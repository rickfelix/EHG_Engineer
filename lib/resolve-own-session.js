/**
 * Resolve Own Session - Deterministic Session Identity Resolution
 *
 * Replaces the buggy heartbeat-based "who am I?" pattern:
 *   .eq('status', 'active').order('heartbeat_at', { ascending: false }).limit(1)
 *
 * That pattern returns whichever session heartbeated most recently, NOT the
 * calling session. When multiple Claude Code sessions are active, this causes
 * session identity collisions.
 *
 * Identity formats in the system:
 *   - claude_sessions.session_id: "session_{uuid8}_{tty}_{pid}" (generated by session-manager.mjs)
 *   - claude_sessions.terminal_id: "win-cc-{ssePort}-{ccPid}" (from getTerminalId() when env var not set)
 *   - Marker file session_id: Claude Code conversation UUID (from SessionStart stdin)
 *   - CLAUDE_SESSION_ID env var: Same as marker file UUID (when CLAUDE_ENV_FILE works)
 *
 * Resolution strategy:
 *   1. CLAUDE_SESSION_ID env var → match session_id column
 *   2. Marker file UUID → match session_id column
 *   3. Computed terminal_id (SSE port + CC PID) → match terminal_id column
 *   4. Heartbeat fallback with warning
 *
 * @module resolve-own-session
 * @see scripts/hooks/capture-session-id.cjs - writes marker files
 * @see lib/terminal-identity.js - getTerminalId() and findClaudeCodePid()
 * @see lib/session-manager.mjs - generates session_id format
 */

import { getTerminalId } from './terminal-identity.js';

/**
 * Get all identity candidates for the current session.
 * Returns multiple IDs to try in priority order.
 *
 * @returns {{envId: string|null, markerId: string|null, terminalId: string|null}}
 */
function getIdentityCandidates() {
  const envId = process.env.CLAUDE_SESSION_ID || null;

  // getTerminalId() returns:
  //   - CLAUDE_SESSION_ID if set (same as envId)
  //   - marker file session_id (UUID) if marker found
  //   - "win-cc-{port}-{pid}" if no marker but SSE port available
  //   - fallback formats otherwise
  const terminalId = getTerminalId();

  // If terminalId differs from envId, it's an additional candidate
  const markerId = (terminalId && terminalId !== envId) ? terminalId : null;

  return { envId, markerId, terminalId };
}

/**
 * Get the current session's best-guess ID.
 * For simple callers that just need a session identifier.
 *
 * @returns {string|null} The session ID, or null if unresolvable
 */
export function getOwnSessionId() {
  const { envId, markerId, terminalId } = getIdentityCandidates();
  return envId || markerId || terminalId || null;
}

/**
 * Resolve the current session's row from claude_sessions, deterministically.
 *
 * Tries multiple identity strategies to find the correct DB row:
 *   1. CLAUDE_SESSION_ID env var → session_id match
 *   2. Marker file / terminal ID → session_id match
 *   3. Any resolved ID → terminal_id column match
 *   4. Heartbeat fallback (legacy, with warning)
 *
 * @param {object} supabase - Supabase client instance
 * @param {object} [options] - Options
 * @param {string} [options.select] - Columns to select
 * @param {boolean} [options.warnOnFallback] - Log warning when falling back to heartbeat (default: true)
 * @returns {Promise<{data: object|null, source: string, sessionId: string|null}>}
 */
export async function resolveOwnSession(supabase, options = {}) {
  const {
    select = 'session_id, sd_id, metadata, status, heartbeat_at, track, claimed_at',
    warnOnFallback = true
  } = options;

  const { envId, markerId, terminalId } = getIdentityCandidates();

  // Strategy 1: Direct lookup by session_id using env var
  if (envId) {
    const { data } = await supabase
      .from('claude_sessions')
      .select(select)
      .eq('session_id', envId)
      .in('status', ['active', 'idle'])
      .maybeSingle();

    if (data) {
      return { data, source: 'env_var', sessionId: envId };
    }
  }

  // Strategy 2: Lookup by session_id using marker file UUID
  if (markerId) {
    const { data } = await supabase
      .from('claude_sessions')
      .select(select)
      .eq('session_id', markerId)
      .in('status', ['active', 'idle'])
      .maybeSingle();

    if (data) {
      return { data, source: 'marker_file', sessionId: markerId };
    }
  }

  // Strategy 3: Lookup by terminal_id column
  // The DB may store terminal_id as "win-cc-{port}" (legacy) or "win-cc-{port}-{pid}" (new).
  // Try all identity candidates plus SSE-port-only format for backward compat.
  const ssePortOnly = process.env.CLAUDE_CODE_SSE_PORT
    ? `win-cc-${process.env.CLAUDE_CODE_SSE_PORT}` : null;
  const candidates = [envId, markerId, terminalId, ssePortOnly]
    .filter((v, i, a) => v && a.indexOf(v) === i); // unique, non-null
  for (const candidate of candidates) {
    const { data } = await supabase
      .from('claude_sessions')
      .select(select)
      .eq('terminal_id', candidate)
      .in('status', ['active', 'idle'])
      .order('heartbeat_at', { ascending: false })
      .limit(1)
      .maybeSingle();

    if (data) {
      return { data, source: 'terminal_id', sessionId: data.session_id };
    }
  }

  // Strategy 4: Fallback to heartbeat-based lookup (legacy behavior)
  if (warnOnFallback) {
    const attempted = candidates.join(', ') || '(none)';
    console.warn('[resolve-own-session] WARNING: Falling back to heartbeat-based session lookup. ' +
      `Tried: ${attempted}`);
  }

  const { data, error } = await supabase
    .from('claude_sessions')
    .select(select)
    .eq('status', 'active')
    .order('heartbeat_at', { ascending: false })
    .limit(1)
    .maybeSingle();

  if (error) {
    return { data: null, source: 'error', sessionId: null };
  }

  return { data: data || null, source: 'heartbeat_fallback', sessionId: data?.session_id || null };
}

export default { getOwnSessionId, resolveOwnSession };
