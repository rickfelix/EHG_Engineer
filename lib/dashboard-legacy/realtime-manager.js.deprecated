import { fileURLToPath } from 'url';
import { dirname } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

/**
 * Real-time Database Subscription Manager
 * Handles Supabase real-time subscriptions for live data updates
 */

import { createClient } from '@supabase/supabase-js';
import path from 'path';
require('dotenv').config({ path: path.join(__dirname, '../..', '.env') });

class RealtimeManager {
  constructor() {
    this.supabase = null;
    this.subscriptions = new Map();
    this.listeners = new Map();
    this.isConnected = false;
  }

  /**
   * Initialize Supabase client with real-time capabilities
   */
  async initialize() {
    try {
      const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
      const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

      if (!supabaseUrl || !supabaseKey || supabaseUrl === 'your_supabase_url_here') {
        console.log('📡 Real-time sync not available - no Supabase credentials');
        return false;
      }

      this.supabase = createClient(supabaseUrl, supabaseKey, {
        realtime: {
          params: {
            eventsPerSecond: 10
          }
        }
      });

      this.isConnected = true;
      console.log('🔄 Real-time sync initialized successfully');
      return true;
    } catch (error) {
      console.error('❌ Failed to initialize real-time sync:', error);
      return false;
    }
  }

  /**
   * Subscribe to Strategic Directives changes
   */
  subscribeToStrategicDirectives(callback) {
    if (!this.isConnected) return null;

    const channel = this.supabase
      .channel('strategic-directives-changes')
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'strategic_directives_v2'
        },
        (payload) => {
          console.log('📍 SD Change detected:', payload.eventType);
          callback({
            type: 'sd_change',
            event: payload.eventType,
            data: payload.new || payload.old,
            old: payload.old
          });
        }
      )
      .subscribe((status) => {
        console.log('🔗 SD Subscription status:', status);
      });

    this.subscriptions.set('strategic_directives', channel);
    return channel;
  }

  /**
   * Subscribe to PRD changes
   */
  subscribeToPRDs(callback) {
    if (!this.isConnected) return null;

    const channel = this.supabase
      .channel('prd-changes')
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'product_requirements_v2'
        },
        (payload) => {
          console.log('📍 PRD Change detected:', payload.eventType);
          callback({
            type: 'prd_change',
            event: payload.eventType,
            data: payload.new || payload.old,
            old: payload.old
          });
        }
      )
      .subscribe((status) => {
        console.log('🔗 PRD Subscription status:', status);
      });

    this.subscriptions.set('product_requirements', channel);
    return channel;
  }

  /**
   * Subscribe to Execution Sequences changes
   */
  subscribeToExecutionSequences(callback) {
    if (!this.isConnected) return null;

    const channel = this.supabase
      .channel('ees-changes')
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'execution_sequences_v2'
        },
        (payload) => {
          console.log('📍 EES Change detected:', payload.eventType);
          callback({
            type: 'ees_change',
            event: payload.eventType,
            data: payload.new || payload.old,
            old: payload.old
          });
        }
      )
      .subscribe((status) => {
        console.log('🔗 EES Subscription status:', status);
      });

    this.subscriptions.set('execution_sequences', channel);
    return channel;
  }

  /**
   * Subscribe to all database changes
   */
  subscribeToAll(callback) {
    const channels = [];
    
    // Subscribe to all tables
    channels.push(this.subscribeToStrategicDirectives(callback));
    channels.push(this.subscribeToPRDs(callback));
    channels.push(this.subscribeToExecutionSequences(callback));

    return channels.filter(Boolean);
  }

  /**
   * Load PRDs for a specific Strategic Directive
   */
  async loadPRDsForSD(directiveId) {
    if (!this.isConnected) return [];

    try {
      const { data, error } = await this.supabase
        .from('product_requirements_v2')
        .select('*')
        .eq('directive_id', directiveId)
        .order('created_at', { ascending: false });

      if (error) {
        console.error('Error loading PRDs for SD:', error);
        return [];
      }

      return data || [];
    } catch (error) {
      console.error('Failed to load PRDs:', error);
      return [];
    }
  }

  /**
   * Load Execution Sequences for a specific Strategic Directive
   */
  async loadEESForSD(directiveId) {
    if (!this.isConnected) return [];

    try {
      const { data, error } = await this.supabase
        .from('execution_sequences_v2')
        .select('*')
        .eq('directive_id', directiveId)
        .order('sequence_number', { ascending: true });

      if (error) {
        console.error('Error loading EES for SD:', error);
        return [];
      }

      return data || [];
    } catch (error) {
      console.error('Failed to load EES:', error);
      return [];
    }
  }

  /**
   * Load complete SD details including PRDs and EES
   */
  async loadSDDetails(directiveId) {
    if (!this.isConnected) return null;

    try {
      // Load SD
      const { data: sd, error: sdError } = await this.supabase
        .from('strategic_directives_v2')
        .select('*')
        .eq('id', directiveId)
        .single();

      if (sdError) {
        console.error('Error loading SD details:', sdError);
        return null;
      }

      // Load associated PRDs
      const prds = await this.loadPRDsForSD(directiveId);
      
      // Load associated EES
      const ees = await this.loadEESForSD(directiveId);

      return {
        ...sd,
        prds,
        executionSequences: ees,
        totalPRDs: prds.length,
        totalEES: ees.length,
        completedPRDs: prds.filter(p => p.status === 'approved' || p.status === 'complete').length,
        completedEES: ees.filter(e => e.status === 'completed').length
      };
    } catch (error) {
      console.error('Failed to load SD details:', error);
      return null;
    }
  }

  /**
   * Unsubscribe from a specific channel
   */
  unsubscribe(channelName) {
    const channel = this.subscriptions.get(channelName);
    if (channel) {
      channel.unsubscribe();
      this.subscriptions.delete(channelName);
      console.log(`🔌 Unsubscribed from ${channelName}`);
    }
  }

  /**
   * Unsubscribe from all channels
   */
  unsubscribeAll() {
    for (const [name, channel] of this.subscriptions) {
      channel.unsubscribe();
      console.log(`🔌 Unsubscribed from ${name}`);
    }
    this.subscriptions.clear();
  }

  /**
   * Clean up and close connections
   */
  async cleanup() {
    this.unsubscribeAll();
    if (this.supabase) {
      await this.supabase.removeAllChannels();
    }
    this.isConnected = false;
    console.log('🧹 Real-time manager cleaned up');
  }
}

export default RealtimeManager;