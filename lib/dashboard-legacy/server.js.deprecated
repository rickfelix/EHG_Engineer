import { fileURLToPath } from 'url';
import { dirname } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

#!/usr/bin/env node

/**
 * LEO Protocol Dashboard Server
 * Express server with WebSocket support for real-time updates
 */

import express from 'express';
import http from 'http';
import WebSocket from 'ws';
import path from 'path';
import fs from 'fs';
import cors from 'cors';
import chokidar from 'chokidar';
import OpenAI from 'openai';
require('dotenv').config({ path: path.join(__dirname, '../../.env') });
import DatabaseLoader from './database-loader';
import RealtimeManager from './realtime-manager';
import RefreshAPI from './refresh-api';
import LEOVersionDetector from './version-detector';

// Initialize Express app
const app = express();
const server = http.createServer(app);
const wss = new WebSocket.Server({ server });

// Configuration
const PORT = process.env.DASHBOARD_PORT || 3000;
const PROJECT_ROOT = path.resolve(__dirname, '../..');

// Global WebSocket clients tracking for refresh API
global.wsClients = new Set();

// Initialize components
const dbLoader = new DatabaseLoader();
const realtimeManager = new RealtimeManager();
const refreshAPI = new RefreshAPI(server, dbLoader);
const versionDetector = new LEOVersionDetector(PROJECT_ROOT);

// Initialize OpenAI if API key is provided
let openai = null;
if (process.env.OPENAI_API_KEY) {
  openai = new OpenAI({
    apiKey: process.env.OPENAI_API_KEY
  });
  console.log('✅ OpenAI integration enabled');
} else {
  console.log('⚠️ OpenAI API key not found - SD Assistant will use fallback mode');
}

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.static(path.join(__dirname, 'client', 'dist')));

// State management
let dashboardState = {
  leoProtocol: {
    version: '4.1.2_database_first', // Will be updated async
    activeRole: null,
    currentSD: null,
    currentPRD: null,
    phase: null
  },
  context: {
    usage: 0,
    total: 180000,
    breakdown: {}
  },
  handoffs: [],
  strategicDirectives: [],
  prds: [],
  checklists: {},
  progress: {
    overall: 0,
    byPhase: {}
  }
};

// Load initial state
async function loadState() {
  try {
    // Load LEO status
    const statusPath = path.join(PROJECT_ROOT, '.leo-status.json');
    if (fs.existsSync(statusPath)) {
      const status = JSON.parse(fs.readFileSync(statusPath, 'utf8'));
      dashboardState.leoProtocol = {
        ...dashboardState.leoProtocol,
        ...status,
        version: dashboardState.leoProtocol.version // Use current state version
      };
    }

    // Load context state
    const contextPath = path.join(PROJECT_ROOT, '.leo-context-state.json');
    if (fs.existsSync(contextPath)) {
      const context = JSON.parse(fs.readFileSync(contextPath, 'utf8'));
      // If currentUsage exists, it's the breakdown, not the full context object
      if (context.currentUsage) {
        const breakdown = context.currentUsage;
        const usage = Object.values(breakdown).reduce((sum, val) => sum + (val || 0), 0);
        dashboardState.context = {
          usage: usage,
          total: 180000,
          breakdown: breakdown
        };
      } else {
        dashboardState.context = context;
      }
    }

    // Load handoff state
    const handoffPath = path.join(PROJECT_ROOT, '.leo-handoff-state.json');
    if (fs.existsSync(handoffPath)) {
      const handoff = JSON.parse(fs.readFileSync(handoffPath, 'utf8'));
      dashboardState.handoffs = handoff.history || [];
    }

    // Load from database if connected, fallback to filesystem
    if (dbLoader.isConnected) {
      console.log('📊 Loading data from database...');
      
      // Load PRDs first so they're available for SD progress calculation
      dashboardState.prds = await dbLoader.loadPRDs();
      
      // Load Strategic Directives (will now find associated PRDs)
      dashboardState.strategicDirectives = await dbLoader.loadStrategicDirectives();
      
      // Load Execution Sequences
      dashboardState.executionSequences = await dbLoader.loadExecutionSequences();
      
      console.log('✅ Database load complete');
    } else {
      console.log('⚠️  Database not connected - loading from filesystem');
      
      // Fallback to filesystem loading
      const prdDir = path.join(PROJECT_ROOT, 'docs', 'prds');
      if (fs.existsSync(prdDir)) {
        dashboardState.prds = loadDocuments(prdDir, 'PRD');
      }

      const sdDir = path.join(PROJECT_ROOT, 'docs', 'strategic-directives');
      if (fs.existsSync(sdDir)) {
        dashboardState.strategicDirectives = loadDocuments(sdDir, 'SD');
      }
    }

    // Always ensure version is current from database
    const detectedVersion = await versionDetector.detectLatestVersion();
    dashboardState.leoProtocol.version = detectedVersion;
    console.log(`📋 LEO Protocol version set to: ${dashboardState.leoProtocol.version}`);

  } catch (error) {
    console.error('Error loading state:', error);
  }
}

// Load documents from directory
function loadDocuments(dir, type) {
  const documents = [];
  try {
    const files = fs.readdirSync(dir);
    for (const file of files) {
      if (file.endsWith('.md')) {
        const filepath = path.join(dir, file);
        const content = fs.readFileSync(filepath, 'utf8');
        const doc = parseDocument(content, file, type);
        documents.push(doc);
      }
    }
  } catch (error) {
    console.error(`Error loading ${type} documents:`, error);
  }
  return documents;
}

// Parse markdown document
function parseDocument(content, filename, type) {
  const lines = content.split('\n');
  const doc = {
    id: filename.replace('.md', ''),
    type,
    filename,
    title: '',
    content,
    metadata: {},
    checklist: [],
    progress: 0
  };

  // Extract title (first # heading)
  const titleMatch = content.match(/^#\s+(.+)$/m);
  if (titleMatch) {
    doc.title = titleMatch[1];
  }

  // Extract metadata (key: value pairs)
  const metadataRegex = /^\*\*(.+?)\*\*:\s*(.+)$/gm;
  let match;
  while ((match = metadataRegex.exec(content)) !== null) {
    doc.metadata[match[1]] = match[2];
  }

  // Extract checklist items (handles both Unix and Windows line endings)
  const checklistRegex = /^-\s*\[([ x])\]\s+(.+?)[\r\n]*$/gm;
  while ((match = checklistRegex.exec(content)) !== null) {
    doc.checklist.push({
      checked: match[1] === 'x',
      text: match[2].trim()  // Trim any trailing whitespace/CR
    });
  }

  // Calculate progress using LEO Protocol v4.0 three-phase workflow
  // If database already has progress=100, use it directly (fixes SD-2025-001)
  if (doc.progress === 100) {
    console.log(`Using database progress (${doc.progress}%) for completed document: ${doc.id}`);
  } else {
    doc.progress = calculateLEOProtocolProgress(doc);
  }

  return doc;
}

// Calculate overall progress
function calculateProgress() {
  const allChecklists = [
    ...dashboardState.strategicDirectives,
    ...dashboardState.prds
  ];

  if (allChecklists.length === 0) {
    dashboardState.progress.overall = 0;
    return;
  }

  const totalProgress = allChecklists.reduce((sum, doc) => sum + doc.progress, 0);
  dashboardState.progress.overall = Math.round(totalProgress / allChecklists.length);

  // Calculate by phase
  dashboardState.progress.byPhase = {
    strategic: calculatePhaseProgress(dashboardState.strategicDirectives),
    planning: calculatePhaseProgress(dashboardState.prds.filter(p => p.metadata.Status === 'Planning')),
    execution: calculatePhaseProgress(dashboardState.prds.filter(p => p.metadata.Status === 'In Progress')),
    verification: calculatePhaseProgress(dashboardState.prds.filter(p => p.metadata.Status === 'Testing'))
  };
}

// Calculate progress according to LEO Protocol v4.0 three-phase workflow
function calculateLEOProtocolProgress(doc) {
  // Add validation and error handling to prevent silent failures
  if (!doc || typeof doc !== 'object') {
    console.error('❌ calculateLEOProtocolProgress: Invalid document object', doc?.id || 'unknown');
    return 0;
  }

  // Define the phases of LEO Protocol v4.0 with LEAD returning for validation
  // The workflow is: LEAD (planning) → PLAN → EXEC → LEAD (validation)
  // LEAD has two phases: initial strategic planning and final validation
  const phases = {
    LEAD_PLANNING: { weight: 25, name: 'LEAD Strategic Planning' },    // Phase 1: Strategic planning
    PLAN: { weight: 25, name: 'PLAN Technical Planning' },             // Phase 2: Technical planning  
    EXEC: { weight: 25, name: 'EXEC Implementation' },                 // Phase 3: Implementation
    LEAD_VALIDATION: { weight: 25, name: 'LEAD Validation' }           // Phase 4: LEAD returns for validation
  };

  let totalProgress = 0;
  let currentPhase = 'LEAD';
  let phaseStatus = '';
  let phaseDetails = {
    LEAD: { complete: false, progress: 0 },
    PLAN: { complete: false, progress: 0 },
    EXEC: { complete: false, progress: 0 }
  };
  
  // Track uncompleted items for validation
  let uncompletedItems = [];
  
  // Check database status if available
  let dbStatus = doc.metadata?.Status || null;
  
  // Determine document type (SD or PRD) - check PRD first since PRD filenames contain SD
  const isPRD = doc.type === 'PRD' || doc.filename?.startsWith('PRD-');
  const isSD = !isPRD && (doc.type === 'SD' || doc.filename?.includes('SD-'));
  
  // For SD documents, calculate LEAD phase and check for associated PRD
  if (isSD) {
    const leadChecklist = doc.checklist || [];
    if (leadChecklist.length > 0) {
      const leadCompleted = leadChecklist.filter(item => item.checked).length;
      const leadUncompleted = leadChecklist.filter(item => !item.checked);
      const leadCompletionRatio = leadCompleted / leadChecklist.length;
      
      // Track uncompleted LEAD items
      if (leadUncompleted.length > 0) {
        uncompletedItems.push({
          phase: 'LEAD',
          source: 'Strategic Directive',
          items: leadUncompleted.map(item => item.text)
        });
      }
      
      // LEAD Planning phase contributes its weight * completion ratio
      phaseDetails.LEAD.progress = leadCompletionRatio * 100;
      phaseDetails.LEAD.complete = leadCompletionRatio === 1;
      
      // Start with LEAD Planning phase contribution
      totalProgress = leadCompletionRatio * phases.LEAD_PLANNING.weight;
      
      // Check if there's an associated PRD to get PLAN and EXEC progress
      const prdId = `PRD-${doc.id || doc.filename?.replace('SD-', '')}`;
      console.log(`\n=== SD PROGRESS CHECK ===`);
      console.log(`SD ID: ${doc.id}`);
      console.log(`Looking for PRD ID: ${prdId}`);
      console.log(`Available PRDs: ${dashboardState.prds.map(p => p.id).join(', ')}`);
      
      const associatedPRD = dashboardState.prds.find(prd => 
        prd.id === prdId || prd.filename?.includes(doc.id?.replace('SD-', ''))
      );
      
      if (associatedPRD) {
        console.log(`Found associated PRD: ${associatedPRD.id}`);
        // PRD already has its progress calculated during load
        console.log(`PRD progress: ${associatedPRD.progress}%`);
        
        // The PRD progress already includes all three phases (LEAD+PLAN+EXEC)
        // This is the TRUE progress of the Strategic Directive
        return associatedPRD.progress;
      } else {
        console.log(`No associated PRD found`);
        // No PRD yet, so only LEAD phase counts (max 33.33%)
        if (phaseDetails.LEAD.complete) {
          currentPhase = 'PLAN';
          phaseStatus = 'LEAD Complete, awaiting PLAN Agent';
          // LEAD Planning complete but no PRD means we're at 25%
          totalProgress = phases.LEAD_PLANNING.weight;
        } else {
          currentPhase = 'LEAD';
          phaseStatus = `LEAD In Progress (${leadCompleted}/${leadChecklist.length} items)`;
          // LEAD Planning in progress
          totalProgress = leadCompletionRatio * phases.LEAD_PLANNING.weight;
        }
      }
    }
    
    // Return SD progress (will be max 33.33% without PRD, or full progress with PRD)
    return Math.round(totalProgress);
  }

  // For PRD documents, calculate all three phases
  if (isPRD) {
    console.log(`\n=== PRD PROGRESS CALCULATION ===`);
    console.log(`PRD: ${doc.filename}`);
    console.log(`Total checklist items: ${doc.checklist?.length || 0}`);
    
    // PRD exists means LEAD Planning phase is complete
    phaseDetails.LEAD.complete = true;
    phaseDetails.LEAD.progress = 100;
    totalProgress = phases.LEAD_PLANNING.weight; // LEAD Planning is complete
    
    // Use the current document's checklist (it's already a PRD)
    if (doc.checklist && doc.checklist.length > 0) {
        // Separate PLAN handoff checklist from EXEC implementation items
        const planHandoffKeywords = [
          'PRD created and saved',
          'SD requirements mapped',
          'Technical specifications complete',
          'Architecture decisions documented',
          'Performance requirements clearly defined',
          'Accessibility requirements comprehensive',
          'Prerequisites verified',
          'Test requirements defined',
          'test scenarios documented',
          'Performance benchmarks established',
          'testing criteria specified',
          'testing matrix created',
          'Acceptance criteria clear',
          'Acceptance criteria unambiguous',
          'Acceptance criteria comprehensive',
          'Technical risks identified',
          'Implementation risks assessed',
          'Dependencies documented',
          'Contingency plans established',
          'Success metrics measurable',
          'Technical architecture documented',
          'Implementation phases clearly defined',
          'Code examples provided',
          'Documentation requirements specified',
          'Risk mitigation strategies',
          'Context usage optimized',
          'Executive summary created',
          'summary created'
        ];
        
        // Find the PLAN Agent Handoff Checklist section
        // In the PRD structure, PLAN handoff items come after "## PLAN Agent Handoff Checklist"
        // Look for position in document or use specific markers
        const planHandoffStartIndex = doc.content.indexOf('## PLAN Agent Handoff Checklist');
        
        let planHandoffItems = [];
        let execImplementationItems = [];
        
        if (planHandoffStartIndex > -1) {
          // Items after this header are PLAN handoff items
          // Count lines to determine which checklist items are in this section
          const beforeHandoff = doc.content.substring(0, planHandoffStartIndex);
          const checklistItemsBefore = (beforeHandoff.match(/-\s*\[[ x]\]/g) || []).length;
          
          // Debug logging
          console.log(`PRD Analysis: Found PLAN handoff at position ${planHandoffStartIndex}`);
          console.log(`Checklist items before handoff section: ${checklistItemsBefore}`);
          console.log(`Total checklist items: ${doc.checklist.length}`);
          
          // Split checklist items based on position
          planHandoffItems = doc.checklist.slice(checklistItemsBefore);
          execImplementationItems = doc.checklist.slice(0, checklistItemsBefore);
          
          console.log(`PLAN items: ${planHandoffItems.length}, checked: ${planHandoffItems.filter(i => i.checked).length}`);
          console.log(`EXEC items: ${execImplementationItems.length}, checked: ${execImplementationItems.filter(i => i.checked).length}`);
        } else {
          // Fallback: use keyword matching for older PRDs
          planHandoffItems = doc.checklist.filter(item => {
            const text = item.text.toLowerCase();
            return (
              text.includes('prd created and saved') ||
              text.includes('requirements mapped') ||
              text.includes('specifications complete') ||
              text.includes('architecture documented') ||
              text.includes('requirements clearly') ||
              text.includes('requirements comprehensive') ||
              text.includes('prerequisites verified') ||
              text.includes('requirements defined') ||
              text.includes('scenarios documented') ||
              text.includes('benchmarks established') ||
              text.includes('criteria specified') ||
              text.includes('matrix created') ||
              text.includes('criteria clear') ||
              text.includes('criteria unambiguous') ||
              text.includes('criteria comprehensive') ||
              text.includes('risks identified') ||
              text.includes('risks assessed') ||
              text.includes('dependencies documented') ||
              text.includes('contingency plans') ||
              text.includes('metrics measurable') ||
              text.includes('architecture documented') ||
              text.includes('phases clearly') ||
              text.includes('examples provided') ||
              text.includes('requirements specified') ||
              text.includes('mitigation strategies') ||
              text.includes('usage optimized') ||
              text.includes('summary created')
            );
          });
          
          execImplementationItems = doc.checklist.filter(item => 
            !planHandoffItems.includes(item)
          );
        }
        
        
        // Calculate PLAN phase completion based on handoff checklist only
        const planHandoffCompleted = planHandoffItems.filter(item => item.checked).length;
        const planHandoffTotal = planHandoffItems.length;
        const planCompletionRatio = planHandoffTotal > 0 ? planHandoffCompleted / planHandoffTotal : 1;
        
        console.log(`\n=== PLAN PHASE CALCULATION ===`);
        console.log(`PLAN checklist items: ${planHandoffTotal}`);
        console.log(`PLAN completed items: ${planHandoffCompleted}`);
        console.log(`PLAN completion ratio: ${planCompletionRatio}`);
        
        // Calculate EXEC phase completion based on implementation items
        const execCompleted = execImplementationItems.filter(item => item.checked).length;
        const execTotal = execImplementationItems.length;
        const execCompletionRatio = execTotal > 0 ? execCompleted / execTotal : 0;
        
        // Track uncompleted items separately
        const uncompletedPlanItems = planHandoffItems.filter(item => !item.checked);
        const uncompletedExecItems = execImplementationItems.filter(item => !item.checked);
        
        if (uncompletedPlanItems.length > 0) {
          uncompletedItems.push({
            phase: 'PLAN',
            source: 'PRD Handoff',
            items: uncompletedPlanItems.map(item => item.text)
          });
        }
        
        if (uncompletedExecItems.length > 0) {
          uncompletedItems.push({
            phase: 'EXEC',
            source: 'PRD Implementation',
            items: uncompletedExecItems.map(item => item.text)
          });
        }
        
        // PLAN phase is complete when handoff checklist is done
        phaseDetails.PLAN.progress = planCompletionRatio * 100;
        phaseDetails.PLAN.complete = planCompletionRatio === 1;
        
        // EXEC phase progress based on implementation items
        phaseDetails.EXEC.progress = execCompletionRatio * 100;
        phaseDetails.EXEC.complete = execCompletionRatio === 1;
        
        // Check for VALIDATION phase (when EXEC is complete)
        let validationComplete = false;
        if (phaseDetails.EXEC.complete) {
          // Look for validation markers in the document
          const hasValidation = doc.content && (
            doc.content.includes('✅ Strategic objectives verified') ||
            doc.content.includes('VALIDATION COMPLETE') ||
            doc.content.includes('Ready for production deployment')
          );
          validationComplete = hasValidation;
        }
        
        // Calculate total progress from all four phases
        totalProgress = phases.LEAD_PLANNING.weight + 
                       (planCompletionRatio * phases.PLAN.weight) + 
                       (execCompletionRatio * phases.EXEC.weight) +
                       (validationComplete ? phases.LEAD_VALIDATION.weight : 0);
        
        console.log(`PRD Progress: LEAD_PLANNING=${phases.LEAD_PLANNING.weight.toFixed(1)}, PLAN=${(planCompletionRatio * phases.PLAN.weight).toFixed(1)}, EXEC=${(execCompletionRatio * phases.EXEC.weight).toFixed(1)}, LEAD_VALIDATION=${validationComplete ? phases.LEAD_VALIDATION.weight : 0}, Total=${totalProgress.toFixed(1)}%`);
        
        // Determine current phase and status
        if (!phaseDetails.PLAN.complete) {
          currentPhase = 'PLAN';
          phaseStatus = `PLAN In Progress (${planHandoffCompleted}/${planHandoffTotal} handoff items)`;
        } else if (!phaseDetails.EXEC.complete) {
          currentPhase = 'EXEC';
          phaseStatus = `EXEC In Progress (${execCompleted}/${execTotal} implementation tasks)`;
        } else if (!validationComplete) {
          currentPhase = 'LEAD_VALIDATION';
          phaseStatus = 'EXEC Complete - Awaiting LEAD Agent strategic validation';
        } else {
          currentPhase = 'COMPLETE';
          phaseStatus = 'All phases complete - Ready for production deployment';
        }
      } else {
        // PRD exists but no checklist - this was the root cause of SD-2025-001 issue
        console.warn(`⚠️  PRD ${doc.id} has no checklist - dashboard calculation may be inaccurate`);
        console.warn(`   Consider adding checklist items or using database progress field directly`);
        
        // Check if database has progress field we can use
        if (doc.progress && typeof doc.progress === 'number' && doc.progress > 0) {
          console.log(`📊 Using database progress field (${doc.progress}%) instead of calculation`);
          return doc.progress;
        }
        
        // Fallback: PRD exists but no checklist - assume PRD just created, all phases start
        phaseDetails.PLAN.progress = 0;
        phaseDetails.EXEC.progress = 0;
        totalProgress = phases.LEAD_PLANNING.weight; // Only LEAD Planning is complete
        currentPhase = 'PLAN';
        phaseStatus = 'PLAN In Progress - PRD created without checklist (incomplete data)';
        
        // Log for debugging purposes
        console.log(`📋 PRD ${doc.id} calculation fallback: LEAD=${phases.LEAD_PLANNING.weight}%, others=0%`);
      }
    
    // Return PRD progress (all three phases)
    return Math.round(totalProgress);
  }

  // Fallback for documents that aren't clearly SD or PRD
  // Default to simple progress calculation based on checklist
  if (!isSD && !isPRD) {
    const checklist = doc.checklist || [];
    if (checklist.length > 0) {
      const completed = checklist.filter(item => item.checked).length;
      const completionRatio = completed / checklist.length;
      totalProgress = completionRatio * 100;
      currentPhase = 'Unknown';
      phaseStatus = `Progress: ${completed}/${checklist.length} items complete`;
    }
    return Math.round(totalProgress);
  }
  
  // This completes the function - old logic has been removed
  return Math.round(totalProgress);
}

// Validate Strategic Directive completion requirements
function validateSDCompletion(doc, phaseDetails) {
  const checks = {
    requirementsCoverage: { passed: false, score: 0, details: '' },
    testCoverage: { passed: false, score: 0, details: '' },
    documentation: { passed: false, score: 0, details: '' },
    codeQuality: { passed: false, score: 0, details: '' },
    buildStatus: { passed: false, score: 0, details: '' }
  };
  
  // Check 1: Requirements coverage
  if (phaseDetails.LEAD.complete && phaseDetails.PLAN.complete) {
    checks.requirementsCoverage.passed = true;
    checks.requirementsCoverage.score = 100;
    checks.requirementsCoverage.details = 'All requirements documented';
  } else {
    checks.requirementsCoverage.score = (phaseDetails.LEAD.progress + phaseDetails.PLAN.progress) / 2;
    checks.requirementsCoverage.details = 'Requirements incomplete';
  }
  
  // Check 2: Test coverage
  if (phaseDetails.EXEC.tasks) {
    const testTasks = phaseDetails.EXEC.tasks.items.filter(item => 
      item.text.toLowerCase().includes('test')
    );
    const completedTests = testTasks.filter(item => item.checked).length;
    checks.testCoverage.score = testTasks.length > 0 ? (completedTests / testTasks.length) * 100 : 0;
    checks.testCoverage.passed = checks.testCoverage.score >= 80;
    checks.testCoverage.details = `${completedTests}/${testTasks.length} test tasks complete`;
  }
  
  // Check 3: Documentation quality
  const docPath = path.join(PROJECT_ROOT, 'docs');
  if (fs.existsSync(docPath)) {
    const files = fs.readdirSync(docPath, { recursive: true });
    const mdFiles = files.filter(f => f.toString().endsWith('.md'));
    checks.documentation.score = Math.min(100, mdFiles.length * 20); // 20 points per doc file, max 100
    checks.documentation.passed = checks.documentation.score >= 60;
    checks.documentation.details = `${mdFiles.length} documentation files`;
  }
  
  // Check 4: Code quality (lint/type checks)
  if (phaseDetails.EXEC.indicators) {
    const buildStatus = phaseDetails.EXEC.indicators.indicators.build;
    if (buildStatus && buildStatus.status) {
      checks.codeQuality.score = 100;
      checks.codeQuality.passed = true;
      checks.codeQuality.details = 'Build successful';
    } else {
      checks.codeQuality.score = 50;
      checks.codeQuality.details = buildStatus?.details || 'Build not verified';
    }
  }
  
  // Check 5: Build status
  const buildPath = path.join(PROJECT_ROOT, 'lib/dashboard/client/dist');
  if (fs.existsSync(buildPath)) {
    const stats = fs.statSync(buildPath);
    const hoursSinceModified = (Date.now() - stats.mtime) / (1000 * 60 * 60);
    if (hoursSinceModified < 1) {
      checks.buildStatus.score = 100;
      checks.buildStatus.passed = true;
      checks.buildStatus.details = 'Fresh build available';
    } else {
      checks.buildStatus.score = Math.max(0, 100 - (hoursSinceModified * 10));
      checks.buildStatus.details = `Build ${Math.round(hoursSinceModified)} hours old`;
    }
  }
  
  // Calculate overall QA score
  const totalScore = Object.values(checks).reduce((sum, check) => sum + check.score, 0);
  const avgScore = totalScore / Object.keys(checks).length;
  
  return {
    score: Math.round(avgScore),
    checks: checks,
    passed: avgScore >= 90,
    summary: `QA Score: ${Math.round(avgScore)}% - ${avgScore >= 90 ? 'PASSED' : 'NEEDS IMPROVEMENT'}`
  };
}

// Generate comprehensive progress audit report
function generateProgressAudit(sd) {
  const audit = {
    id: sd.id,
    title: sd.title,
    timestamp: new Date().toISOString(),
    summary: {
      calculatedProgress: sd.progress,
      databaseStatus: sd.metadata?.Status || 'Not set',
      currentPhase: sd.leoPhase?.current || 'Unknown',
      canComplete: sd.leoPhase?.validation?.canComplete || false
    },
    phaseBreakdown: {
      LEAD: {
        weight: 33.33,
        progress: sd.leoPhase?.phaseProgress?.LEAD?.progress || 0,
        complete: sd.leoPhase?.phaseProgress?.LEAD?.complete || false,
        checklist: []
      },
      PLAN: {
        weight: 33.33,
        progress: sd.leoPhase?.phaseProgress?.PLAN?.progress || 0,
        complete: sd.leoPhase?.phaseProgress?.PLAN?.complete || false,
        checklist: []
      },
      EXEC: {
        weight: 33.34,
        progress: sd.leoPhase?.phaseProgress?.EXEC?.progress || 0,
        complete: sd.leoPhase?.phaseProgress?.EXEC?.complete || false,
        checklist: [],
        indicators: null
      }
    },
    validation: {
      passed: sd.leoPhase?.validation?.canComplete || false,
      uncompletedItems: sd.leoPhase?.validation?.uncompletedCount || 0,
      details: sd.leoPhase?.validation?.details || []
    },
    calculations: {
      formula: 'LEAD(33.33%) + PLAN(33.33%) + EXEC(33.34%)',
      breakdown: []
    },
    recommendations: []
  };
  
  // Add SD checklist items to LEAD phase
  if (sd.checklist) {
    audit.phaseBreakdown.LEAD.checklist = sd.checklist.map(item => ({
      text: item.text,
      checked: item.checked,
      phase: 'LEAD'
    }));
  }
  
  // Load PRD checklist if available
  const prdPath = sd.metadata?.PRD || `docs/prds/PRD-${sd.id}.md`;
  const prdFullPath = path.join(PROJECT_ROOT, prdPath);
  
  if (fs.existsSync(prdFullPath)) {
    try {
      const prdContent = fs.readFileSync(prdFullPath, 'utf8');
      const prdDoc = parseDocument(prdContent, path.basename(prdPath));
      
      if (prdDoc.checklist) {
        // Use structural position to categorize PRD items
        const planHandoffStartIndex = prdContent.indexOf('## PLAN Agent Handoff Checklist');
        
        if (planHandoffStartIndex > -1) {
          // Count checklist items before the PLAN handoff section
          const beforeHandoff = prdContent.substring(0, planHandoffStartIndex);
          const checklistItemsBefore = (beforeHandoff.match(/- \[[ x]\]/g) || []).length;
          
          // Split checklist based on position
          const execItems = prdDoc.checklist.slice(0, checklistItemsBefore);
          const planItems = prdDoc.checklist.slice(checklistItemsBefore);
          
          // Add EXEC items to audit
          execItems.forEach(item => {
            audit.phaseBreakdown.EXEC.checklist.push({
              text: item.text,
              checked: item.checked,
              phase: 'EXEC',
              source: 'PRD'
            });
          });
          
          // Add PLAN items to audit
          planItems.forEach(item => {
            audit.phaseBreakdown.PLAN.checklist.push({
              text: item.text,
              checked: item.checked,
              phase: 'PLAN',
              source: 'PRD'
            });
          });
        } else {
          // Fallback for older PRDs without clear section markers
          prdDoc.checklist.forEach(item => {
            // Use simple heuristic: checked items at end are likely PLAN handoff
            if (item.checked) {
              audit.phaseBreakdown.PLAN.checklist.push({
                text: item.text,
                checked: item.checked,
                phase: 'PLAN',
                source: 'PRD'
              });
            } else {
              audit.phaseBreakdown.EXEC.checklist.push({
                text: item.text,
                checked: item.checked,
                phase: 'EXEC',
                source: 'PRD'
              });
            }
          });
        }
      }
    } catch (error) {
      audit.recommendations.push('Error reading PRD file - check file path and permissions');
    }
  } else {
    audit.recommendations.push('No PRD found - PLAN phase cannot progress');
  }
  
  // Add EXEC indicators if available
  if (sd.leoPhase?.phaseProgress?.EXEC?.indicators) {
    audit.phaseBreakdown.EXEC.indicators = sd.leoPhase.phaseProgress.EXEC.indicators;
  }
  
  // Calculate detailed breakdown
  const leadContribution = (audit.phaseBreakdown.LEAD.progress / 100) * 33.33;
  const planContribution = (audit.phaseBreakdown.PLAN.progress / 100) * 33.33;
  const execContribution = (audit.phaseBreakdown.EXEC.progress / 100) * 33.34;
  
  audit.calculations.breakdown = [
    `LEAD: ${audit.phaseBreakdown.LEAD.progress}% × 33.33% = ${leadContribution.toFixed(2)}%`,
    `PLAN: ${audit.phaseBreakdown.PLAN.progress}% × 33.33% = ${planContribution.toFixed(2)}%`,
    `EXEC: ${audit.phaseBreakdown.EXEC.progress}% × 33.34% = ${execContribution.toFixed(2)}%`,
    `Total: ${(leadContribution + planContribution + execContribution).toFixed(2)}%`
  ];
  
  // Generate recommendations
  if (!audit.phaseBreakdown.LEAD.complete) {
    const unchecked = audit.phaseBreakdown.LEAD.checklist.filter(i => !i.checked).length;
    audit.recommendations.push(`Complete ${unchecked} remaining LEAD checklist items`);
  }
  
  if (!audit.phaseBreakdown.PLAN.complete && audit.phaseBreakdown.LEAD.complete) {
    const unchecked = audit.phaseBreakdown.PLAN.checklist.filter(i => !i.checked).length;
    if (unchecked > 0) {
      audit.recommendations.push(`Complete ${unchecked} remaining PLAN checklist items in PRD`);
    }
  }
  
  if (!audit.phaseBreakdown.EXEC.complete && audit.phaseBreakdown.PLAN.complete) {
    const unchecked = audit.phaseBreakdown.EXEC.checklist.filter(i => !i.checked).length;
    if (unchecked > 0) {
      audit.recommendations.push(`Complete ${unchecked} remaining EXEC implementation tasks`);
    }
  }
  
  if (audit.validation.uncompletedItems > 0) {
    audit.recommendations.push(`Cannot mark SD as complete - ${audit.validation.uncompletedItems} items remain unchecked`);
  }
  
  if (audit.summary.databaseStatus === 'Completed' && !audit.validation.passed) {
    audit.recommendations.push('WARNING: Database shows completed but validation failed - review required');
  }
  
  return audit;
}

// Get remaining tasks for each phase
function getRemainingTasks(phaseDetails) {
  const remaining = [];
  
  if (!phaseDetails.LEAD.complete) {
    remaining.push({
      phase: 'LEAD',
      description: 'Complete Strategic Directive checklist items'
    });
  }
  
  if (!phaseDetails.PLAN.complete) {
    remaining.push({
      phase: 'PLAN',
      description: 'Complete PRD planning and checklist items'
    });
  }
  
  if (!phaseDetails.EXEC.complete) {
    if (phaseDetails.EXEC.tasks && phaseDetails.EXEC.tasks.items) {
      // Show specific uncompleted tasks
      const uncompletedTasks = phaseDetails.EXEC.tasks.items
        .filter(item => !item.checked)
        .map(item => item.text);
      
      if (uncompletedTasks.length > 0) {
        remaining.push({
          phase: 'EXEC',
          description: 'Complete implementation tasks',
          tasks: uncompletedTasks
        });
      }
    } else if (phaseDetails.EXEC.indicators) {
      // Show missing indicators
      const missing = Object.entries(phaseDetails.EXEC.indicators.indicators)
        .filter(([key, val]) => !val.status)
        .map(([key, val]) => `${key}: ${val.details || 'not found'}`);
      
      if (missing.length > 0) {
        remaining.push({
          phase: 'EXEC',
          description: 'Complete implementation requirements',
          tasks: missing
        });
      }
    } else {
      remaining.push({
        phase: 'EXEC',
        description: 'Begin implementation phase'
      });
    }
  }
  
  
  return remaining;
}

// Check if implementation is complete (EXEC phase indicators)
function checkImplementationComplete(doc) {
  // More accurate implementation checking
  const indicators = {
    tests: { status: false, details: '' },
    build: { status: false, details: '' },
    documentation: { status: false, details: '' },
    deployment: { status: false, details: '' }
  };
  
  // Check for actual test files (not just directory)
  const testPaths = [
    'tests',
    '__tests__',
    'lib/dashboard/client/src/__tests__',
    'lib/dashboard/client/src/**/*.test.js',
    'lib/dashboard/client/src/**/*.spec.js'
  ];
  
  for (const testPath of testPaths) {
    const fullPath = path.join(PROJECT_ROOT, testPath);
    if (fs.existsSync(fullPath)) {
      try {
        const stats = fs.statSync(fullPath);
        if (stats.isDirectory()) {
          const files = fs.readdirSync(fullPath);
          const testFiles = files.filter(f => f.endsWith('.test.js') || f.endsWith('.spec.js'));
          if (testFiles.length > 0) {
            indicators.tests.status = true;
            indicators.tests.details = `${testFiles.length} test files found`;
            break;
          }
        }
      } catch (e) {
        // Continue checking other paths
      }
    }
  }
  
  // Check for recent build artifacts (not stale)
  const buildPaths = [
    'lib/dashboard/client/dist',
    'dist',
    'build'
  ];
  
  for (const buildPath of buildPaths) {
    const fullPath = path.join(PROJECT_ROOT, buildPath);
    if (fs.existsSync(fullPath)) {
      try {
        const stats = fs.statSync(fullPath);
        const hoursSinceModified = (Date.now() - stats.mtime) / (1000 * 60 * 60);
        // Consider build fresh if modified within last 24 hours
        if (hoursSinceModified < 24) {
          indicators.build.status = true;
          indicators.build.details = `Build updated ${Math.round(hoursSinceModified)} hours ago`;
          break;
        } else {
          indicators.build.details = `Build is stale (${Math.round(hoursSinceModified)} hours old)`;
        }
      } catch (e) {
        // Continue checking
      }
    }
  }
  
  // Check for meaningful documentation
  const docPaths = [
    'docs/strategic-directives',
    'docs/prds',
    'README.md',
    'docs/README.md'
  ];
  
  let docCount = 0;
  for (const docPath of docPaths) {
    const fullPath = path.join(PROJECT_ROOT, docPath);
    if (fs.existsSync(fullPath)) {
      docCount++;
    }
  }
  
  if (docCount >= 2) {
    indicators.documentation.status = true;
    indicators.documentation.details = `${docCount} documentation sources found`;
  }
  
  // Check for deployment readiness
  const deploymentPaths = [
    '.github/workflows',
    'Dockerfile',
    'docker-compose.yml',
    '.env.example',
    'deployment'
  ];
  
  for (const deployPath of deploymentPaths) {
    const fullPath = path.join(PROJECT_ROOT, deployPath);
    if (fs.existsSync(fullPath)) {
      indicators.deployment.status = true;
      indicators.deployment.details = `${deployPath} found`;
      break;
    }
  }
  
  // Calculate completion ratio based on status
  const totalIndicators = Object.keys(indicators).length;
  const completedIndicators = Object.values(indicators).filter(ind => ind.status).length;
  const completionRatio = completedIndicators / totalIndicators;
  
  return {
    hasImplementation: completedIndicators > 0,
    completionRatio: completionRatio,
    indicators: indicators,
    summary: `${completedIndicators}/${totalIndicators} implementation indicators`,
    details: Object.entries(indicators).map(([key, val]) => 
      `${key}: ${val.status ? '✓' : '✗'} ${val.details}`
    ).join(', ')
  };
}

function calculatePhaseProgress(documents) {
  if (documents.length === 0) return 0;
  const total = documents.reduce((sum, doc) => sum + doc.progress, 0);
  return Math.round(total / documents.length);
}

// WebSocket connection handling
wss.on('connection', (ws) => {
  console.log('New WebSocket connection');
  
  // Track this client for refresh API
  global.wsClients.add(ws);

  // Send initial state
  ws.send(JSON.stringify({
    type: 'state',
    data: dashboardState
  }));

  ws.on('message', async (message) => {
    try {
      const msg = JSON.parse(message);
      await handleWebSocketMessage(ws, msg);
    } catch (error) {
      console.error('WebSocket message error:', error);
    }
  });

  ws.on('close', () => {
    console.log('WebSocket connection closed');
    // Remove from tracked clients
    global.wsClients.delete(ws);
  });
});

// Handle WebSocket messages
async function handleWebSocketMessage(ws, msg) {
  switch (msg.type) {
    case 'updateChecklist':
      updateChecklist(msg.data);
      broadcastState();
      break;
    case 'requestHandoff':
      processHandoff(msg.data);
      broadcastState();
      break;
    case 'compactContext':
      compactContext();
      broadcastState();
      break;
    case 'refresh':
      await loadState();
      calculateProgress();
      ws.send(JSON.stringify({
        type: 'state',
        data: dashboardState
      }));
      break;
    case 'setActiveSD':
      setActiveStrategicDirective(msg.data.sdId);
      broadcastState();
      break;
  }
}

// Broadcast state to all connected clients
function broadcastState() {
  const message = JSON.stringify({
    type: 'state',
    data: dashboardState
  });

  wss.clients.forEach((client) => {
    if (client.readyState === WebSocket.OPEN) {
      client.send(message);
    }
  });
}

// Set active Strategic Directive
function setActiveStrategicDirective(sdId) {
  dashboardState.leoProtocol.currentSD = sdId;
  console.log(`Set active Strategic Directive to: ${sdId}`);
}

// Update checklist item
async function updateChecklist(data) {
  const { documentId, itemIndex, checked } = data;
  
  // Find document
  let doc = dashboardState.strategicDirectives.find(d => d.id === documentId) ||
            dashboardState.prds.find(d => d.id === documentId);
  
  if (doc && doc.checklist[itemIndex]) {
    // Update in memory
    doc.checklist[itemIndex].checked = checked;
    
    // Determine document type and checklist type
    const documentType = doc.type === 'SD' ? 'SD' : 'PRD';
    let checklistType = 'checklist';
    
    // For PRDs, determine which checklist based on phase
    if (documentType === 'PRD' && doc.checklist[itemIndex].phase) {
      if (doc.checklist[itemIndex].phase === 'PLAN') {
        checklistType = 'plan_checklist';
      } else if (doc.checklist[itemIndex].phase === 'EXEC') {
        checklistType = 'exec_checklist';
      } else if (doc.checklist[itemIndex].phase === 'VALIDATION') {
        checklistType = 'validation_checklist';
      }
    }
    
    // Save to database if connected
    if (dbLoader && dbLoader.isConnected) {
      const saved = await dbLoader.updateChecklistItem(
        documentType,
        documentId,
        checklistType,
        itemIndex,
        checked
      );
      
      if (saved) {
        console.log('✅ Checklist saved to database');
      } else {
        console.log('⚠️  Failed to save checklist to database');
      }
    }
    
    // Recalculate progress
    doc.progress = calculateLEOProtocolProgress(doc);
    
    // Update file (fallback)
    updateDocumentFile(doc);
    
    // Recalculate overall progress
    calculateProgress();
  }
}

// Update document file with new checklist state
function updateDocumentFile(doc) {
  try {
    let content = doc.content;
    
    // Update checkbox states in content
    doc.checklist.forEach((item, index) => {
      const oldPattern = new RegExp(`-\\s*\\[[x ]\\]\\s+${escapeRegex(item.text)}`, 'g');
      const newCheckbox = item.checked ? '[x]' : '[ ]';
      content = content.replace(oldPattern, `- ${newCheckbox} ${item.text}`);
    });
    
    // Determine file path
    const dir = doc.type === 'SD' ? 'strategic-directives' : 'prds';
    const filepath = path.join(PROJECT_ROOT, 'docs', dir, doc.filename);
    
    // Write updated content
    fs.writeFileSync(filepath, content);
    doc.content = content;
    
  } catch (error) {
    console.error('Error updating document file:', error);
  }
}

function escapeRegex(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

// Process handoff request
function processHandoff(data) {
  const { type, checklist, exceptionReason } = data;
  
  // Validate handoff against SD progress and uncompleted items for EXEC-to-COMPLETE
  if (type === 'EXEC-to-COMPLETE' && dashboardState.leoProtocol.currentSD) {
    const activeSD = dashboardState.strategicDirectives.find(
      sd => sd.id === dashboardState.leoProtocol.currentSD
    );
    
    if (activeSD) {
      // Check progress
      if (activeSD.progress < 100) {
        return {
          success: false,
          message: `Cannot complete handoff: Strategic Directive is only ${activeSD.progress}% complete. Finish all SD tasks first.`
        };
      }
      
      // Check validation status for uncompleted items
      if (activeSD.leoPhase?.validation?.hasUncompletedItems) {
        const count = activeSD.leoPhase.validation.uncompletedCount;
        const details = activeSD.leoPhase.validation.details
          .map(group => `${group.source}: ${group.items.length} unchecked items`)
          .join(', ');
        
        return {
          success: false,
          message: `Cannot complete handoff: ${count} checklist items are not checked. (${details})`
        };
      }
    }
  }
  
  // Validate checklist completion
  const completed = checklist.filter(item => item.checked).length;
  const required = checklist.length;
  
  if (completed >= required) {
    // Handoff approved
    dashboardState.handoffs.push({
      type,
      timestamp: new Date().toISOString(),
      status: 'approved',
      checklist,
      completionRate: '100%'
    });
    
    // Update LEO status
    updateLeoStatus(type);
    
    return { success: true, status: 'approved' };
  } else if (exceptionReason) {
    // Exception handoff with justification
    dashboardState.handoffs.push({
      type,
      timestamp: new Date().toISOString(),
      status: 'exception',
      checklist,
      exceptionReason,
      completionRate: `${Math.round((completed/required) * 100)}%`
    });
    
    // Update LEO status (proceed with caution)
    updateLeoStatus(type);
    
    return { success: true, status: 'exception', message: 'Exception handoff recorded' };
  } else {
    // Handoff blocked - need exception
    return {
      success: false,
      message: `Handoff blocked: ${completed}/${required} items complete. Exception reason required.`
    };
  }
}

// Update LEO status after handoff
function updateLeoStatus(handoffType) {
  const [from, , to] = handoffType.split('-');
  
  // COMPLETE is not a role in LEO Protocol - it's a state
  // Valid roles are: LEAD, PLAN, EXEC
  let actualRole = null;
  
  if (to === 'COMPLETE') {
    // When completing an SD, clear the active role
    // The system is now awaiting the next Strategic Directive
    actualRole = null;
    dashboardState.leoProtocol.currentSD = null;
    console.log('Strategic Directive completed - system awaiting next SD');
  } else if (['LEAD', 'PLAN', 'EXEC'].includes(to)) {
    // Valid role transition
    actualRole = to;
    
    // If we have an active SD, verify the role matches its phase
    if (dashboardState.leoProtocol.currentSD) {
      const activeSD = dashboardState.strategicDirectives.find(
        sd => sd.id === dashboardState.leoProtocol.currentSD
      );
      
      if (activeSD && activeSD.leoPhase) {
        // Use the SD's actual phase
        actualRole = activeSD.leoPhase.current || to;
      }
    }
  }
  
  dashboardState.leoProtocol.activeRole = actualRole;
  
  dashboardState.leoProtocol.lastHandoff = {
    type: handoffType,
    timestamp: new Date().toISOString()
  };
  
  // Save to file
  const statusPath = path.join(PROJECT_ROOT, '.leo-status.json');
  fs.writeFileSync(statusPath, JSON.stringify(dashboardState.leoProtocol, null, 2));
}

// Compact context
function compactContext() {
  // This would trigger the actual context compaction
  // For now, just simulate it
  dashboardState.context.usage = Math.round(dashboardState.context.usage * 0.5);
}

// API Routes

// Status endpoint
app.get('/api/status', (req, res) => {
  res.json({
    status: 'running',
    version: dashboardState.leoProtocol.version,
    uptime: process.uptime()
  });
});

// Setup refresh API routes (database refresh, server restart)
refreshAPI.setupRoutes(app);

// Get current state
app.get('/api/state', (req, res) => {
  res.json(dashboardState);
});

// Strategic Directives
app.get('/api/sd', (req, res) => {
  res.json(dashboardState.strategicDirectives);
});

app.get('/api/sd/:id', async (req, res) => {
  const sd = dashboardState.strategicDirectives.find(d => d.id === req.params.id);
  if (!sd) {
    return res.status(404).json({ error: 'SD not found' });
  }
  
  // SD already includes PRDs and EES from database loader
  // But let's ensure we have the full data for backward compatibility
  const enhancedSD = { ...sd };
  
  // If PRDs are not already in the SD (old format), find them
  if (!sd.prds || sd.prds.length === 0) {
    const associatedPRDs = dashboardState.prds.filter(prd => 
      prd.directiveId === sd.id || 
      prd.id === `PRD-${sd.id}` ||
      prd.filename?.includes(sd.id)
    );
    
    if (associatedPRDs.length > 0) {
      enhancedSD.prds = associatedPRDs.map(prd => ({
        id: prd.id,
        title: prd.title,
        status: prd.status,
        phase: prd.phase,
        progress: prd.progress,
        functionalRequirements: prd.functionalRequirements,
        nonFunctionalRequirements: prd.nonFunctionalRequirements,
        technicalRequirements: prd.technicalRequirements,
        testScenarios: prd.testScenarios,
        acceptanceCriteria: prd.acceptanceCriteria,
        checklist: prd.checklist
      }));
      
      // Keep backward compatibility with single PRD
      enhancedSD.prd = enhancedSD.prds[0];
    }
  } else {
    // Use PRDs from database loader (already included)
    // Also set single PRD for backward compatibility
    enhancedSD.prd = enhancedSD.prds[0];
  }
  
  // If EES are not already in the SD (old format), find them
  if (!sd.executionSequences || sd.executionSequences.length === 0) {
    if (dashboardState.executionSequences) {
      const associatedEES = dashboardState.executionSequences.filter(ees => 
        ees.directive_id === sd.id
      );
      
      if (associatedEES.length > 0) {
        enhancedSD.executionSequences = associatedEES.map(ees => ({
          id: ees.id,
          title: ees.title,
          description: ees.description,
          sequenceNumber: ees.sequence_number,
          status: ees.status,
          phase: ees.phase,
          progress: ees.progress,
          deliverables: ees.deliverables,
          assignedTo: ees.assigned_to,
          plannedStart: ees.planned_start,
        plannedEnd: ees.planned_end,
        actualStart: ees.actual_start,
        actualEnd: ees.actual_end
      }));
      }
    }
  }
  
  // Calculate overall progress
  enhancedSD.overallProgress = sd.progress || 0;
  
  // Add phase breakdown (use first PRD for backward compatibility)
  const primaryPRD = enhancedSD.prd;
  enhancedSD.phaseBreakdown = {
    leadPlanning: {
      complete: sd.checklist?.filter(i => i.checked).length === sd.checklist?.length,
      progress: sd.checklist ? (sd.checklist.filter(i => i.checked).length / sd.checklist.length * 100) : 0
    },
    planDesign: primaryPRD ? {
      complete: primaryPRD.checklist?.filter(i => i.phase === 'PLAN' && i.checked).length === 
                primaryPRD.checklist?.filter(i => i.phase === 'PLAN').length,
      progress: primaryPRD.progress || 0
    } : { complete: false, progress: 0 },
    execImplementation: primaryPRD ? {
      complete: primaryPRD.checklist?.filter(i => i.phase === 'EXEC' && i.checked).length === 
                primaryPRD.checklist?.filter(i => i.phase === 'EXEC').length,
      progress: primaryPRD.checklist?.filter(i => i.phase === 'EXEC').length > 0 ?
                (primaryPRD.checklist.filter(i => i.phase === 'EXEC' && i.checked).length / 
                 primaryPRD.checklist.filter(i => i.phase === 'EXEC').length * 100) : 0
    } : { complete: false, progress: 0 },
    validation: primaryPRD ? {
      complete: primaryPRD.checklist?.filter(i => i.phase === 'VALIDATION' && i.checked).length === 
                primaryPRD.checklist?.filter(i => i.phase === 'VALIDATION').length,
      progress: primaryPRD.checklist?.filter(i => i.phase === 'VALIDATION').length > 0 ?
                (primaryPRD.checklist.filter(i => i.phase === 'VALIDATION' && i.checked).length / 
                 primaryPRD.checklist.filter(i => i.phase === 'VALIDATION').length * 100) : 0
    } : { complete: false, progress: 0 }
  };
  
  res.json(enhancedSD);
});

// PRDs
app.get('/api/prd', (req, res) => {
  res.json(dashboardState.prds);
});

app.get('/api/prd/:id', (req, res) => {
  const prd = dashboardState.prds.find(d => d.id === req.params.id);
  if (prd) {
    res.json(prd);
  } else {
    res.status(404).json({ error: 'PRD not found' });
  }
});

// PRD Enhancement API with Lovable.dev best practices
app.post('/api/prd/enhance', (req, res) => {
  try {
    const { prdData, projectType = 'web-app' } = req.body;
    
    if (!prdData) {
      return res.status(400).json({ error: 'PRD data is required' });
    }

    // Generate enhanced PRD content with lovable.dev best practices
    const enhancedContent = dbLoader.generateEnhancedPRDContent(prdData, projectType);
    
    res.json({
      success: true,
      enhancedContent,
      projectType,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('Error enhancing PRD:', error);
    res.status(500).json({ error: 'Failed to enhance PRD' });
  }
});

// PRD Template API - Get project-specific templates
app.get('/api/prd/template/:projectType', (req, res) => {
  try {
    const { projectType } = req.params;
    const lovableDevSections = dbLoader.generateLovableDevSections(projectType);
    const aiWorkflowChecklist = dbLoader.generateAIWorkflowChecklist();
    const accessibilityChecklist = dbLoader.generateAccessibilityChecklist();
    
    res.json({
      projectType,
      sections: lovableDevSections,
      checklists: {
        aiWorkflow: aiWorkflowChecklist,
        accessibility: accessibilityChecklist
      },
      supportedProjectTypes: ['web-app', 'dashboard', 'e-commerce'],
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('Error generating PRD template:', error);
    res.status(500).json({ error: 'Failed to generate PRD template' });
  }
});

// PRD Best Practices API - Get lovable.dev specific guidance
app.get('/api/prd/best-practices', (req, res) => {
  try {
    const bestPractices = {
      architecture: {
        framework: 'React 18+ with TypeScript for type safety and modern features',
        buildSystem: 'Vite for fast development and optimized production builds',
        styling: 'Tailwind CSS with custom design system tokens',
        backend: 'Supabase for PostgreSQL database, authentication, and real-time features',
        deployment: 'Netlify or Vercel with automatic CI/CD from Git repositories'
      },
      development: {
        aiIntegration: 'Leverage AI co-pilot for 60-70% of development time',
        iterativeCycles: '15-30 minute development intervals for focused progress',
        knowledgeFiles: 'Maintain comprehensive /knowledge directory for AI context',
        componentFirst: 'Build reusable atomic design components with Storybook',
        databaseFirst: 'Design Supabase schema before frontend implementation'
      },
      performance: {
        loadTime: 'Target <3 seconds initial load, <1 second subsequent navigation',
        lighthouse: '90+ scores across all Lighthouse categories on mobile',
        bundleSize: 'Implement code splitting and lazy loading for optimization',
        coreWebVitals: 'Meet recommended thresholds for LCP, FID, and CLS',
        caching: 'Utilize Supabase query optimization and browser caching'
      },
      accessibility: {
        wcagCompliance: 'WCAG 2.1 AA standards with automated and manual testing',
        semanticHTML: 'Proper heading hierarchy and landmark structure',
        keyboardNav: 'Full keyboard navigation support for all interactive elements',
        colorContrast: 'Minimum 4.5:1 ratio for normal text, 3:1 for large text',
        screenReader: 'Test with NVDA/JAWS and provide meaningful ARIA labels'
      },
      security: {
        rowLevelSecurity: 'Implement RLS policies in Supabase for data protection',
        inputValidation: 'Sanitize and validate all user inputs on client and server',
        authentication: 'Role-based access control with Supabase Auth',
        httpsEnforcement: 'Secure headers and HTTPS-only configuration',
        environmentVars: 'Proper management of sensitive configuration data'
      }
    };

    res.json({
      bestPractices,
      platform: 'lovable.dev',
      lastUpdated: new Date().toISOString(),
      documentation: 'https://docs.lovable.dev'
    });
  } catch (error) {
    console.error('Error fetching best practices:', error);
    res.status(500).json({ error: 'Failed to fetch best practices' });
  }
});

// Handoffs
app.get('/api/handoff', (req, res) => {
  res.json(dashboardState.handoffs);
});

app.post('/api/handoff', (req, res) => {
  const result = processHandoff(req.body);
  broadcastState();
  res.json(result || { success: true });
});

// Context
app.get('/api/context', (req, res) => {
  res.json(dashboardState.context);
});

app.post('/api/context/compact', (req, res) => {
  compactContext();
  broadcastState();
  res.json({ success: true });
});

// Progress
app.get('/api/progress', (req, res) => {
  res.json(dashboardState.progress);
});

// Progress Audit - Detailed validation report
app.get('/api/progress/audit/:sdId?', (req, res) => {
  const sdId = req.params.sdId;
  
  let targetSD = null;
  if (sdId) {
    targetSD = dashboardState.strategicDirectives.find(sd => sd.id === sdId);
  } else if (dashboardState.leoProtocol.currentSD) {
    targetSD = dashboardState.strategicDirectives.find(
      sd => sd.id === dashboardState.leoProtocol.currentSD
    );
  }
  
  if (!targetSD) {
    return res.status(404).json({ error: 'No Strategic Directive found for audit' });
  }
  
  // Ensure SD has fresh calculation
  targetSD.progress = calculateLEOProtocolProgress(targetSD);
  
  // Generate comprehensive audit report
  const audit = generateProgressAudit(targetSD);
  res.json(audit);
});

// Checklists
app.post('/api/checklist/update', (req, res) => {
  updateChecklist(req.body);
  broadcastState();
  res.json({ success: true });
});

// Metrics endpoint with real data
app.get('/api/metrics', (req, res) => {
  import { execSync } from 'child_process';
  let metrics = {
    tests: {
      total: 0,
      passed: 0,
      failed: 0,
      skipped: 0
    },
    coverage: {
      lines: 0,
      branches: 0,
      functions: 0,
      statements: 0
    },
    git: {
      branch: 'unknown',
      uncommittedChanges: 0,
      lastCommit: '',
      ahead: 0,
      behind: 0
    }
  };

  try {
    // Get git information
    try {
      metrics.git.branch = execSync('git rev-parse --abbrev-ref HEAD', { encoding: 'utf8' }).trim();
      const status = execSync('git status --porcelain', { encoding: 'utf8' });
      metrics.git.uncommittedChanges = status.split('\n').filter(line => line.trim()).length;
      metrics.git.lastCommit = execSync('git log -1 --pretty=format:"%h - %s"', { encoding: 'utf8' }).trim();
      
      // Check if we're ahead/behind remote
      try {
        const remote = execSync('git rev-list --count @{u}..HEAD', { encoding: 'utf8' }).trim();
        metrics.git.ahead = parseInt(remote) || 0;
        const behind = execSync('git rev-list --count HEAD..@{u}', { encoding: 'utf8' }).trim();
        metrics.git.behind = parseInt(behind) || 0;
      } catch (e) {
        // Remote might not be set up
      }
    } catch (error) {
      console.log('Git info not available:', error.message);
    }

    // Check for test results (look for common test result files)
    const testResultPaths = [
      path.join(PROJECT_ROOT, 'coverage', 'coverage-summary.json'),
      path.join(PROJECT_ROOT, 'test-results.json'),
      path.join(PROJECT_ROOT, '.nyc_output', 'processinfo', 'index.json')
    ];

    for (const resultPath of testResultPaths) {
      if (fs.existsSync(resultPath)) {
        try {
          const data = JSON.parse(fs.readFileSync(resultPath, 'utf8'));
          if (data.total) {
            metrics.coverage = {
              lines: data.total.lines?.pct || 0,
              branches: data.total.branches?.pct || 0,
              functions: data.total.functions?.pct || 0,
              statements: data.total.statements?.pct || 0
            };
          }
        } catch (e) {
          // Invalid JSON or unexpected format
        }
      }
    }

    // Check package.json for test script existence
    const packageJsonPath = path.join(PROJECT_ROOT, 'package.json');
    if (fs.existsSync(packageJsonPath)) {
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
      if (packageJson.scripts && packageJson.scripts.test) {
        metrics.tests.available = true;
        metrics.tests.command = packageJson.scripts.test;
      }
    }

    // Count test files as a proxy for test count
    try {
      const testFiles = execSync('find . -name "*.test.js" -o -name "*.spec.js" -o -name "*.test.ts" -o -name "*.spec.ts" 2>/dev/null | wc -l', { 
        encoding: 'utf8',
        cwd: PROJECT_ROOT 
      }).trim();
      metrics.tests.files = parseInt(testFiles) || 0;
    } catch (e) {
      metrics.tests.files = 0;
    }

  } catch (error) {
    console.error('Error gathering metrics:', error);
  }

  res.json(metrics);
});

// Enhanced application context with idea-specific analysis
function getApplicationContext(idea = '') {
  import { execSync } from 'child_process';
  const context = {
    projectRoot: PROJECT_ROOT,
    projectName: path.basename(PROJECT_ROOT),
    technologies: [],
    structure: [],
    existingFiles: [],
    relevantFiles: [],
    patterns: {},
    conventions: {},
    relatedFeatures: [],
    potentialConflicts: [],
    suggestedIntegrations: []
  };
  
  // Analyze idea keywords for context relevance
  const ideaLower = idea.toLowerCase();
  const ideaKeywords = {
    dashboard: ['dashboard', 'ui', 'interface', 'display', 'view'],
    api: ['api', 'endpoint', 'rest', 'graphql', 'service'],
    database: ['database', 'db', 'storage', 'persist', 'data'],
    auth: ['auth', 'login', 'security', 'permission', 'user'],
    realtime: ['realtime', 'websocket', 'live', 'stream', 'push'],
    ai: ['ai', 'ml', 'machine learning', 'neural', 'model'],
    testing: ['test', 'quality', 'coverage', 'unit', 'integration'],
    monitoring: ['monitor', 'track', 'metric', 'log', 'observe']
  };
  
  // Identify which areas the idea touches
  const relevantAreas = [];
  for (const [area, keywords] of Object.entries(ideaKeywords)) {
    if (keywords.some(keyword => ideaLower.includes(keyword))) {
      relevantAreas.push(area);
    }
  }
  
  // Check for common technology indicators
  const packageJsonPath = path.join(PROJECT_ROOT, 'package.json');
  if (fs.existsSync(packageJsonPath)) {
    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
    context.dependencies = Object.keys(packageJson.dependencies || {});
    context.devDependencies = Object.keys(packageJson.devDependencies || {});
    context.scripts = Object.keys(packageJson.scripts || {});
    
    // Deep technology analysis based on idea
    const techMap = {
      'react': { name: 'React', relevant: ['dashboard', 'ui'] },
      'vue': { name: 'Vue.js', relevant: ['dashboard', 'ui'] },
      'express': { name: 'Express.js', relevant: ['api', 'server'] },
      'fastify': { name: 'Fastify', relevant: ['api', 'server'] },
      'openai': { name: 'OpenAI', relevant: ['ai'] },
      'ws': { name: 'WebSocket', relevant: ['realtime'] },
      'socket.io': { name: 'Socket.io', relevant: ['realtime'] },
      'mongodb': { name: 'MongoDB', relevant: ['database'] },
      'postgresql': { name: 'PostgreSQL', relevant: ['database'] },
      'jest': { name: 'Jest', relevant: ['testing'] },
      'mocha': { name: 'Mocha', relevant: ['testing'] },
      'passport': { name: 'Passport.js', relevant: ['auth'] },
      'jsonwebtoken': { name: 'JWT', relevant: ['auth'] },
      'winston': { name: 'Winston', relevant: ['monitoring'] },
      'pino': { name: 'Pino', relevant: ['monitoring'] }
    };
    
    // Find relevant technologies for this idea
    for (const [pkg, info] of Object.entries(techMap)) {
      if (context.dependencies.includes(pkg) || context.devDependencies.includes(pkg)) {
        context.technologies.push(info.name);
        if (info.relevant.some(area => relevantAreas.includes(area))) {
          context.suggestedIntegrations.push(`Use existing ${info.name} for ${info.relevant.join('/')}`);
        }
      }
    }
  }
  
  // Analyze project structure for relevant directories
  const structureMap = {
    'components': ['dashboard', 'ui'],
    'api': ['api', 'endpoint'],
    'routes': ['api', 'routing'],
    'models': ['database', 'data'],
    'controllers': ['api', 'logic'],
    'services': ['api', 'business'],
    'middleware': ['api', 'auth'],
    'tests': ['testing'],
    'docs': ['documentation'],
    '__tests__': ['testing'],
    'auth': ['auth'],
    'utils': ['utilities'],
    'hooks': ['react', 'ui'],
    'store': ['state', 'data'],
    'lib': ['library', 'shared']
  };
  
  for (const [dir, areas] of Object.entries(structureMap)) {
    const dirPath = path.join(PROJECT_ROOT, dir);
    if (fs.existsSync(dirPath)) {
      context.structure.push(dir);
      if (areas.some(area => relevantAreas.includes(area))) {
        context.relevantFiles.push(`${dir}/ - relevant for ${areas.join(', ')}`);
      }
    }
  }
  
  // Find files specifically related to the idea
  try {
    // Search for files with relevant keywords
    relevantAreas.forEach(area => {
      const searchTerms = ideaKeywords[area] || [];
      searchTerms.forEach(term => {
        try {
          const files = execSync(
            `find . -type f \\( -name "*${term}*" -o -path "*/${term}/*" \\) -name "*.js" -o -name "*.jsx" -o -name "*.ts" -o -name "*.tsx" 2>/dev/null | head -10`,
            { cwd: PROJECT_ROOT, encoding: 'utf8' }
          ).split('\n').filter(f => f);
          
          files.forEach(file => {
            if (!context.relevantFiles.includes(file)) {
              context.relevantFiles.push(file);
            }
          });
        } catch (e) {
          // Ignore errors for specific searches
        }
      });
    });
  } catch (e) {
    // Ignore general errors
  }
  
  // Detect coding patterns and conventions
  try {
    // Check for test files to understand testing patterns
    const testFiles = execSync(
      'find . -type f \\( -name "*.test.js" -o -name "*.spec.js" \\) 2>/dev/null | head -5',
      { cwd: PROJECT_ROOT, encoding: 'utf8' }
    ).split('\n').filter(f => f);
    
    if (testFiles.length > 0) {
      context.patterns.testing = 'Test files found - follows testing best practices';
    }
    
    // Check for TypeScript
    if (fs.existsSync(path.join(PROJECT_ROOT, 'tsconfig.json'))) {
      context.patterns.typescript = 'TypeScript configured - type safety enabled';
    }
    
    // Check for ESLint/Prettier
    if (fs.existsSync(path.join(PROJECT_ROOT, '.eslintrc.js')) || 
        fs.existsSync(path.join(PROJECT_ROOT, '.eslintrc.json'))) {
      context.patterns.linting = 'ESLint configured - code quality standards enforced';
    }
    
    // Check for CI/CD
    if (fs.existsSync(path.join(PROJECT_ROOT, '.github/workflows')) || 
        fs.existsSync(path.join(PROJECT_ROOT, '.gitlab-ci.yml'))) {
      context.patterns.cicd = 'CI/CD pipelines configured';
    }
  } catch (e) {
    // Ignore errors
  }
  
  // Analyze recent git activity to understand active areas
  try {
    const recentFiles = execSync(
      'git log --name-only --pretty=format: -20 2>/dev/null | sort | uniq -c | sort -rn | head -10',
      { cwd: PROJECT_ROOT, encoding: 'utf8' }
    ).split('\n').filter(f => f.trim());
    
    context.recentActivity = recentFiles.map(f => {
      const match = f.match(/\s+(\d+)\s+(.+)/);
      if (match) {
        return { count: parseInt(match[1]), file: match[2] };
      }
      return null;
    }).filter(Boolean);
    
    // Check if any recent activity relates to the idea
    context.recentActivity.forEach(activity => {
      relevantAreas.forEach(area => {
        if (activity.file.toLowerCase().includes(area)) {
          context.relatedFeatures.push(`Recent work on ${activity.file} (${activity.count} changes)`);
        }
      });
    });
  } catch (e) {
    // Ignore git errors
  }
  
  // Check for potential conflicts or considerations
  if (relevantAreas.includes('api') && context.technologies.includes('Express.js')) {
    context.potentialConflicts.push('Consider existing Express.js routes and middleware');
  }
  
  if (relevantAreas.includes('dashboard') && context.structure.includes('client')) {
    context.potentialConflicts.push('Existing client structure may need integration');
  }
  
  if (relevantAreas.includes('realtime') && !context.technologies.includes('WebSocket')) {
    context.potentialConflicts.push('No WebSocket library detected - may need to add real-time capability');
  }
  
  // Add LEO Protocol specific context
  if (fs.existsSync(path.join(PROJECT_ROOT, '.leo-status.json'))) {
    context.leoProtocol = true;
    context.relatedFeatures.push('LEO Protocol integration available');
  }
  
  // Add specific recommendations based on the idea
  if (ideaLower.includes('dashboard') && context.structure.includes('lib/dashboard')) {
    context.suggestedIntegrations.push('Extend existing dashboard in lib/dashboard/');
  }
  
  if (ideaLower.includes('api') && context.scripts && context.scripts.includes('test')) {
    context.suggestedIntegrations.push('Include API tests using existing test framework');
  }
  
  return context;
}

// Strategic Directive Assistant AI endpoint
app.post('/api/sd-assistant/analyze', async (req, res) => {
  const { idea, existingDirectives = [] } = req.body;
  const appContext = getApplicationContext(idea);  // Pass idea for context analysis
  
  if (!idea) {
    return res.status(400).json({ error: 'No idea provided' });
  }

  try {
    if (openai) {
      // Use OpenAI to generate tailored questions
      const systemPrompt = `You are an expert at helping refine Strategic Directives for the LEO Protocol system. 
      Analyze the user's rough idea and generate 3-5 highly specific clarifying questions that would help transform their idea into a well-structured Strategic Directive.
      
      Application Context for "${idea}":
      - Project: ${appContext.projectName}
      - Relevant Technologies: ${appContext.technologies.join(', ')}
      - Project structure: ${appContext.structure.join(', ')}
      - Relevant existing files: ${appContext.relevantFiles.slice(0, 5).join(', ')}
      - Related recent work: ${appContext.relatedFeatures.join(', ')}
      - Suggested integrations: ${appContext.suggestedIntegrations.join(', ')}
      - Potential considerations: ${appContext.potentialConflicts.join(', ')}
      - Patterns in use: ${Object.entries(appContext.patterns).map(([k,v]) => `${k}: ${v}`).join(', ')}
      ${appContext.leoProtocol ? '- LEO Protocol is already integrated in this project' : ''}
      
      The questions should:
      1. Be HIGHLY SPECIFIC to their idea and how it fits with the existing codebase
      2. Reference specific files, directories, or technologies they should consider
      3. Ask about integration with existing features found in the codebase
      4. Consider the patterns and conventions already in use
      5. Address potential conflicts or overlaps with existing functionality
      6. Suggest leveraging existing code/patterns where applicable
      
      Each question should have 3-5 multiple choice options that are specific to their project.
      Some questions should allow multiple selections when appropriate (e.g., technologies, user groups, features).
      Include an "Other" option where users might have custom answers.
      
      Existing Strategic Directives in the system:
      ${existingDirectives.slice(0, 3).map(sd => sd.title).join(', ')}
      
      Return the response as JSON with this structure:
      {
        "analysis": {
          "strengths": ["list of what's good about the idea"],
          "gaps": ["list of what's missing or unclear"],
          "suggestions": ["list of improvements"]
        },
        "questions": [
          {
            "id": "unique_id",
            "question": "The specific question to ask",
            "why": "Brief explanation of why this matters",
            "multiSelect": false,
            "allowOther": false,
            "options": [
              {
                "value": "option_value",
                "label": "Option Label",
                "description": "What this choice means",
                "impact": "How this affects the directive"
              }
            ]
          }
        ],
        "refinementHints": {
          "title": "Suggested title for the directive",
          "focus": "Primary area of focus",
          "estimatedScope": "rough estimate of scope",
          "technologies": "Relevant technologies from the stack",
          "integration": "How this fits with existing architecture"
        }
      }`;

      const completion = await openai.chat.completions.create({
        model: process.env.OPENAI_MODEL || 'gpt-4-turbo-preview',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: `Analyze this Strategic Directive idea and provide specific questions: "${idea}"` }
        ],
        response_format: { type: "json_object" },
        temperature: 0.7,
        max_tokens: 2000
      });

      const analysis = JSON.parse(completion.choices[0].message.content);
      
      // Enhance questions with multi-select capabilities based on question content
      if (analysis.questions) {
        analysis.questions = analysis.questions.map(question => {
          // Add multi-select support to certain types of questions
          if (question.id.includes('payment') || question.id.includes('tech') || 
              question.id.includes('stack') || question.id.includes('user') ||
              question.question.toLowerCase().includes('which') ||
              question.question.toLowerCase().includes('what types') ||
              question.question.toLowerCase().includes('multiple')) {
            question.multiSelect = true;
            question.allowOther = true;
          }
          
          // Set defaults if not provided
          if (question.multiSelect === undefined) question.multiSelect = false;
          if (question.allowOther === undefined) question.allowOther = false;
          
          return question;
        });
      }
      
      res.json(analysis);
      
    } else {
      // Fallback to rule-based analysis when OpenAI is not available
      const analysis = performFallbackAnalysis(idea, existingDirectives);
      res.json(analysis);
    }
  } catch (error) {
    console.error('Error analyzing SD idea:', error);
    
    // Fallback to basic analysis on error
    const fallbackAnalysis = performFallbackAnalysis(idea, existingDirectives);
    res.json(fallbackAnalysis);
  }
});

// Fallback analysis function when OpenAI is not available
function performFallbackAnalysis(idea, existingDirectives) {
  const ideaLower = idea.toLowerCase();
  const analysis = {
    analysis: {
      strengths: [],
      gaps: [],
      suggestions: []
    },
    questions: [],
    refinementHints: {
      title: idea.split(' ').slice(0, 8).join(' '),
      focus: 'General',
      estimatedScope: 'Medium'
    }
  };

  // Analyze strengths
  if (idea.length > 100) {
    analysis.analysis.strengths.push('Detailed description provided');
  }
  if (ideaLower.includes('implement') || ideaLower.includes('create')) {
    analysis.analysis.strengths.push('Clear action-oriented language');
  }

  // Identify gaps and generate questions based on what's missing
  const questions = [];
  
  // Check for technical details
  if (!ideaLower.includes('api') && !ideaLower.includes('database') && !ideaLower.includes('frontend')) {
    analysis.analysis.gaps.push('Technical implementation details not specified');
    questions.push({
      id: 'tech_stack',
      question: `What technical components will be involved in "${idea.substring(0, 50)}..."?`,
      why: 'Understanding the technical requirements helps scope the work',
      multiSelect: true,  // Allow multiple selections
      allowOther: true,   // Allow "Other" option
      options: [
        {
          value: 'frontend',
          label: 'Frontend/UI Components',
          description: 'User interface and client-side logic',
          impact: 'Will require React/UI development'
        },
        {
          value: 'backend',
          label: 'Backend/API Services',
          description: 'Server-side logic and data processing',
          impact: 'Will require API design and server development'
        },
        {
          value: 'database',
          label: 'Database/Data Storage',
          description: 'Data persistence and management',
          impact: 'Will require database schema design'
        },
        {
          value: 'integration',
          label: 'Third-party Integrations',
          description: 'Connecting with external services',
          impact: 'Will require API integration and testing'
        },
        {
          value: 'ai_ml',
          label: 'AI/ML Components',
          description: 'Machine learning or AI features',
          impact: 'Will require AI model integration'
        }
      ]
    });
  }

  // Check for user impact
  if (!ideaLower.includes('user') && !ideaLower.includes('team') && !ideaLower.includes('developer')) {
    analysis.analysis.gaps.push('User impact not clearly defined');
    questions.push({
      id: 'users',
      question: 'Who will be the primary beneficiaries of this directive?',
      why: 'Knowing the users helps tailor the solution appropriately',
      multiSelect: true,  // Allow selecting multiple user groups
      allowOther: true,   // Allow specifying other user groups
      options: [
        {
          value: 'developers',
          label: 'Development Team',
          description: 'Internal developers working on the project',
          impact: 'Focus on developer experience and tooling'
        },
        {
          value: 'end_users',
          label: 'End Users',
          description: 'Final users of the application',
          impact: 'Focus on user experience and usability'
        },
        {
          value: 'stakeholders',
          label: 'Business Stakeholders',
          description: 'Management and decision makers',
          impact: 'Focus on reporting and visibility'
        },
        {
          value: 'ops_team',
          label: 'Operations Team',
          description: 'DevOps and system administrators',
          impact: 'Focus on deployment and monitoring'
        },
        {
          value: 'qa_team',
          label: 'QA/Testing Team',
          description: 'Quality assurance and testers',
          impact: 'Focus on testability and quality metrics'
        }
      ]
    });
  }

  // Check for timeline
  if (!ideaLower.includes('urgent') && !ideaLower.includes('asap') && !ideaLower.includes('deadline')) {
    questions.push({
      id: 'timeline',
      question: 'What is the expected timeline for implementation?',
      why: 'Timeline affects resource allocation and approach',
      options: [
        {
          value: 'immediate',
          label: 'Immediate (1-2 days)',
          description: 'Urgent requirement, minimal viable solution',
          impact: 'Focus on core functionality only'
        },
        {
          value: 'sprint',
          label: 'Current Sprint (1 week)',
          description: 'Part of current development cycle',
          impact: 'Standard development with testing'
        },
        {
          value: 'release',
          label: 'Next Release (2-4 weeks)',
          description: 'Planned feature for upcoming release',
          impact: 'Full implementation with documentation'
        },
        {
          value: 'backlog',
          label: 'Future/Backlog',
          description: 'Nice to have, when resources allow',
          impact: 'Can be thoroughly planned and designed'
        }
      ]
    });
  }

  // Add suggestions
  if (idea.length < 50) {
    analysis.analysis.suggestions.push('Expand on the problem you\'re trying to solve');
  }
  if (!ideaLower.includes('because') && !ideaLower.includes('in order to')) {
    analysis.analysis.suggestions.push('Add the business justification or "why" behind this directive');
  }

  analysis.questions = questions;
  return analysis;
}

// Generate refined Strategic Directive with AI
app.post('/api/sd-assistant/refine', async (req, res) => {
  const { idea, answers, questions, existingDirectives = [] } = req.body;
  const appContext = getApplicationContext(idea);  // Pass idea for context analysis
  
  if (!idea) {
    return res.status(400).json({ error: 'No idea provided' });
  }

  try {
    if (openai) {
      const systemPrompt = `You are an expert at writing Strategic Directives for the LEO Protocol system.
      Generate a comprehensive, well-structured Strategic Directive based on the user's idea and their answers to clarifying questions.
      
      Application Context for "${idea}":
      - Project: ${appContext.projectName}
      - Relevant Technologies: ${appContext.technologies.join(', ')}
      - Project structure: ${appContext.structure.join(', ')}
      - Relevant existing files/directories: ${appContext.relevantFiles.slice(0, 10).join(', ')}
      - Related features already in codebase: ${appContext.relatedFeatures.join(', ')}
      - Suggested integrations: ${appContext.suggestedIntegrations.join(', ')}
      - Key dependencies to leverage: ${appContext.dependencies?.filter(d => 
          appContext.suggestedIntegrations.some(s => s.toLowerCase().includes(d))
        ).join(', ')}
      - Development patterns in use: ${Object.entries(appContext.patterns).map(([k,v]) => v).join(', ')}
      ${appContext.leoProtocol ? '- LEO Protocol integration is available' : ''}
      ${appContext.recentActivity ? `- Recent development activity in: ${appContext.recentActivity.slice(0, 3).map(a => a.file).join(', ')}` : ''}
      
      The directive should:
      1. Reference SPECIFIC files and directories from their codebase
      2. Build upon existing code and patterns found in the project
      3. Include actionable objectives that leverage existing infrastructure
      4. Define technical requirements that align with their current architecture
      5. Suggest specific integration points with existing code
      6. Reference actual dependencies and tools they already have
      7. Follow the coding patterns and conventions detected in their project
      
      Format the output as a complete Strategic Directive in Markdown with:
      - Title and metadata
      - Executive Summary
      - Business Objectives (as checkboxes)
      - Technical Requirements
      - Success Criteria
      - Constraints
      - Implementation Notes
      - Resources Required
      
      Make it specific, actionable, and aligned with their existing technology choices.`;

      const userContent = `
      Original Idea: "${idea}"
      
      Questions and Answers:
      ${JSON.stringify(answers, null, 2)}
      
      Generate a refined Strategic Directive that incorporates all this information and the application context.
      `;

      const completion = await openai.chat.completions.create({
        model: process.env.OPENAI_MODEL || 'gpt-5',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userContent }
        ],
        temperature: 0.7,
        max_tokens: 3000
      });

      const refinedPrompt = completion.choices[0].message.content;
      res.json({ refinedPrompt });
      
    } else {
      // Fallback to basic refinement
      res.json({ refinedPrompt: generateBasicRefinedPrompt(idea, answers) });
    }
  } catch (error) {
    console.error('Error refining SD:', error);
    res.json({ refinedPrompt: generateBasicRefinedPrompt(idea, answers) });
  }
});

function generateBasicRefinedPrompt(idea, answers) {
  return `# Strategic Directive: ${idea.substring(0, 50)}

**Date**: ${new Date().toISOString().split('T')[0]}
**Status**: Draft

## Executive Summary
${idea}

## Business Objectives
- [ ] Implement core functionality
- [ ] Ensure quality and testing
- [ ] Document implementation

## Technical Requirements
- Must integrate with existing LEO Protocol
- Follow established patterns
- Maintain backward compatibility

## Success Criteria
- All objectives completed
- Tests passing
- Documentation complete

## Implementation Notes
To be refined based on specific requirements.
`;
}

// Error handling middleware
app.use((err, req, res, next) => {
  console.error('Error:', err.stack);
  
  // Log to file for debugging
  const errorLog = `[${new Date().toISOString()}] ${err.stack}\n`;
  fs.appendFileSync(path.join(__dirname, 'error.log'), errorLog);
  
  res.status(err.status || 500).json({
    error: {
      message: err.message || 'Internal Server Error',
      status: err.status || 500,
      ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
    }
  });
});

// SDIP (Strategic Directive Initiation Protocol) Routes
// Import SDIP handler (initialize only if credentials available)
let sdipHandler = null;
if (process.env.NEXT_PUBLIC_SUPABASE_URL || process.env.SUPABASE_URL) {
  import SDIPHandler from './sdip/api/sdip-handler';
  sdipHandler = new SDIPHandler(
    process.env.NEXT_PUBLIC_SUPABASE_URL || process.env.SUPABASE_URL,
    process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
    process.env.OPENAI_API_KEY
  );
}

// SDIP API endpoints (only if handler initialized)
if (sdipHandler) {
  // Create new submission
  app.post('/api/sdip/submissions', (req, res) => sdipHandler.createSubmission(req, res));
  
  // Get submission by ID
  app.get('/api/sdip/submissions/:id', (req, res) => sdipHandler.getSubmission(req, res));
  
  // Complete a specific step
  app.post('/api/sdip/submissions/:id/step/:step', (req, res) => sdipHandler.completeStep(req, res));
  
  // Create SD from submission
  app.post('/api/sdip/strategic-directive', (req, res) => sdipHandler.createStrategicDirective(req, res));
  
  // List all submissions
  app.get('/api/sdip/submissions', (req, res) => sdipHandler.listSubmissions(req, res));
  
  // Create submission group
  app.post('/api/sdip/groups', (req, res) => sdipHandler.createGroup(req, res));
  
  console.log('✅ SDIP routes initialized at /api/sdip/*');
} else {
  console.log('⚠️ SDIP routes not initialized - missing Supabase credentials');
}

// Serve React app for all other routes
app.get('*', (req, res) => {
  res.sendFile(path.join(__dirname, 'client', 'dist', 'index.html'));
});

// File system watching
function setupFileWatching() {
  const watcher = chokidar.watch([
    path.join(PROJECT_ROOT, 'docs', 'strategic-directives'),
    path.join(PROJECT_ROOT, 'docs', 'prds'),
    path.join(PROJECT_ROOT, '.leo-*.json')
  ], {
    persistent: true,
    ignoreInitial: true
  });

  watcher.on('change', async (filepath) => {
    console.log(`File changed: ${filepath}`);
    await loadState();
    calculateProgress();
    broadcastState();
  });

  watcher.on('add', async (filepath) => {
    console.log(`File added: ${filepath}`);
    await loadState();
    calculateProgress();
    broadcastState();
  });
}

// Start server
async function startServer() {
  await loadState();
  calculateProgress();
  setupFileWatching();
  
  // Initialize real-time subscriptions if database is connected
  if (dbLoader.isConnected) {
    const realtimeInitialized = await realtimeManager.initialize();
    
    if (realtimeInitialized) {
      console.log('🔄 Setting up real-time database subscriptions...');
      
      // Subscribe to all database changes
      realtimeManager.subscribeToAll(async (change) => {
        console.log(`📡 Real-time change detected: ${change.type} - ${change.event}`);
        
        // Reload the affected data
        if (change.type === 'sd_change') {
          dashboardState.strategicDirectives = await dbLoader.loadStrategicDirectives();
        } else if (change.type === 'prd_change') {
          dashboardState.prds = await dbLoader.loadPRDs();
          // Also reload SDs since PRDs affect SD progress
          dashboardState.strategicDirectives = await dbLoader.loadStrategicDirectives();
        } else if (change.type === 'ees_change') {
          dashboardState.executionSequences = await dbLoader.loadExecutionSequences();
          // Also reload SDs to update EES counts
          dashboardState.strategicDirectives = await dbLoader.loadStrategicDirectives();
        }
        
        // Recalculate progress and broadcast to all clients
        calculateProgress();
        broadcastState();
      });
      
      console.log('✅ Real-time sync enabled - dashboard will auto-refresh on database changes');
    }
  }
  
  server.listen(PORT, () => {
    console.log(`
╔════════════════════════════════════════╗
║     LEO Protocol Dashboard Server      ║
╠════════════════════════════════════════╣
║  Status: ✅ Running                    ║
║  Port:   ${PORT}                          ║
║  URL:    http://localhost:${PORT}         ║
║  Real-time: ${realtimeManager.isConnected ? '✅ Enabled' : '⚠️ Disabled'}          ║
╚════════════════════════════════════════╝
    `);
  });
}

// Handle shutdown gracefully
process.on('SIGTERM', async () => {
  console.log('Shutting down dashboard server...');
  
  // Clean up real-time subscriptions
  if (realtimeManager.isConnected) {
    await realtimeManager.cleanup();
  }
  
  server.close(() => {
    console.log('Server closed');
    process.exit(0);
  });
});

process.on('SIGINT', async () => {
  console.log('\nShutting down dashboard server...');
  
  // Clean up real-time subscriptions
  if (realtimeManager.isConnected) {
    await realtimeManager.cleanup();
  }
  
  server.close(() => {
    console.log('Server closed');
    process.exit(0);
  });
});

// Start the server
startServer();