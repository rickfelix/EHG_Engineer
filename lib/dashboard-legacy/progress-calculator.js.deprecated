/**
 * LEO Protocol v4.1 Progress Calculator
 * Deterministic progress calculation that replaces metadata-based approach
 * Single source of truth for all progress calculations
 */

class ProgressCalculator {
  constructor() {
    // LEO Protocol v4.1 official phase weights
    this.PHASE_WEIGHTS = {
      LEAD_PLANNING: 20,      // SD creation and approval
      PLAN_DESIGN: 20,        // PRD creation and planning
      EXEC_IMPLEMENTATION: 30, // Implementation work
      PLAN_VERIFICATION: 15,   // Testing and verification
      LEAD_APPROVAL: 15       // Final approval and deployment
    };

    this.PHASE_ORDER = [
      'LEAD_PLANNING',
      'PLAN_DESIGN', 
      'EXEC_IMPLEMENTATION',
      'PLAN_VERIFICATION',
      'LEAD_APPROVAL'
    ];
  }

  /**
   * Calculate SD progress using deterministic LEO Protocol v4.1 rules
   * This is the SINGLE SOURCE OF TRUTH for progress calculation
   */
  calculateSDProgress(sd, prd) {
    // SPECIAL CASE: For archived SDs with metadata completion_percentage but no PRD,
    // respect the manual completion percentage (e.g., foundation SDs)
    if (sd?.status === 'archived' && sd?.metadata?.completion_percentage === 100 && !prd) {
      return {
        phases: {
          LEAD_PLANNING: 100,
          PLAN_DESIGN: 100,
          EXEC_IMPLEMENTATION: 100,
          PLAN_VERIFICATION: 100,
          LEAD_APPROVAL: 100
        },
        total: 100,
        currentPhase: 'COMPLETE',
        details: {
          manualCompletion: true,
          reason: 'Archived SD with manual 100% completion (no PRD required)'
        }
      };
    }

    const progress = {
      phases: {
        LEAD_PLANNING: 0,
        PLAN_DESIGN: 0,
        EXEC_IMPLEMENTATION: 0,
        PLAN_VERIFICATION: 0,
        LEAD_APPROVAL: 0
      },
      total: 0,
      currentPhase: 'LEAD_PLANNING',
      details: {}
    };

    // PHASE 1: LEAD Planning (20%)
    progress.phases.LEAD_PLANNING = this.calculateLeadPlanningProgress(sd);
    progress.details.leadPlanning = this.getLeadPlanningDetails(sd);

    // PHASE 2: PLAN Design (20%) - requires PRD
    if (prd) {
      progress.phases.PLAN_DESIGN = this.calculatePlanDesignProgress(prd);
      progress.details.planDesign = this.getPlanDesignDetails(prd);

      // PHASE 3: EXEC Implementation (30%)
      progress.phases.EXEC_IMPLEMENTATION = this.calculateExecImplementationProgress(prd);
      progress.details.execImplementation = this.getExecImplementationDetails(prd);

      // PHASE 4: PLAN Verification (15%)
      progress.phases.PLAN_VERIFICATION = this.calculatePlanVerificationProgress(prd);
      progress.details.planVerification = this.getPlanVerificationDetails(prd);

      // PHASE 5: LEAD Approval (15%)
      progress.phases.LEAD_APPROVAL = this.calculateLeadApprovalProgress(prd);
      progress.details.leadApproval = this.getLeadApprovalDetails(prd);
    }

    // Calculate total progress using official weights
    progress.total = Math.round(
      (progress.phases.LEAD_PLANNING * this.PHASE_WEIGHTS.LEAD_PLANNING / 100) +
      (progress.phases.PLAN_DESIGN * this.PHASE_WEIGHTS.PLAN_DESIGN / 100) +
      (progress.phases.EXEC_IMPLEMENTATION * this.PHASE_WEIGHTS.EXEC_IMPLEMENTATION / 100) +
      (progress.phases.PLAN_VERIFICATION * this.PHASE_WEIGHTS.PLAN_VERIFICATION / 100) +
      (progress.phases.LEAD_APPROVAL * this.PHASE_WEIGHTS.LEAD_APPROVAL / 100)
    );

    // Determine current phase
    progress.currentPhase = this.determineCurrentPhase(progress.phases);

    return progress;
  }

  /**
   * LEAD Planning Phase (20%) - SD Creation and Definition
   */
  calculateLeadPlanningProgress(sd) {
    if (!sd || !sd.id) return 0;

    // Check if SD is a placeholder/draft
    const isPlaceholder = 
      sd.title === '[Enter Strategic Directive Title]' ||
      !sd.title ||
      sd.status === 'draft' ||
      sd.title.trim().length === 0;

    if (isPlaceholder) return 0;

    // SD exists with meaningful content
    return 100;
  }

  getLeadPlanningDetails(sd) {
    return {
      hasTitle: sd?.title && sd.title !== '[Enter Strategic Directive Title]',
      hasDescription: sd?.description && sd.description.trim().length > 0,
      hasObjectives: sd?.strategic_objectives && sd.strategic_objectives.length > 0,
      isActive: sd?.status !== 'draft'
    };
  }

  /**
   * PLAN Design Phase (20%) - PRD Creation and Planning
   */
  calculatePlanDesignProgress(prd) {
    if (!prd) return 0;

    const planChecklist = prd.plan_checklist || [];
    if (planChecklist.length === 0) return 100; // No checklist = considered complete

    const completedItems = planChecklist.filter(item => 
      (typeof item === 'object' && item.checked) || 
      (typeof item === 'string' && false) // strings default to unchecked
    ).length;

    return Math.round((completedItems / planChecklist.length) * 100);
  }

  getPlanDesignDetails(prd) {
    const planChecklist = prd.plan_checklist || [];
    return {
      totalItems: planChecklist.length,
      completedItems: planChecklist.filter(item => 
        typeof item === 'object' && item.checked
      ).length,
      hasRequirements: prd?.functional_requirements?.length > 0,
      hasTechnicalSpecs: prd?.technical_requirements?.length > 0
    };
  }

  /**
   * EXEC Implementation Phase (30%) - Implementation Work
   */
  calculateExecImplementationProgress(prd) {
    if (!prd) return 0;

    const execChecklist = prd.exec_checklist || [];
    if (execChecklist.length === 0) return 100; // No checklist = considered complete

    const completedItems = execChecklist.filter(item => 
      (typeof item === 'object' && item.checked) || 
      (typeof item === 'string' && false)
    ).length;

    return Math.round((completedItems / execChecklist.length) * 100);
  }

  getExecImplementationDetails(prd) {
    const execChecklist = prd.exec_checklist || [];
    return {
      totalItems: execChecklist.length,
      completedItems: execChecklist.filter(item => 
        typeof item === 'object' && item.checked
      ).length,
      phase: prd?.phase || 'unknown'
    };
  }

  /**
   * PLAN Verification Phase (15%) - Testing and Quality Assurance
   */
  calculatePlanVerificationProgress(prd) {
    if (!prd) return 0;

    // Check multiple sources for verification data
    let verificationItems = [];

    // 1. Check direct validation_checklist
    if (prd.validation_checklist && Array.isArray(prd.validation_checklist) && prd.validation_checklist.length > 0) {
      verificationItems = prd.validation_checklist;
    }
    // 2. Check metadata for verification_checklist (new approach)
    else if (prd.metadata?.verification_checklist && Array.isArray(prd.metadata.verification_checklist) && prd.metadata.verification_checklist.length > 0) {
      verificationItems = prd.metadata.verification_checklist;
    }
    // 3. Check status-based completion
    else if (prd.status === 'verification_complete' || prd.status === 'approved') {
      return 100;
    }

    if (!Array.isArray(verificationItems) || verificationItems.length === 0) return 0; // No verification data

    const completedItems = verificationItems.filter(item => 
      (typeof item === 'object' && item.checked) || 
      (typeof item === 'string' && false)
    ).length;

    return Math.round((completedItems / verificationItems.length) * 100);
  }

  getPlanVerificationDetails(prd) {
    let verificationItems = prd.validation_checklist || prd.metadata?.verification_checklist || [];
    
    // Ensure verificationItems is an array
    if (!Array.isArray(verificationItems)) {
      verificationItems = [];
    }
    
    return {
      totalItems: verificationItems.length,
      completedItems: verificationItems.filter(item => 
        typeof item === 'object' && item.checked
      ).length,
      status: prd?.status,
      hasQualityAssurance: prd?.metadata?.quality_assurance === 'PASSED'
    };
  }

  /**
   * LEAD Approval Phase (15%) - Final Approval
   */
  calculateLeadApprovalProgress(prd) {
    if (!prd) return 0;

    // Check explicit approval
    if (prd.approved_by === 'LEAD' && prd.approval_date) {
      return 100;
    }

    // Check status-based approval
    if (prd.status === 'approved' || prd.status === 'complete' || prd.status === 'completed') {
      return 100;
    }

    return 0;
  }

  getLeadApprovalDetails(prd) {
    return {
      isApproved: prd?.approved_by === 'LEAD',
      approvalDate: prd?.approval_date,
      approver: prd?.approved_by,
      status: prd?.status
    };
  }

  /**
   * Determine current active phase based on progress
   */
  determineCurrentPhase(phases) {
    // Find first incomplete phase
    for (const phase of this.PHASE_ORDER) {
      if (phases[phase] < 100) {
        return phase;
      }
    }
    
    // All phases complete
    return 'COMPLETE';
  }

  /**
   * Get human-readable phase name
   */
  getPhaseDisplayName(phase) {
    const displayNames = {
      LEAD_PLANNING: 'LEAD Planning',
      PLAN_DESIGN: 'PLAN Design',
      EXEC_IMPLEMENTATION: 'EXEC Implementation',
      PLAN_VERIFICATION: 'PLAN Verification',
      LEAD_APPROVAL: 'LEAD Approval',
      COMPLETE: 'Complete'
    };
    
    return displayNames[phase] || phase;
  }

  /**
   * Get progress summary for dashboard
   */
  getProgressSummary(sd, prd) {
    const progress = this.calculateSDProgress(sd, prd);
    
    return {
      total: progress.total,
      currentPhase: progress.currentPhase,
      currentPhaseDisplay: this.getPhaseDisplayName(progress.currentPhase),
      phases: Object.entries(progress.phases).map(([phase, percentage]) => ({
        phase,
        phaseDisplay: this.getPhaseDisplayName(phase),
        percentage,
        weight: this.PHASE_WEIGHTS[phase],
        isComplete: percentage === 100,
        isCurrent: phase === progress.currentPhase
      })),
      details: progress.details
    };
  }

  /**
   * Calculate system-wide progress (all SDs)
   */
  calculateSystemProgress(allSDs, allPRDs) {
    if (!allSDs || allSDs.length === 0) return { average: 0, breakdown: {} };

    const prdMap = {};
    if (allPRDs) {
      allPRDs.forEach(prd => {
        prdMap[prd.directive_id] = prd;
      });
    }

    let totalProgress = 0;
    const breakdown = {
      byPhase: {},
      bySD: []
    };

    allSDs.forEach(sd => {
      const prd = prdMap[sd.id];
      const progress = this.calculateSDProgress(sd, prd);
      
      totalProgress += progress.total;
      breakdown.bySD.push({
        id: sd.id,
        title: sd.title,
        progress: progress.total,
        currentPhase: progress.currentPhase
      });

      // Aggregate by phase
      Object.entries(progress.phases).forEach(([phase, percentage]) => {
        if (!breakdown.byPhase[phase]) {
          breakdown.byPhase[phase] = { total: 0, count: 0, average: 0 };
        }
        breakdown.byPhase[phase].total += percentage;
        breakdown.byPhase[phase].count += 1;
      });
    });

    // Calculate phase averages
    Object.keys(breakdown.byPhase).forEach(phase => {
      const phaseData = breakdown.byPhase[phase];
      phaseData.average = Math.round(phaseData.total / phaseData.count);
    });

    return {
      average: Math.round(totalProgress / allSDs.length),
      breakdown
    };
  }
}

export default ProgressCalculator;