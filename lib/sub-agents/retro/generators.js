/**
 * RETRO Sub-Agent Content Generators
 * Extracted from retro.js for modularity
 */

import {
  extractTestMetrics,
  categorizeLearning,
  extractAffectedComponents,
  calculateOnSchedule,
  calculateWithinScope
} from './analyzers.js';

import {
  generateSmartActionItems,
  generateImprovementAreas
} from './action-items.js';

/**
 * Generate retrospective content
 * @param {Object} sdData - Strategic Directive data
 * @param {Object} prdData - PRD data
 * @param {Object} handoffs - Handoff analysis
 * @param {Object} subAgentResults - Sub-agent execution results
 * @param {Object} _options - Options (unused)
 * @param {Object} testEvidence - Test evidence
 * @param {Object} deliverables - Deliverables data
 * @param {Object} storyCoverage - Story coverage data
 */
export function generateRetrospective(sdData, prdData, handoffs, subAgentResults, _options, testEvidence = null, deliverables = null, storyCoverage = null) {
  const objectivesMet = sdData.status === 'completed';
  const onSchedule = calculateOnSchedule(prdData, handoffs, sdData);
  const withinScope = calculateWithinScope(deliverables);
  // SD-LEARN-FIX-ADDRESS-IMPROVEMENT-LEARN-002: Removed legacy_id fallback (column dropped 2026-01-24)
  const sdKey = sdData.sd_key || sdData.id?.substring(0, 8);
  const sdTitle = sdData.title || 'Unknown SD';

  // SD-LEO-REFAC-TESTING-INFRA-001: Generate SD-specific "what went well" items
  // Avoid generic phrases that trigger boilerplate detection
  const whatWentWell = generateWhatWentWell(sdData, prdData, handoffs, subAgentResults, testEvidence, sdKey, sdTitle);

  // SD-LEO-REFAC-TESTING-INFRA-001: Generate SD-specific improvement items
  // Focus on actionable observations, not generic recommendations
  const whatNeedsImprovement = generateWhatNeedsImprovement(sdData, prdData, handoffs, subAgentResults, testEvidence, sdKey);

  const keyLearnings = generateSdTypeSpecificLearnings(sdData, prdData, handoffs, subAgentResults, testEvidence);

  const successPatterns = [];
  if (whatWentWell.length > 3) successPatterns.push('Comprehensive validation');
  if (handoffs.count >= 4) successPatterns.push('Complete LEO Protocol workflow');
  if (subAgentResults.count >= 3) successPatterns.push('Multi-dimensional verification');

  const failurePatterns = [];
  if (whatNeedsImprovement.length > 2) failurePatterns.push('Protocol shortcuts taken');

  const protocolImprovements = generateProtocolImprovements(sdData, prdData, handoffs, subAgentResults, whatNeedsImprovement);
  const actionItems = generateSmartActionItems(sdData, prdData, handoffs, subAgentResults, whatNeedsImprovement, protocolImprovements);

  if (protocolImprovements.length > 0) {
    actionItems.push(`Apply ${protocolImprovements.length} LEO Protocol improvement(s) to leo_protocol_sections table`);
  }

  const improvementAreas = generateImprovementAreas(sdData, prdData, handoffs, subAgentResults, whatNeedsImprovement, testEvidence);

  let qualityScore = 70;
  if (objectivesMet) qualityScore += 10;
  if (prdData.found) qualityScore += 5;
  if (handoffs.count >= 4) qualityScore += 10;
  if (subAgentResults.count >= 3) qualityScore += 5;

  let teamSatisfaction = 7;
  if (objectivesMet) teamSatisfaction += 1;
  if (qualityScore >= 90) teamSatisfaction += 1;
  if (teamSatisfaction > 10) teamSatisfaction = 10;

  const learningCategory = categorizeLearning(sdData, prdData, handoffs, subAgentResults);

  return {
    sd_id: sdData.id,
    target_application: sdData.target_application,
    title: `${sdData.title} - Retrospective`,
    retro_type: 'SD_COMPLETION',
    conducted_date: new Date().toISOString().split('T')[0],
    generated_by: 'MANUAL',
    status: 'PUBLISHED',
    learning_category: learningCategory,
    what_went_well: whatWentWell,
    what_needs_improvement: whatNeedsImprovement,
    key_learnings: keyLearnings,
    success_patterns: successPatterns,
    failure_patterns: failurePatterns,
    action_items: actionItems,
    improvement_areas: improvementAreas,
    quality_score: qualityScore,
    team_satisfaction: teamSatisfaction,
    objectives_met: objectivesMet,
    on_schedule: onSchedule,
    within_scope: withinScope,
    velocity_achieved: sdData.progress_percentage || 100,
    business_value_delivered: qualityScore,
    auto_generated: true,
    description: `Comprehensive retrospective for ${sdData.title}. Generated by RETRO sub-agent.`,
    protocol_improvements: protocolImprovements,
    affected_components: extractAffectedComponents(sdData, learningCategory),
    tags: [],
    // Quick-fix QF-20260201-963: Capture future enhancement opportunities
    future_enhancements: extractFutureEnhancements(sdData, prdData, subAgentResults),
    ...extractTestMetrics(sdData.id, testEvidence, storyCoverage)
  };
}

/**
 * Generate LEO Protocol improvements based on retrospective analysis
 */
export function generateProtocolImprovements(sdData, prdData, handoffs, subAgentResults, whatNeedsImprovement) {
  const improvements = [];
  const sdType = (sdData.sd_type || 'feature').toLowerCase();

  const EXEMPT_FROM_TESTING = ['orchestrator', 'documentation', 'docs'];
  const EXEMPT_FROM_E2E = ['orchestrator', 'documentation', 'docs', 'infrastructure'];
  const EXEMPT_FROM_SUBAGENTS = ['orchestrator', 'documentation', 'docs', 'bugfix'];
  const EXEMPT_FROM_FULL_HANDOFFS = ['orchestrator', 'documentation', 'docs', 'infrastructure', 'bugfix'];
  const EXEMPT_FROM_PRD = ['documentation', 'docs'];

  if (!prdData.found && !EXEMPT_FROM_PRD.includes(sdType)) {
    improvements.push({
      category: 'PLAN_ENFORCEMENT',
      improvement: 'Enforce LEAD→PLAN handoff requirement: Block EXEC phase if no PRD exists',
      evidence: `SD ${sdData.id} proceeded without PRD creation`,
      impact: 'Prevents implementation without documented requirements',
      affected_phase: 'LEAD'
    });
  }

  const minHandoffs = EXEMPT_FROM_FULL_HANDOFFS.includes(sdType) ? 2 : 4;
  if (handoffs.count < minHandoffs && !['orchestrator'].includes(sdType)) {
    const missingHandoffs = minHandoffs - handoffs.count;
    improvements.push({
      category: 'HANDOFF_ENFORCEMENT',
      improvement: `Strengthen handoff validation: ${missingHandoffs} handoff(s) missing from complete chain`,
      evidence: `SD ${sdData.id} (${sdType}) had ${handoffs.count}/${minHandoffs} expected handoffs`,
      impact: 'Ensures complete handoff cycle for this SD type',
      affected_phase: null
    });
  }

  if (subAgentResults.count === 0 && !EXEMPT_FROM_SUBAGENTS.includes(sdType)) {
    improvements.push({
      category: 'SUB_AGENT_AUTOMATION',
      improvement: 'Auto-trigger sub-agents on handoff creation: No sub-agents executed during SD lifecycle',
      evidence: `SD ${sdData.id} completed without any sub-agent validations`,
      impact: 'Prevents quality gaps from manual-only verification',
      affected_phase: 'EXEC'
    });
  }

  const testingRun = subAgentResults.results?.some(r => r.sub_agent_code === 'TESTING');
  if (!testingRun && subAgentResults.count > 0 && !EXEMPT_FROM_TESTING.includes(sdType)) {
    improvements.push({
      category: 'TESTING_ENFORCEMENT',
      improvement: 'Mandate TESTING sub-agent execution before EXEC→PLAN handoff',
      evidence: `SD ${sdData.id} ran ${subAgentResults.count} sub-agents but not TESTING`,
      impact: 'Ensures test coverage validation before completion claims',
      affected_phase: 'EXEC'
    });
  }

  if (whatNeedsImprovement.length > 3) {
    improvements.push({
      category: 'PROCESS_SIMPLIFICATION',
      improvement: 'Review SD scope: High improvement count suggests over-scoping',
      evidence: `SD ${sdData.id} identified ${whatNeedsImprovement.length} improvement areas`,
      impact: 'Encourages smaller, more focused SDs with fewer gaps',
      affected_phase: 'LEAD'
    });
  }

  const category = sdData.category?.toLowerCase() || '';

  if (category.includes('test') || category.includes('qa')) {
    improvements.push({
      category: 'TESTING_METRICS',
      improvement: 'Add test coverage metrics to testing-focused SD retrospectives',
      evidence: `SD ${sdData.id} is testing-related but may lack coverage metrics`,
      impact: 'Quantifies testing improvements for future reference',
      affected_phase: 'PLAN'
    });
  }

  if (category.includes('database') || category.includes('schema')) {
    improvements.push({
      category: 'DATABASE_VALIDATION',
      improvement: 'Mandate DATABASE sub-agent for schema-related SDs',
      evidence: `SD ${sdData.id} involves database changes`,
      impact: 'Ensures schema changes are validated before deployment',
      affected_phase: 'EXEC'
    });
  }

  if (EXEMPT_FROM_TESTING.includes(sdType) || EXEMPT_FROM_E2E.includes(sdType) || EXEMPT_FROM_SUBAGENTS.includes(sdType)) {
    console.log(`   ℹ️  SD type '${sdType}' exemptions applied:`);
    if (EXEMPT_FROM_TESTING.includes(sdType)) console.log('      - Exempt from TESTING_ENFORCEMENT');
    if (EXEMPT_FROM_E2E.includes(sdType)) console.log('      - Exempt from E2E_TESTING');
    if (EXEMPT_FROM_SUBAGENTS.includes(sdType)) console.log('      - Exempt from SUB_AGENT_AUTOMATION');
    if (EXEMPT_FROM_FULL_HANDOFFS.includes(sdType)) console.log('      - Using simplified handoff chain');
    if (EXEMPT_FROM_PRD.includes(sdType)) console.log('      - PRD optional');
  }

  return improvements;
}

/**
 * Generate SD-specific learnings by analyzing actual execution data
 *
 * SD-LEO-REFAC-TESTING-INFRA-001: Replaced template-based learnings with
 * data-driven insights extracted from sub-agent results, handoffs, and PRD.
 *
 * SD-LEO-INFRA-ENHANCE-RETRO-SUB-001: Added success_metrics integration
 * to tie learnings to actual outcomes vs baselines.
 *
 * Key changes:
 * - Extract specific findings from sub-agent metadata
 * - Analyze PRD functional requirements vs completion
 * - Identify unique challenges and solutions from this SD
 * - Avoid generic phrases that match boilerplate patterns
 * - Reference SD success_metrics for outcome-tied learnings
 */
export function generateSdTypeSpecificLearnings(sdData, prdData, handoffs, subAgentResults, testEvidence) {
  const learnings = [];
  const sdTitle = sdData.title || 'Unknown SD';
  // SD-LEARN-FIX-ADDRESS-IMPROVEMENT-LEARN-002: Removed legacy_id fallback (column dropped 2026-01-24)
  const sdKey = sdData.sd_key || sdData.id?.substring(0, 8);

  // SD-LEO-INFRA-ENHANCE-RETRO-SUB-001: Extract insights from success_metrics
  const successMetricsInsights = extractSuccessMetricsInsights(sdData, sdKey);
  learnings.push(...successMetricsInsights);

  // Extract ACTUAL insights from sub-agent execution results
  if (subAgentResults.count > 0) {
    const subAgentInsights = extractSubAgentInsights(subAgentResults.results, sdKey);
    learnings.push(...subAgentInsights);
  }

  // Extract insights from PRD if available
  if (prdData.found && prdData.prd) {
    const prdInsights = extractPRDInsights(prdData.prd, sdKey, sdTitle);
    learnings.push(...prdInsights);
  }

  // Extract insights from handoff chain
  if (handoffs.count > 0) {
    const handoffInsights = extractHandoffInsights(handoffs.handoffs, sdKey);
    learnings.push(...handoffInsights);
  }

  // Extract test-specific learnings
  if (testEvidence) {
    const testInsights = extractTestInsights(testEvidence, sdKey);
    learnings.push(...testInsights);
  }

  // Add SD-title-specific learning (always unique per SD)
  learnings.push({
    category: 'SD_SPECIFIC',
    learning: `"${sdTitle}" implemented and validated through ${subAgentResults.count} sub-agent executions across ${handoffs.count} phase transitions.`,
    evidence: `SD ${sdKey} completion metadata`,
    applicability: `Reference ${sdKey} patterns for similar future work`,
    success_metrics: sdData.success_metrics || []
  });

  return learnings;
}

/**
 * Extract insights from SD success_metrics field
 * SD-LEO-INFRA-ENHANCE-RETRO-SUB-001: Tie learnings to actual outcomes vs baselines
 *
 * @param {Object} sdData - Strategic Directive data with success_metrics
 * @param {string} sdKey - SD key for reference
 * @returns {Array} Learnings tied to success metrics
 */
function extractSuccessMetricsInsights(sdData, sdKey) {
  const insights = [];
  const metrics = sdData.success_metrics;

  // Handle different success_metrics formats (array, object with primary/secondary, or string)
  let metricsArray = [];

  if (Array.isArray(metrics)) {
    metricsArray = metrics;
  } else if (metrics && typeof metrics === 'object') {
    // Handle {primary: [...], secondary: [...]} format
    if (metrics.primary) {
      metricsArray.push(...(Array.isArray(metrics.primary) ? metrics.primary : []));
    }
    if (metrics.secondary) {
      metricsArray.push(...(Array.isArray(metrics.secondary) ? metrics.secondary : []));
    }
  } else if (typeof metrics === 'string') {
    // Try to parse JSON string
    try {
      const parsed = JSON.parse(metrics);
      if (Array.isArray(parsed)) {
        metricsArray = parsed;
      } else if (parsed.primary) {
        metricsArray.push(...(Array.isArray(parsed.primary) ? parsed.primary : []));
        if (parsed.secondary) {
          metricsArray.push(...(Array.isArray(parsed.secondary) ? parsed.secondary : []));
        }
      }
    } catch {
      // Not valid JSON, skip
    }
  }

  if (metricsArray.length === 0) {
    // No success_metrics found - this is an insight itself
    console.log(`   ℹ️  No success_metrics found for ${sdKey} - learnings won't reference baselines`);
    return insights;
  }

  console.log(`   ✓ Extracting learnings from ${metricsArray.length} success_metrics for ${sdKey}`);

  // Extract up to 3 metrics to avoid bloat
  const topMetrics = metricsArray.slice(0, 3);

  for (const metric of topMetrics) {
    if (metric.metric && metric.baseline && metric.target) {
      // Full metric with baseline and target
      insights.push({
        category: 'SUCCESS_METRICS_OUTCOME',
        learning: `${sdKey} metric "${metric.metric}": Baseline ${metric.baseline} → Target ${metric.target}${metric.measurement ? ` (measured via: ${metric.measurement})` : ''}.`,
        evidence: 'SD success_metrics field',
        applicability: `Use ${sdKey} metrics as reference for similar SD scope estimation`,
        success_metrics: [metric]
      });
    } else if (metric.metric) {
      // Partial metric (at least has metric name)
      insights.push({
        category: 'SUCCESS_METRICS_DEFINED',
        learning: `${sdKey} defined success metric: "${metric.metric}"${metric.target ? ` with target ${metric.target}` : ''}.`,
        evidence: 'SD success_metrics field',
        applicability: 'Ensure similar SDs define measurable success criteria',
        success_metrics: [metric]
      });
    }
  }

  // If SD is completed, add outcome learning
  if (sdData.status === 'completed' && metricsArray.length > 0) {
    const metricNames = metricsArray.slice(0, 3).map(m => m.metric || 'unnamed').join(', ');
    insights.push({
      category: 'METRICS_ACHIEVED',
      learning: `${sdKey} completed with ${metricsArray.length} defined success metrics (${metricNames}). Metrics enabled objective completion validation.`,
      evidence: 'SD status=completed with success_metrics populated',
      applicability: 'Pre-defining metrics reduces subjective completion claims',
      success_metrics: metricsArray.slice(0, 3)
    });
  }

  return insights;
}

/**
 * Extract specific insights from sub-agent execution results
 */
function extractSubAgentInsights(results, sdKey) {
  const insights = [];

  // Group results by agent
  const byAgent = {};
  for (const r of results) {
    if (!byAgent[r.sub_agent_code]) {
      byAgent[r.sub_agent_code] = [];
    }
    byAgent[r.sub_agent_code].push(r);
  }

  // Extract insights from each agent's results
  for (const [agentCode, agentResults] of Object.entries(byAgent)) {
    const passCount = agentResults.filter(r => r.verdict === 'PASS').length;
    const failCount = agentResults.filter(r => r.verdict === 'BLOCKED' || r.verdict === 'FAIL').length;
    const latestResult = agentResults[agentResults.length - 1];

    // Only create insight if there's meaningful data
    if (failCount > 0 && passCount > 0) {
      insights.push({
        category: `${agentCode}_VALIDATION`,
        learning: `${agentCode} initially blocked (${failCount}x) then passed (${passCount}x) for ${sdKey}. Resolution required ${agentResults.length} iterations.`,
        evidence: `Sub-agent execution chain: ${agentResults.map(r => r.verdict).join(' → ')}`,
        applicability: `When ${agentCode} blocks, check previous resolution patterns from ${sdKey}`
      });
    } else if (passCount === agentResults.length && passCount >= 2) {
      insights.push({
        category: `${agentCode}_PATTERN`,
        learning: `${agentCode} passed consistently (${passCount}x) for ${sdKey}, indicating stable validation criteria met.`,
        evidence: `All ${passCount} ${agentCode} executions returned PASS`,
        applicability: `${sdKey} demonstrates reliable ${agentCode} compliance pattern`
      });
    }
  }

  // Identify which agents were NOT run (potential gap)
  const expectedAgents = ['REGRESSION', 'TESTING', 'VALIDATION'];
  const ranAgents = new Set(Object.keys(byAgent));
  const missingAgents = expectedAgents.filter(a => !ranAgents.has(a));

  if (missingAgents.length > 0 && results.length > 0) {
    insights.push({
      category: 'VALIDATION_GAP',
      learning: `${sdKey} did not execute ${missingAgents.join(', ')} sub-agents. Consider if these validations apply to this SD type.`,
      evidence: `Ran: ${[...ranAgents].join(', ')}. Missing: ${missingAgents.join(', ')}`,
      applicability: 'Evaluate sub-agent coverage for SD type'
    });
  }

  return insights;
}

/**
 * Extract insights from PRD content
 */
function extractPRDInsights(prd, sdKey, sdTitle) {
  const insights = [];
  const frCount = prd.functional_requirements?.length || 0;

  if (frCount > 0) {
    // Extract specific FR details
    const frs = prd.functional_requirements;
    const highPriorityFRs = frs.filter(fr =>
      fr.priority === 'high' || fr.priority === 'required' || fr.priority === 'P0'
    );

    insights.push({
      category: 'REQUIREMENTS_ANALYSIS',
      learning: `PRD for "${sdTitle}" specified ${frCount} functional requirements${highPriorityFRs.length > 0 ? `, ${highPriorityFRs.length} marked high-priority` : ''}.`,
      evidence: `PRD ID: ${prd.id}, Title: "${prd.title}"`,
      applicability: `Reference ${sdKey} PRD structure for similar scope estimation`
    });

    // Extract first FR as example of specificity level
    if (frs[0]) {
      const firstFR = typeof frs[0] === 'string' ? frs[0] : (frs[0].description || frs[0].title || JSON.stringify(frs[0]));
      const truncatedFR = firstFR.length > 80 ? firstFR.substring(0, 77) + '...' : firstFR;
      insights.push({
        category: 'FR_PATTERN',
        learning: `FR example from ${sdKey}: "${truncatedFR}" - this specificity level enabled clear acceptance criteria.`,
        evidence: `FR-1 from PRD ${prd.id}`,
        applicability: 'Use similar FR detail level for measurable completion'
      });
    }
  }

  return insights;
}

/**
 * Extract insights from handoff chain
 */
function extractHandoffInsights(handoffList, sdKey) {
  const insights = [];
  const handoffTypes = [...new Set(handoffList.map(h => h.handoff_type))];

  // Calculate time between first and last handoff
  if (handoffList.length >= 2) {
    const sorted = [...handoffList].sort((a, b) =>
      new Date(a.created_at) - new Date(b.created_at)
    );
    const firstHandoff = sorted[0];
    const lastHandoff = sorted[sorted.length - 1];
    const durationHours = Math.round(
      (new Date(lastHandoff.created_at) - new Date(firstHandoff.created_at)) / (1000 * 60 * 60)
    );

    if (durationHours > 0) {
      insights.push({
        category: 'EXECUTION_TIMELINE',
        learning: `${sdKey} completed ${handoffList.length} handoffs (${handoffTypes.join(' → ')}) over ${durationHours} hours.`,
        evidence: `First: ${firstHandoff.handoff_type} at ${firstHandoff.created_at?.split('T')[0]}, Last: ${lastHandoff.handoff_type}`,
        applicability: `Use ${durationHours}h as reference for similar SD scope`
      });
    }
  }

  // Identify if any handoff type was repeated (indicates rework)
  const handoffCounts = {};
  for (const h of handoffList) {
    handoffCounts[h.handoff_type] = (handoffCounts[h.handoff_type] || 0) + 1;
  }
  const repeatedHandoffs = Object.entries(handoffCounts).filter(([_, count]) => count > 1);

  if (repeatedHandoffs.length > 0) {
    const repeated = repeatedHandoffs.map(([type, count]) => `${type}(${count}x)`).join(', ');
    insights.push({
      category: 'REWORK_PATTERN',
      learning: `${sdKey} had repeated handoffs: ${repeated}. This indicates iteration was needed to pass gates.`,
      evidence: `Handoff frequency analysis for ${sdKey}`,
      applicability: 'Repeated handoffs suggest areas for upfront validation'
    });
  }

  return insights;
}

/**
 * Extract insights from test evidence
 */
function extractTestInsights(testEvidence, sdKey) {
  const insights = [];

  if (testEvidence.pass_rate !== undefined) {
    const passRate = testEvidence.pass_rate;
    const verdict = testEvidence.verdict;

    insights.push({
      category: 'TEST_RESULTS',
      learning: `${sdKey} achieved ${passRate}% test pass rate (verdict: ${verdict}). Run type: ${testEvidence.run_type || 'unknown'}.`,
      evidence: `Test evidence ID: ${testEvidence.id || 'embedded'}, freshness: ${testEvidence.freshness_status || 'unknown'}`,
      applicability: passRate >= 95
        ? `${sdKey} test patterns can serve as reference for similar SDs`
        : `Review ${sdKey} test failures for regression prevention`
    });
  }

  return insights;
}

/**
 * Generate SD-specific "what went well" items
 * Avoids generic phrases that trigger boilerplate detection
 */
function generateWhatWentWell(sdData, prdData, handoffs, subAgentResults, testEvidence, sdKey, sdTitle) {
  const items = [];

  // Specific achievement based on SD title
  if (sdData.status === 'completed') {
    items.push(`"${sdTitle}" delivered all planned functionality`);
  }

  // Specific handoff achievement with types
  if (handoffs.count >= 3) {
    const types = [...new Set(handoffs.handoffs.map(h => h.handoff_type))];
    items.push(`${sdKey} executed ${handoffs.count} handoffs (${types.slice(0, 3).join(', ')})`);
  }

  // Specific PRD achievement
  if (prdData.found && prdData.prd) {
    const frCount = prdData.prd.functional_requirements?.length || 0;
    if (frCount > 0) {
      items.push(`PRD "${prdData.prd.title}" defined ${frCount} FRs - all addressed`);
    } else {
      items.push(`PRD created for ${sdKey} with structured requirements`);
    }
  }

  // Specific sub-agent achievements
  if (subAgentResults.count > 0) {
    const passCount = subAgentResults.results.filter(r => r.verdict === 'PASS').length;
    const agents = [...new Set(subAgentResults.results.map(r => r.sub_agent_code))];
    items.push(`${passCount}/${subAgentResults.count} sub-agent validations passed (${agents.slice(0, 3).join(', ')})`);
  }

  // Specific test achievement
  if (testEvidence?.verdict === 'PASS') {
    items.push(`${sdKey} tests: ${testEvidence.pass_rate}% pass rate achieved`);
  } else if (testEvidence?.pass_rate >= 80) {
    items.push(`${sdKey} test coverage at ${testEvidence.pass_rate}%`);
  }

  // Add SD-type specific achievement
  const sdType = (sdData.sd_type || sdData.category || 'feature').toLowerCase();
  if (sdType === 'refactor' || sdType === 'infrastructure') {
    items.push(`${sdType.charAt(0).toUpperCase() + sdType.slice(1)} completed without breaking existing functionality`);
  }

  return items;
}

/**
 * Generate SD-specific improvement items
 * Focuses on actionable observations, not generic recommendations
 */
function generateWhatNeedsImprovement(sdData, prdData, handoffs, subAgentResults, testEvidence, sdKey) {
  const items = [];

  // Specific PRD observation
  if (!prdData.found) {
    items.push(`${sdKey} proceeded without PRD - scope defined informally`);
  }

  // Specific handoff observation
  if (handoffs.count < 4) {
    const presentTypes = [...new Set(handoffs.handoffs.map(h => h.handoff_type))];
    const expectedTypes = ['LEAD-TO-PLAN', 'PLAN-TO-EXEC', 'EXEC-TO-PLAN', 'PLAN-TO-LEAD'];
    const missing = expectedTypes.filter(t => !presentTypes.includes(t));
    if (missing.length > 0) {
      items.push(`${sdKey} missing handoffs: ${missing.join(', ')}`);
    }
  }

  // Specific sub-agent observation
  if (subAgentResults.count === 0) {
    items.push(`${sdKey} completed without automated sub-agent validation`);
  } else {
    const failedAgents = subAgentResults.results
      .filter(r => r.verdict === 'BLOCKED' || r.verdict === 'FAIL')
      .map(r => r.sub_agent_code);
    const uniqueFailedAgents = [...new Set(failedAgents)];
    if (uniqueFailedAgents.length > 0) {
      items.push(`${sdKey} had blocking issues from: ${uniqueFailedAgents.join(', ')}`);
    }
  }

  // Specific test observation
  if (testEvidence) {
    if (testEvidence.verdict === 'FAIL') {
      items.push(`${sdKey} test failures at ${testEvidence.pass_rate}% pass rate need resolution`);
    }
    if (testEvidence.freshness_status === 'STALE') {
      items.push(`${sdKey} test evidence is stale (${testEvidence.freshness_status})`);
    }
  } else {
    items.push(`${sdKey} lacks unified test evidence in database`);
  }

  return items;
}

/**
 * Quick-fix QF-20260201-963: Extract future enhancement opportunities
 * Captures improvement ideas from SD metadata that would otherwise be lost.
 */
function extractFutureEnhancements(sdData, prdData, subAgentResults) {
  const enhancements = [];
  const sdKey = sdData.sd_key || sdData.id?.substring(0, 8);

  // Primary source: SD metadata.future_enhancements (set during implementation)
  if (sdData.metadata?.future_enhancements) {
    const noted = sdData.metadata.future_enhancements;
    if (Array.isArray(noted)) {
      enhancements.push(...noted.map(e => ({ ...e, source_sd_id: sdKey })));
    }
  }

  // Secondary: PRD items marked as future/nice-to-have
  if (prdData.found && prdData.prd?.non_functional_requirements) {
    const nfrs = prdData.prd.non_functional_requirements;
    for (const nfr of nfrs) {
      const text = typeof nfr === 'string' ? nfr : (nfr.description || '');
      if (text.toLowerCase().includes('future') || nfr.priority === 'future') {
        enhancements.push({ enhancement: text, source_sd_id: sdKey, captured_from: 'prd_nfr' });
      }
    }
  }

  return enhancements;
}
