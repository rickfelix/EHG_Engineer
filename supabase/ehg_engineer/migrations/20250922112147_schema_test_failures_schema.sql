-- LEO Protocol v4.1.3 - Enhanced QA with Fix Recommendations
-- Database schema for tracking test failures and fix recommendations
-- Maintains complete audit trail of testing and remediation efforts

-- =====================================================
-- Table: test_failures
-- Purpose: Track all test failures detected by Testing Sub-Agent
-- =====================================================
CREATE TABLE IF NOT EXISTS test_failures (
  id SERIAL PRIMARY KEY,
  test_id TEXT NOT NULL UNIQUE,
  test_run_id TEXT NOT NULL,
  target_component TEXT NOT NULL,
  error_type TEXT NOT NULL,
  error_message TEXT NOT NULL,
  stack_trace TEXT,
  
  -- Failure analysis details
  root_cause TEXT,
  code_location TEXT,
  confidence_score INTEGER CHECK (confidence_score >= 0 AND confidence_score <= 100),
  severity TEXT CHECK (severity IN ('HIGH', 'MEDIUM', 'LOW', 'UNKNOWN')),
  
  -- DOM and environment state at failure
  dom_state JSONB,
  console_errors JSONB,
  network_failures JSONB,
  screenshots TEXT[],
  
  -- Fix recommendation
  suggested_fix JSONB,
  fix_applied BOOLEAN DEFAULT FALSE,
  fix_validated BOOLEAN DEFAULT FALSE,
  
  -- Metadata
  prd_id TEXT,
  sd_id TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index for quick lookups
CREATE INDEX idx_test_failures_test_run ON test_failures(test_run_id);
CREATE INDEX idx_test_failures_component ON test_failures(target_component);
CREATE INDEX idx_test_failures_error_type ON test_failures(error_type);
CREATE INDEX idx_test_failures_severity ON test_failures(severity);
CREATE INDEX idx_test_failures_fix_status ON test_failures(fix_applied, fix_validated);

-- =====================================================
-- Table: fix_recommendations
-- Purpose: Detailed fix recommendations generated by recommendation engine
-- =====================================================
CREATE TABLE IF NOT EXISTS fix_recommendations (
  id SERIAL PRIMARY KEY,
  test_failure_id INTEGER REFERENCES test_failures(id) ON DELETE CASCADE,
  recommendation_id TEXT NOT NULL UNIQUE,
  
  -- Recommendation details
  summary TEXT NOT NULL,
  primary_action TEXT NOT NULL,
  alternative_actions JSONB,
  
  -- Implementation guidance
  implementation_steps JSONB NOT NULL,
  code_examples JSONB,
  estimated_time TEXT,
  estimated_effort TEXT CHECK (estimated_effort IN ('low', 'medium', 'high', 'very_high')),
  
  -- Validation
  validation_command TEXT,
  validation_description TEXT,
  prevention_tips JSONB,
  
  -- Confidence and priority
  confidence INTEGER CHECK (confidence >= 0 AND confidence <= 100),
  priority TEXT CHECK (priority IN ('CRITICAL', 'HIGH', 'MEDIUM', 'LOW')),
  
  -- Status tracking
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'in_progress', 'applied', 'validated', 'rejected')),
  assigned_to TEXT DEFAULT 'EXEC',
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index for performance
CREATE INDEX idx_fix_recommendations_failure ON fix_recommendations(test_failure_id);
CREATE INDEX idx_fix_recommendations_status ON fix_recommendations(status);
CREATE INDEX idx_fix_recommendations_priority ON fix_recommendations(priority);

-- =====================================================
-- Table: fix_validation_results
-- Purpose: Track validation attempts for applied fixes
-- =====================================================
CREATE TABLE IF NOT EXISTS fix_validation_results (
  id SERIAL PRIMARY KEY,
  fix_recommendation_id INTEGER REFERENCES fix_recommendations(id) ON DELETE CASCADE,
  
  -- Validation attempt details
  attempt_number INTEGER NOT NULL,
  success BOOLEAN NOT NULL,
  error_message TEXT,
  
  -- Refinement if validation failed
  refined_recommendation JSONB,
  refinement_applied BOOLEAN DEFAULT FALSE,
  
  -- Timing
  validation_duration_ms INTEGER,
  executed_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index for validation lookups
CREATE INDEX idx_validation_results_recommendation ON fix_validation_results(fix_recommendation_id);
CREATE INDEX idx_validation_results_success ON fix_validation_results(success);

-- =====================================================
-- Table: test_runs
-- Purpose: Track overall test execution runs
-- =====================================================
CREATE TABLE IF NOT EXISTS test_runs (
  id TEXT PRIMARY KEY,
  run_type TEXT CHECK (run_type IN ('automated', 'manual', 'validation', 'regression')),
  
  -- Run statistics
  total_tests INTEGER NOT NULL,
  passed INTEGER NOT NULL,
  failed INTEGER NOT NULL,
  warnings INTEGER DEFAULT 0,
  success_rate DECIMAL(5,2),
  
  -- Timing
  start_time TIMESTAMPTZ NOT NULL,
  end_time TIMESTAMPTZ,
  duration_seconds INTEGER,
  
  -- Configuration
  config JSONB,
  environment TEXT,
  base_url TEXT,
  
  -- Associated documents
  prd_id TEXT,
  sd_id TEXT,
  agent TEXT DEFAULT 'Testing Sub-Agent',
  
  -- Output locations
  report_path TEXT,
  screenshots_path TEXT,
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index for run lookups
CREATE INDEX idx_test_runs_type ON test_runs(run_type);
CREATE INDEX idx_test_runs_prd ON test_runs(prd_id);
CREATE INDEX idx_test_runs_created ON test_runs(created_at DESC);

-- =====================================================
-- Table: fix_handoffs
-- Purpose: Track handoffs between Testing Sub-Agent and EXEC for fixes
-- =====================================================
CREATE TABLE IF NOT EXISTS fix_handoffs (
  id SERIAL PRIMARY KEY,
  handoff_id TEXT NOT NULL UNIQUE,
  
  -- Handoff details
  from_agent TEXT NOT NULL DEFAULT 'Testing Sub-Agent',
  to_agent TEXT NOT NULL DEFAULT 'EXEC',
  test_run_id TEXT REFERENCES test_runs(id),
  
  -- Summary
  total_fixes_required INTEGER NOT NULL,
  total_estimated_time TEXT,
  overall_priority TEXT CHECK (overall_priority IN ('CRITICAL', 'HIGH', 'MEDIUM', 'LOW')),
  
  -- Document references
  handoff_document_path TEXT,
  fix_requests_path TEXT,
  
  -- Status
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'acknowledged', 'in_progress', 'completed', 'blocked')),
  acknowledged_at TIMESTAMPTZ,
  completed_at TIMESTAMPTZ,
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index for handoff tracking
CREATE INDEX idx_fix_handoffs_status ON fix_handoffs(status);
CREATE INDEX idx_fix_handoffs_test_run ON fix_handoffs(test_run_id);

-- =====================================================
-- Views for reporting and monitoring
-- =====================================================

-- View: Current fix status summary
CREATE OR REPLACE VIEW fix_status_summary AS
SELECT 
  COUNT(*) AS total_failures,
  COUNT(CASE WHEN f.fix_applied = TRUE THEN 1 END) AS fixes_applied,
  COUNT(CASE WHEN f.fix_validated = TRUE THEN 1 END) AS fixes_validated,
  COUNT(CASE WHEN f.fix_applied = FALSE THEN 1 END) AS pending_fixes,
  AVG(f.confidence_score) AS avg_confidence,
  COUNT(CASE WHEN f.severity = 'HIGH' THEN 1 END) AS high_severity_count,
  COUNT(CASE WHEN f.severity = 'MEDIUM' THEN 1 END) AS medium_severity_count,
  COUNT(CASE WHEN f.severity = 'LOW' THEN 1 END) AS low_severity_count
FROM test_failures f
WHERE f.created_at > NOW() - INTERVAL '7 days';

-- View: Recent test run performance
CREATE OR REPLACE VIEW recent_test_performance AS
SELECT 
  id AS run_id,
  run_type,
  total_tests,
  passed,
  failed,
  success_rate,
  duration_seconds,
  created_at
FROM test_runs
ORDER BY created_at DESC
LIMIT 10;

-- View: Fix recommendation effectiveness
CREATE OR REPLACE VIEW fix_effectiveness AS
SELECT 
  fr.error_type,
  COUNT(*) AS total_recommendations,
  COUNT(CASE WHEN r.status = 'validated' THEN 1 END) AS successful_fixes,
  AVG(r.confidence) AS avg_confidence,
  AVG(v.attempt_number) AS avg_attempts_to_fix
FROM test_failures fr
JOIN fix_recommendations r ON fr.id = r.test_failure_id
LEFT JOIN fix_validation_results v ON r.id = v.fix_recommendation_id AND v.success = TRUE
GROUP BY fr.error_type;

-- =====================================================
-- Functions for data management
-- =====================================================

-- Function: Record test failure with analysis
CREATE OR REPLACE FUNCTION record_test_failure(
  p_test_id TEXT,
  p_test_run_id TEXT,
  p_target TEXT,
  p_error_type TEXT,
  p_error_message TEXT,
  p_analysis JSONB,
  p_recommendation JSONB
) RETURNS INTEGER AS $$
DECLARE
  v_failure_id INTEGER;
  v_rec_id TEXT;
BEGIN
  -- Insert test failure
  INSERT INTO test_failures (
    test_id, test_run_id, target_component, error_type, error_message,
    root_cause, code_location, confidence_score, severity,
    dom_state, suggested_fix
  ) VALUES (
    p_test_id, p_test_run_id, p_target, p_error_type, p_error_message,
    p_analysis->>'rootCause', p_analysis->>'codeLocation',
    (p_analysis->>'confidence')::INTEGER, UPPER(p_analysis->>'severity'),
    p_analysis->'domState', p_recommendation
  ) RETURNING id INTO v_failure_id;
  
  -- Generate recommendation ID
  v_rec_id := 'REC-' || to_char(NOW(), 'YYYYMMDD-') || v_failure_id;
  
  -- Insert fix recommendation if provided
  IF p_recommendation IS NOT NULL THEN
    INSERT INTO fix_recommendations (
      test_failure_id, recommendation_id, summary, primary_action,
      implementation_steps, confidence, priority, estimated_time
    ) VALUES (
      v_failure_id, v_rec_id, p_recommendation->>'summary',
      p_recommendation->>'primaryFix', p_recommendation->'steps',
      (p_recommendation->>'confidence')::INTEGER,
      UPPER(p_recommendation->>'priority'),
      p_recommendation->>'estimatedTime'
    );
  END IF;
  
  RETURN v_failure_id;
END;
$$ LANGUAGE plpgsql;

-- Function: Update fix validation status
CREATE OR REPLACE FUNCTION update_fix_validation(
  p_test_id TEXT,
  p_validated BOOLEAN,
  p_attempt INTEGER DEFAULT 1
) RETURNS BOOLEAN AS $$
DECLARE
  v_failure_id INTEGER;
  v_rec_id INTEGER;
BEGIN
  -- Get failure ID
  SELECT id INTO v_failure_id FROM test_failures WHERE test_id = p_test_id;
  
  IF v_failure_id IS NULL THEN
    RETURN FALSE;
  END IF;
  
  -- Update failure validation status
  UPDATE test_failures 
  SET fix_validated = p_validated, updated_at = NOW()
  WHERE id = v_failure_id;
  
  -- Get recommendation ID
  SELECT id INTO v_rec_id FROM fix_recommendations WHERE test_failure_id = v_failure_id;
  
  -- Record validation result
  IF v_rec_id IS NOT NULL THEN
    INSERT INTO fix_validation_results (
      fix_recommendation_id, attempt_number, success
    ) VALUES (
      v_rec_id, p_attempt, p_validated
    );
    
    -- Update recommendation status
    IF p_validated THEN
      UPDATE fix_recommendations 
      SET status = 'validated', updated_at = NOW()
      WHERE id = v_rec_id;
    END IF;
  END IF;
  
  RETURN TRUE;
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- Triggers for automatic updates
-- =====================================================

-- Trigger: Update timestamp on modification
CREATE OR REPLACE FUNCTION update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_test_failures_timestamp
  BEFORE UPDATE ON test_failures
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at();

CREATE TRIGGER update_fix_recommendations_timestamp
  BEFORE UPDATE ON fix_recommendations
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at();

-- =====================================================
-- Indexes for performance optimization
-- =====================================================
CREATE INDEX idx_test_failures_created_at ON test_failures(created_at DESC);
CREATE INDEX idx_fix_recommendations_created_at ON fix_recommendations(created_at DESC);
CREATE INDEX idx_test_runs_success_rate ON test_runs(success_rate);

-- =====================================================
-- Comments for documentation
-- =====================================================
COMMENT ON TABLE test_failures IS 'Records all test failures detected by the Testing Sub-Agent with detailed analysis';
COMMENT ON TABLE fix_recommendations IS 'Stores actionable fix recommendations generated by the Fix Recommendation Engine';
COMMENT ON TABLE fix_validation_results IS 'Tracks validation attempts for applied fixes including refinements';
COMMENT ON TABLE test_runs IS 'Maintains history of all test execution runs with statistics';
COMMENT ON TABLE fix_handoffs IS 'Documents handoffs between Testing Sub-Agent and EXEC for fix implementation';

-- Grant permissions (adjust as needed for your environment)
-- GRANT SELECT, INSERT, UPDATE ON ALL TABLES IN SCHEMA public TO leo_testing_agent;
-- GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO leo_testing_agent;