<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>LEO Visual Playground — Geometric Forge</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;0,600;1,300&family=JetBrains+Mono:wght@300;400&display=swap');
  *{margin:0;padding:0;box-sizing:border-box}
  body{background:#040408;color:#e0dcd4;font-family:'Cormorant Garamond',serif;overflow:hidden;height:100vh;width:100vw}
  #app{display:flex;height:100vh;width:100vw}
  #scene{flex:7;position:relative;min-width:0}
  #panel{flex:3;min-width:220px;display:flex;flex-direction:column;
    background:rgba(4,4,16,0.95);border-left:1px solid rgba(0,200,255,0.1);
    font-family:'JetBrains Mono',monospace;overflow:hidden}
  canvas#c{width:100%;height:100%;display:block}

  .vi{position:absolute;top:0;left:0;width:100%;height:100%;z-index:4;pointer-events:none;
    background:radial-gradient(ellipse at center,transparent 30%,rgba(4,4,8,0.65) 100%)}

  .ov{position:absolute;z-index:10;pointer-events:none}
  .ti{top:26px;left:34px}
  .ti h1{font-size:12px;font-weight:300;letter-spacing:6px;text-transform:uppercase;color:rgba(0,200,255,0.9)}
  .ti h2{font-family:'JetBrains Mono',monospace;font-size:10px;font-weight:300;color:rgba(224,220,212,0.54);letter-spacing:1px;margin-top:2px}

  .stt{bottom:34px;left:34px}
  .sr{display:flex;align-items:baseline;gap:10px;margin-bottom:4px}
  .sl{font-family:'JetBrains Mono',monospace;font-size:8.5px;letter-spacing:2px;text-transform:uppercase;color:rgba(224,220,212,0.65);min-width:82px}
  .svl{font-size:14px;font-weight:300;color:rgba(0,200,255,1.0)}

  .phi{bottom:34px;left:50%;transform:translateX(-50%);text-align:center;width:500px}
  .phi-shape{font-size:16px;font-weight:300;color:rgba(0,200,255,1.0);font-style:italic;margin-bottom:4px}
  .phi-key{font-family:'JetBrains Mono',monospace;font-size:9px;letter-spacing:1px;color:rgba(224,220,212,0.78);margin-bottom:8px}
  .phi-bar{display:flex;justify-content:center;gap:3px;margin-bottom:8px}
  .phi-dot{width:60px;height:3px;border-radius:2px;background:rgba(224,220,212,0.18);transition:background .5s,box-shadow .5s}
  .phi-dot.on{background:rgba(0,200,255,0.96);box-shadow:0 0 10px rgba(0,200,255,0.48)}
  .phi-dot.dn{background:rgba(0,191,165,0.6)}
  .phi-labels{display:flex;justify-content:center}
  .phi-lbl{width:63px;font-family:'JetBrains Mono',monospace;font-size:6.5px;letter-spacing:.6px;text-transform:uppercase;color:rgba(224,220,212,0.65);text-align:center;transition:color .4s}
  .phi-lbl.on{color:rgba(0,200,255,1.0)}
  .phi-lbl.dn{color:rgba(0,191,165,0.66)}

  .conn{bottom:34px;right:34px;text-align:right}
  .conn-dot{display:inline-block;width:6px;height:6px;border-radius:50%;margin-right:6px;vertical-align:middle}
  .conn-dot.ok{background:#4a9e7d;box-shadow:0 0 6px rgba(74,158,125,0.4)}
  .conn-dot.err{background:#c4626a;box-shadow:0 0 6px rgba(196,98,106,0.4)}
  .conn-dot.wait{background:#ffab40;animation:pu 1.5s ease-in-out infinite}
  .conn-text{font-family:'JetBrains Mono',monospace;font-size:8.5px;letter-spacing:1px;color:rgba(224,220,212,0.65)}

  .cb{position:absolute;top:50%;left:34px;transform:translateY(-50%);z-index:10;pointer-events:all}
  .bt{display:block;background:none;border:1px solid rgba(0,200,255,0.12);color:rgba(224,220,212,0.6);
    font-family:'JetBrains Mono',monospace;font-size:8.5px;letter-spacing:2px;text-transform:uppercase;
    padding:6px 11px;margin-bottom:4px;cursor:pointer;transition:all .3s;min-width:110px;text-align:left}
  .bt:hover{border-color:rgba(0,200,255,0.3);color:#00c8ff}
  .bt.ac{border-color:rgba(0,200,255,0.4);color:#00c8ff;background:rgba(0,200,255,0.06)}
  .dvd{height:1px;background:rgba(0,200,255,0.06);margin:6px 0;width:110px}

  #slideProg{position:absolute;bottom:0;left:0;height:2px;background:rgba(0,200,255,0.3);z-index:10;transition:width .3s linear}

  .p-section{padding:10px 12px;border-bottom:1px solid rgba(0,200,255,0.1)}
  .p-header{font-size:8px;letter-spacing:2px;text-transform:uppercase;color:rgba(224,220,212,0.48);margin-bottom:8px}

  #activity{flex:0 0 auto;max-height:35%;overflow-y:auto}
  .log-entry{font-size:9px;line-height:1.5;color:rgba(224,220,212,0.54);margin-bottom:2px;
    white-space:nowrap;overflow:hidden;text-overflow:ellipsis;transition:color .5s}
  .log-entry.fresh{color:rgba(0,200,255,1.0)}
  .log-cs{color:#4a9e7d}.log-cp{color:#00c8ff}

  #filter-row{padding:8px 12px;border-bottom:1px solid rgba(0,200,255,0.08)}
  #filter-row select{width:100%;padding:4px 6px;background:rgba(8,8,24,0.8);color:rgba(224,220,212,0.72);
    border:1px solid rgba(0,200,255,0.12);border-radius:3px;font-family:'JetBrains Mono',monospace;font-size:9px}

  #estimate{padding:10px 12px;border-top:1px solid rgba(0,200,255,0.1)}
  #est-dur{font-size:16px;font-weight:300;color:rgba(0,200,255,1.0)}
  #est-detail{font-size:8.5px;line-height:1.6;color:rgba(224,220,212,0.48);margin-top:4px}
  #est-conf{font-size:8px;color:rgba(224,220,212,0.28);margin-top:2px}

  #queue{flex:1;overflow-y:auto;padding:0}
  .q-item{display:flex;align-items:center;gap:8px;padding:6px 12px;cursor:pointer;transition:background .2s;border-left:2px solid transparent}
  .q-item:hover{background:rgba(0,200,255,0.03)}
  .q-item.active{background:rgba(0,200,255,0.05);border-left-color:rgba(0,200,255,0.3)}
  .q-item.claimed{background:rgba(0,191,165,0.06);border-left-color:rgba(0,191,165,0.4)}
  .q-item.claimed .q-key{color:rgba(0,220,180,0.9)}
  .q-item.claimed.active{background:rgba(0,200,255,0.07);border-left-color:rgba(0,200,255,0.4)}
  .q-dot{width:6px;height:6px;border-radius:50%;flex-shrink:0}
  .q-key{font-size:9px;color:rgba(224,220,212,0.6);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .q-item.active .q-key{color:rgba(0,200,255,0.96)}
  .q-est{float:right;font-size:8px;color:rgba(224,220,212,0.36);font-style:italic}
  #history-panel{display:none;flex:1;overflow-y:auto;padding:0}
  .h-group{padding:8px 12px;border-bottom:1px solid rgba(0,200,255,0.06)}
  .h-group-title{font-size:8px;letter-spacing:2px;text-transform:uppercase;color:rgba(0,200,255,0.6);margin-bottom:6px}
  .h-item{font-size:9px;color:rgba(224,220,212,0.5);padding:3px 0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .h-item .h-date{color:rgba(224,220,212,0.28);margin-left:6px}
  .h-filters{display:flex;gap:6px;padding:8px 12px;border-bottom:1px solid rgba(0,200,255,0.08)}
  .h-filters select{flex:1;padding:4px 6px;background:rgba(8,8,24,0.8);color:rgba(224,220,212,0.72);
    border:1px solid rgba(0,200,255,0.12);border-radius:3px;font-family:'JetBrains Mono',monospace;font-size:9px}
  .q-toggle{float:right;font-size:8px;cursor:pointer;color:rgba(0,200,255,0.5);text-decoration:none;letter-spacing:1px}
  .q-toggle:hover{color:rgba(0,200,255,0.9)}
  #diag-card{display:none;position:absolute;z-index:50;pointer-events:all;
    background:rgba(8,8,24,0.94);border:1px solid rgba(0,200,255,0.25);border-radius:6px;
    padding:14px 16px;min-width:260px;max-width:380px;backdrop-filter:blur(8px);
    box-shadow:0 4px 20px rgba(0,0,0,0.5),0 0 15px rgba(0,200,255,0.08);
    font-family:'JetBrains Mono',monospace}
  #diag-card.show{display:block}
  #diag-card-close{position:absolute;top:6px;right:10px;background:none;border:none;
    color:rgba(0,200,255,0.5);font-size:14px;cursor:pointer;font-family:monospace;padding:2px}
  #diag-card-close:hover{color:#00c8ff}
  .dc-title{font-size:11px;font-weight:600;color:rgba(0,200,255,0.95);margin-bottom:6px;padding-right:16px}
  .dc-key{font-size:9px;color:rgba(224,220,212,0.5);margin-bottom:8px;letter-spacing:1px}
  .dc-row{display:flex;justify-content:space-between;font-size:9px;padding:3px 0;border-bottom:1px solid rgba(0,200,255,0.06)}
  .dc-label{color:rgba(224,220,212,0.55);text-transform:uppercase;letter-spacing:1px}
  .dc-value{color:rgba(224,220,212,0.85);text-align:right;max-width:200px;overflow:hidden;text-overflow:ellipsis}
  .dc-loading{font-size:9px;color:rgba(0,200,255,0.4);font-style:italic;margin-top:6px}
  #no-data{display:none;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);text-align:center;z-index:5;font-size:14px;font-weight:300;color:rgba(224,220,212,0.42)}
  #fallback{display:none;width:100%;padding:16px;overflow:auto;height:100%;font-family:'JetBrains Mono',monospace}
  #fallback table{width:100%;border-collapse:collapse;font-size:10px;color:rgba(224,220,212,0.48)}
  #fallback th,#fallback td{padding:6px 8px;border:1px solid rgba(0,200,255,0.1);text-align:left}
  #fallback th{background:rgba(8,8,24,0.8);color:rgba(224,220,212,0.3);text-transform:uppercase;letter-spacing:1px;font-size:8px}
  .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}

  #dup-alert{display:none;position:absolute;top:20px;left:50%;transform:translateX(-50%);z-index:100;
    background:rgba(40,4,4,0.92);border:2px solid rgba(255,60,60,0.7);border-radius:8px;
    padding:16px 24px;max-width:520px;width:90%;backdrop-filter:blur(8px);
    box-shadow:0 0 30px rgba(255,40,40,0.3),inset 0 0 20px rgba(255,40,40,0.05);
    animation:alertPulse 2s ease-in-out infinite}
  #dup-alert.show{display:block}
  #dup-alert-title{font-family:'JetBrains Mono',monospace;font-size:11px;font-weight:700;
    letter-spacing:3px;text-transform:uppercase;color:#ff4444;margin-bottom:8px;
    text-shadow:0 0 10px rgba(255,40,40,0.5)}
  #dup-alert-msg{font-family:'JetBrains Mono',monospace;font-size:9.5px;line-height:1.6;
    color:rgba(255,200,200,0.9)}
  #dup-alert-list{margin:8px 0 0;padding:0;list-style:none}
  #dup-alert-list li{padding:3px 0;color:#ff8888;font-family:'JetBrains Mono',monospace;font-size:9px;
    border-bottom:1px solid rgba(255,60,60,0.1)}
  #dup-alert-list li:last-child{border:none}
  #dup-alert-close{position:absolute;top:8px;right:12px;background:none;border:none;
    color:rgba(255,100,100,0.6);font-size:16px;cursor:pointer;font-family:monospace;padding:4px}
  #dup-alert-close:hover{color:#ff4444}
  #dup-alert-countdown{margin-top:10px;font-family:'JetBrains Mono',monospace;font-size:9px;
    color:rgba(255,180,180,0.7);letter-spacing:1px}
  @keyframes alertPulse{0%,100%{border-color:rgba(255,60,60,0.7);box-shadow:0 0 30px rgba(255,40,40,0.3)}
    50%{border-color:rgba(255,60,60,0.4);box-shadow:0 0 15px rgba(255,40,40,0.15)}}

  #idle-alert{display:none;position:absolute;top:20px;left:50%;transform:translateX(-50%);z-index:99;
    background:rgba(40,32,4,0.92);border:2px solid rgba(255,200,40,0.7);border-radius:8px;
    padding:16px 24px;max-width:520px;width:90%;backdrop-filter:blur(8px);
    box-shadow:0 0 30px rgba(255,200,40,0.2),inset 0 0 20px rgba(255,200,40,0.05);
    animation:idlePulse 3s ease-in-out infinite}
  #idle-alert.show{display:block}
  #idle-alert-title{font-family:'JetBrains Mono',monospace;font-size:11px;font-weight:700;
    letter-spacing:3px;text-transform:uppercase;color:#ffcc33;margin-bottom:8px;
    text-shadow:0 0 10px rgba(255,200,40,0.5)}
  #idle-alert-msg{font-family:'JetBrains Mono',monospace;font-size:9.5px;line-height:1.6;
    color:rgba(255,230,180,0.9)}
  #idle-alert-close{position:absolute;top:8px;right:12px;background:none;border:none;
    color:rgba(255,200,100,0.6);font-size:16px;cursor:pointer;font-family:monospace;padding:4px}
  #idle-alert-close:hover{color:#ffcc33}
  #idle-alert-duration{margin-top:8px;font-family:'JetBrains Mono',monospace;font-size:9px;
    color:rgba(255,220,150,0.7);letter-spacing:1px}
  @keyframes idlePulse{0%,100%{border-color:rgba(255,200,40,0.7);box-shadow:0 0 30px rgba(255,200,40,0.2)}
    50%{border-color:rgba(255,200,40,0.35);box-shadow:0 0 12px rgba(255,200,40,0.1)}}
  @keyframes pu{0%,100%{opacity:1}50%{opacity:.4}}
  @media(prefers-reduced-motion:reduce){*{animation-duration:0.01ms!important;transition-duration:0.01ms!important}}
  @media(max-width:900px){#app{flex-direction:column}#scene{flex:3}#panel{flex:1;min-width:0;max-width:none}#analytics{display:none!important}}

  /* ═══ Analytics Panel (Phase D) ═══ */
  #analytics{width:0;overflow:hidden;display:flex;flex-direction:column;
    background:rgba(4,4,16,0.97);border-left:1px solid rgba(0,200,255,0.1);
    font-family:'JetBrains Mono',monospace;transition:width .3s ease}
  #analytics.open{width:400px;min-width:400px}
  .an-header{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;
    border-bottom:1px solid rgba(0,200,255,0.1)}
  .an-title{font-size:9px;letter-spacing:2px;text-transform:uppercase;color:rgba(0,200,255,0.8)}
  .an-close{background:none;border:none;color:rgba(0,200,255,0.4);font-size:14px;cursor:pointer;padding:2px}
  .an-close:hover{color:#00c8ff}
  .an-status{display:inline-block;width:6px;height:6px;border-radius:50%;margin-left:8px;vertical-align:middle}
  .an-status.ok{background:#4a9e7d}.an-status.off{background:#c4626a}
  .an-tabs{display:flex;border-bottom:1px solid rgba(0,200,255,0.1)}
  .an-tab{flex:1;padding:8px 6px;font-size:8px;letter-spacing:1px;text-transform:uppercase;text-align:center;
    color:rgba(224,220,212,0.45);cursor:pointer;border-bottom:2px solid transparent;transition:all .2s;background:none;border-top:none;border-left:none;border-right:none}
  .an-tab:hover{color:rgba(224,220,212,0.7)}
  .an-tab.active{color:rgba(0,200,255,0.95);border-bottom-color:rgba(0,200,255,0.6)}
  .an-body{flex:1;overflow-y:auto;padding:12px}
  .an-chart-wrap{position:relative;width:100%;min-height:220px}
  .an-chart-wrap canvas{width:100%!important;max-height:280px}
  .an-filter{margin-bottom:10px}
  .an-filter select{width:100%;padding:4px 6px;background:rgba(8,8,24,0.8);color:rgba(224,220,212,0.72);
    border:1px solid rgba(0,200,255,0.12);border-radius:3px;font-family:'JetBrains Mono',monospace;font-size:9px}
  .an-export{display:flex;justify-content:flex-end;margin-top:8px}
  .an-export-btn{background:rgba(0,200,255,0.08);border:1px solid rgba(0,200,255,0.2);color:rgba(0,200,255,0.7);
    font-family:'JetBrains Mono',monospace;font-size:8px;letter-spacing:1px;padding:4px 10px;cursor:pointer;border-radius:3px;transition:all .2s}
  .an-export-btn:hover{background:rgba(0,200,255,0.15);color:#00c8ff}
  .an-toast{position:fixed;bottom:20px;right:20px;background:rgba(0,200,255,0.15);border:1px solid rgba(0,200,255,0.3);
    color:rgba(0,200,255,0.9);font-family:'JetBrains Mono',monospace;font-size:9px;padding:8px 14px;border-radius:4px;
    opacity:0;transition:opacity .3s;pointer-events:none;z-index:200}
  .an-toast.show{opacity:1}
  .an-empty{font-size:9px;color:rgba(224,220,212,0.36);text-align:center;padding:40px 12px}
  #btnAnalytics{margin-top:4px}

  /* ═══ Session Timeline ═══ */
  #session-timeline{max-height:120px;overflow-y:auto}
  .st-row{display:flex;align-items:center;gap:6px;padding:3px 0;font-size:8.5px}
  .st-dot{width:5px;height:5px;border-radius:50%;flex-shrink:0}
  .st-dot.alive{background:#4a9e7d;box-shadow:0 0 4px rgba(74,158,125,0.4)}
  .st-dot.stale{background:#ffab40}.st-dot.dead{background:#c4626a}
  .st-id{color:rgba(224,220,212,0.5);width:90px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
  .st-age{color:rgba(224,220,212,0.36);margin-left:auto;white-space:nowrap}
  .st-bar{display:flex;gap:1px;height:8px;margin-top:6px;border-radius:2px;overflow:hidden}
  .st-bar-seg{min-width:2px;transition:flex .4s}
</style>
</head>
<body>
<div id="app">
  <div id="scene">
    <canvas id="c" aria-label="3D visualization of Strategic Directives"></canvas>
    <div class="vi"></div>
    <div class="ov ti"><h1>LEO Visual Playground</h1><h2 id="subtitle">connecting…</h2></div>
    <div class="ov stt">
      <div class="sr"><span class="sl">Total</span><span class="svl" id="st-total">0</span></div>
      <div class="sr"><span class="sl">Active</span><span class="svl" id="st-active">0</span></div>
      <div class="sr"><span class="sl">Completed</span><span class="svl" id="st-done">0</span></div>
    </div>
    <div class="ov phi">
      <div class="phi-shape" id="sdTitle">—</div>
      <div class="phi-key" id="sdKey"></div>
      <div class="phi-bar" id="dotBar"></div>
      <div class="phi-labels" id="lblBar"></div>
    </div>
    <div class="ov conn"><span class="conn-dot err" id="connDot"></span><span class="conn-text" id="connText">Offline</span></div>
    <div class="cb">
      <button class="bt ac" id="btnPlay" onclick="setSlide('play')">Play</button>
      <button class="bt" id="btnPause" onclick="setSlide('pause')">Pause</button>
      <button class="bt" id="btnNext" onclick="setSlide('next')">Next</button>
      <div class="dvd"></div>
      <button class="bt" id="btnFast" onclick="setSlide('fast')">Fast</button>
      <div class="dvd"></div>
      <button class="bt" id="btnAnalytics" onclick="toggleAnalytics()">Charts</button>
    </div>
    <div id="slideProg"></div>
    <div id="dup-alert"><button id="dup-alert-close" onclick="dismissDupAlert()">&times;</button><div id="dup-alert-title">CLAIM CONFLICT DETECTED</div><div id="dup-alert-msg">Multiple sessions have claimed the same SD. This can cause conflicts.</div><ul id="dup-alert-list"></ul><div id="dup-alert-countdown"></div></div>
    <div id="idle-alert"><button id="idle-alert-close" onclick="dismissIdleAlert()">&times;</button><div id="idle-alert-title">ALL SESSIONS IDLE</div><div id="idle-alert-msg">No active sessions detected for 15+ minutes. LEO workflow may be stalled.</div><div id="idle-alert-duration"></div></div>
    <div id="diag-card"><button id="diag-card-close" onclick="closeDiagCard()">&times;</button><div class="dc-title" id="dc-title"></div><div class="dc-key" id="dc-key"></div><div id="dc-body"></div></div>
    <div id="no-data">No Strategic Directives found.<br>SDs will appear here in real-time.</div>
    <div id="fallback"><table><thead><tr><th>Key</th><th>Title</th><th>Type</th><th>Status</th><th>Priority</th><th>Progress</th></tr></thead><tbody id="fb-body"></tbody></table></div>
  </div>
  <div id="panel">
    <div class="sr-only" id="sr-summary" aria-live="polite" role="status"></div>
    <div class="p-section" id="activity"><div class="p-header">Activity</div><div id="logList"></div></div>
    <div class="p-section" id="session-timeline-section">
      <div class="p-header" style="cursor:pointer" onclick="document.getElementById('session-timeline').style.display=document.getElementById('session-timeline').style.display==='none'?'':'none'">Sessions ▾</div>
      <div id="session-timeline">
        <div class="st-bar" id="st-bar"></div>
        <div id="st-list"></div>
      </div>
    </div>
    <div id="filter-row" style="display:flex;gap:6px;flex-wrap:wrap">
      <select id="filterSel" style="flex:1;min-width:100px">
        <option value="active" selected>Active (draft, review, in-progress)</option>
        <option value="not-done">Not Done</option>
        <option value="draft">Drafts</option>
        <option value="review">Review</option>
        <option value="completed">Completed</option>
        <option value="cancelled">Cancelled</option>
        <option value="all">All</option>
      </select>
      <select id="typeSel" style="flex:1;min-width:100px">
        <option value="all" selected>All Types</option>
        <option value="feature">Feature</option>
        <option value="bugfix">Bugfix</option>
        <option value="enhancement">Enhancement</option>
        <option value="infrastructure">Infrastructure</option>
        <option value="documentation">Documentation</option>
        <option value="database">Database</option>
        <option value="refactor">Refactor</option>
      </select>
    </div>
    <div class="p-section" style="padding:0;flex:1;overflow:hidden;display:flex;flex-direction:column">
      <div class="p-header" style="padding:10px 12px 8px" id="queueHeader">Queue · 0 <a class="q-toggle" id="historyToggle" onclick="toggleHistory()">History</a></div>
      <div id="queue"></div>
      <div id="history-panel">
        <div class="h-filters">
          <select id="histVenture" onchange="loadHistory()"><option value="">All Ventures</option></select>
          <select id="histPeriod" onchange="loadHistory()">
            <option value="7">7 days</option>
            <option value="30" selected>30 days</option>
            <option value="90">90 days</option>
            <option value="all">All time</option>
          </select>
        </div>
        <div id="histList"></div>
      </div>
    </div>
    <div id="estimate">
      <div class="p-header">Estimated Remaining</div>
      <div id="est-dur">--</div>
      <div id="est-detail"></div>
      <div id="est-conf"></div>
    </div>
  </div>
  <div id="analytics" role="complementary" aria-label="Analytics charts panel">
    <div class="an-header">
      <span class="an-title">Analytics<span class="an-status off" id="anConnDot" title="Subscription status"></span></span>
      <button class="an-close" onclick="toggleAnalytics()" aria-label="Close analytics">&times;</button>
    </div>
    <div class="an-tabs" role="tablist">
      <button class="an-tab active" role="tab" data-tab="burndown" onclick="switchAnalyticsTab('burndown')">Burndown</button>
      <button class="an-tab" role="tab" data-tab="gates" onclick="switchAnalyticsTab('gates')">Gate Failures</button>
      <button class="an-tab" role="tab" data-tab="phases" onclick="switchAnalyticsTab('phases')">Time-in-Phase</button>
      <button class="an-tab" role="tab" data-tab="blocking" onclick="switchAnalyticsTab('blocking')">Blocking</button>
      <button class="an-tab" role="tab" data-tab="sankey" onclick="switchAnalyticsTab('sankey')">Inbox Flow</button>
    </div>
    <div class="an-body">
      <div id="an-burndown">
        <div class="an-filter"><select id="anAppFilter" onchange="loadBurndownData()"><option value="">All Applications</option></select></div>
        <div class="an-chart-wrap"><canvas id="burndownCanvas"></canvas></div>
      </div>
      <div id="an-gates" style="display:none">
        <div class="an-chart-wrap"><canvas id="gatesCanvas"></canvas></div>
      </div>
      <div id="an-phases" style="display:none">
        <div class="an-chart-wrap"><canvas id="phasesCanvas"></canvas></div>
      </div>
      <div id="an-blocking" style="display:none">
        <div class="an-chart-wrap"><canvas id="blockingCanvas"></canvas></div>
      </div>
      <div id="an-sankey" style="display:none">
        <div class="an-chart-wrap"><canvas id="sankeyCanvas" style="min-height:280px"></canvas></div>
      </div>
      <div class="an-export"><button class="an-export-btn" onclick="exportChartPNG()">Export PNG</button></div>
    </div>
  </div>
  <div class="an-toast" id="anToast"></div>
</div>

<script src="playground.config.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4/dist/chart.umd.min.js"></script>
<script type="importmap">
{ "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/" } }
</script>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// ═══════════════════════════════════════════════
// CONFIG
// ═══════════════════════════════════════════════
const _params = new URLSearchParams(window.location.search);
const _pc = window.__PLAYGROUND_CONFIG || {};
const CONFIG = {
  SUPABASE_URL: _params.get('sb_url') || _pc.SUPABASE_URL || '',
  SUPABASE_KEY: _params.get('sb_key') || _pc.SUPABASE_KEY || '',
  RECONNECT_MAX: 5,
  RECONNECT_BASE_MS: 1000,
  POLL_INTERVAL_MS: 60000,
  MAX_SDS: 500,
  DEFAULT_FILTER: 'active',
  SLIDE_DURATION: 24,
};

// ═══════════════════════════════════════════════
// SHAPE DEFINITIONS (SD type → geometry)
// ═══════════════════════════════════════════════
const SHAPE_DEFS = {
  infrastructure: { name:'Torus Knot',   makeLo:()=>new THREE.TorusKnotGeometry(3,0.9,32,6), makeHi:()=>new THREE.TorusKnotGeometry(3,0.9,100,20), color:new THREE.Color(0xffcc66) },
  feature:        { name:'Icosahedron',  makeLo:()=>new THREE.IcosahedronGeometry(4,1),      makeHi:()=>new THREE.IcosahedronGeometry(4,3),     color:new THREE.Color(0x40efff) },
  documentation:  { name:'Dodecahedron', makeLo:()=>new THREE.DodecahedronGeometry(4,1),     makeHi:()=>new THREE.DodecahedronGeometry(4,3),    color:new THREE.Color(0xf0a0ff) },
  bugfix:         { name:'Octahedron',   makeLo:()=>new THREE.OctahedronGeometry(4.5,1),     makeHi:()=>new THREE.OctahedronGeometry(4.5,3),    color:new THREE.Color(0xff8a90) },
  fix:            { name:'Octahedron',   makeLo:()=>new THREE.OctahedronGeometry(4.5,1),     makeHi:()=>new THREE.OctahedronGeometry(4.5,3),    color:new THREE.Color(0xff8a90) },
  database:       { name:'Box',          makeLo:()=>new THREE.BoxGeometry(5,5,5,2,2,2),      makeHi:()=>new THREE.BoxGeometry(5,5,5,6,6,6),     color:new THREE.Color(0x66d9ff) },
  enhancement:    { name:'Torus',        makeLo:()=>new THREE.TorusGeometry(3.5,1.2,8,16),   makeHi:()=>new THREE.TorusGeometry(3.5,1.2,24,48), color:new THREE.Color(0x90ffcc) },
  docs:           { name:'Sphere',       makeLo:()=>new THREE.SphereGeometry(4,10,8),        makeHi:()=>new THREE.SphereGeometry(4,32,24),      color:new THREE.Color(0xd0a8ff) },
  implementation: { name:'Sphere',       makeLo:()=>new THREE.SphereGeometry(4,10,8),        makeHi:()=>new THREE.SphereGeometry(4,32,24),      color:new THREE.Color(0xb0efea) },
  discovery_spike:{ name:'Sphere',       makeLo:()=>new THREE.SphereGeometry(4,10,8),        makeHi:()=>new THREE.SphereGeometry(4,32,24),      color:new THREE.Color(0xffe070) },
  refactor:       { name:'Sphere',       makeLo:()=>new THREE.SphereGeometry(4,10,8),        makeHi:()=>new THREE.SphereGeometry(4,32,24),      color:new THREE.Color(0x80f0f0) },
  unknown:        { name:'Sphere',       makeLo:()=>new THREE.SphereGeometry(4,10,8),        makeHi:()=>new THREE.SphereGeometry(4,32,24),      color:new THREE.Color(0x60e8cc) },
};

// Procedural ShaderMaterial patterns for sphere-sharing types (WCAG differentiation)
const SPHERE_PATTERNS = {
  docs: { label:'Rings', fragBody:`float ring = step(0.45, abs(fract(vUv.y * 6.0) - 0.5)); gl_FragColor = vec4(baseColor * (0.6 + ring * 0.4), alpha);` },
  implementation: { label:'Dots', fragBody:`float d = length(fract(vUv * 5.0) - 0.5); float dot = 1.0 - smoothstep(0.15, 0.2, d); gl_FragColor = vec4(baseColor * (0.6 + dot * 0.4), alpha);` },
  discovery_spike: { label:'Diagonal', fragBody:`float diag = step(0.45, abs(fract((vUv.x + vUv.y) * 5.0) - 0.5)); gl_FragColor = vec4(baseColor * (0.6 + diag * 0.4), alpha);` },
  refactor: { label:'Checker', fragBody:`float ch = step(0.5, fract(vUv.x * 4.0)) * step(0.5, fract(vUv.y * 4.0)) + (1.0 - step(0.5, fract(vUv.x * 4.0))) * (1.0 - step(0.5, fract(vUv.y * 4.0))); gl_FragColor = vec4(baseColor * (0.55 + ch * 0.45), alpha);` },
  unknown: { label:'Noise', fragBody:`float n = fract(sin(dot(vUv, vec2(12.9898,78.233))) * 43758.5453); gl_FragColor = vec4(baseColor * (0.65 + n * 0.35), alpha);` },
};

function makePatternMaterial(sdType, color) {
  const pat = SPHERE_PATTERNS[sdType];
  if (!pat) return null;
  return new THREE.ShaderMaterial({
    transparent: true,
    uniforms: { baseColor: { value: new THREE.Vector3(color.r, color.g, color.b) }, alpha: { value: 0.0 } },
    vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
    fragmentShader: `uniform vec3 baseColor; uniform float alpha; varying vec2 vUv; void main() { ${pat.fragBody} }`,
  });
}

// FNV-1a hash for stable per-SD shape selection
function hashString(str) {
  let h = 0x811c9dc5;
  for (let i = 0; i < str.length; i++) { h ^= str.charCodeAt(i); h = Math.imul(h, 0x01000193); }
  return h >>> 0;
}
const GEOMETRY_POOL = [
  { makeLo:()=>new THREE.TorusKnotGeometry(3,0.9,32,6), makeHi:()=>new THREE.TorusKnotGeometry(3,0.9,100,20) },
  { makeLo:()=>new THREE.IcosahedronGeometry(4,1), makeHi:()=>new THREE.IcosahedronGeometry(4,3) },
  { makeLo:()=>new THREE.DodecahedronGeometry(4,1), makeHi:()=>new THREE.DodecahedronGeometry(4,3) },
  { makeLo:()=>new THREE.OctahedronGeometry(4.5,1), makeHi:()=>new THREE.OctahedronGeometry(4.5,3) },
  { makeLo:()=>new THREE.BoxGeometry(5,5,5,2,2,2), makeHi:()=>new THREE.BoxGeometry(5,5,5,6,6,6) },
  { makeLo:()=>new THREE.TorusGeometry(3.5,1.2,8,16), makeHi:()=>new THREE.TorusGeometry(3.5,1.2,24,48) },
  { makeLo:()=>new THREE.SphereGeometry(4,10,8), makeHi:()=>new THREE.SphereGeometry(4,32,24) },
];
function getShapeForSD(sd) {
  const typeDef = SHAPE_DEFS[sd.sd_type] || SHAPE_DEFS.unknown;
  const poolIdx = hashString(sd.id || sd.sd_key || '') % GEOMETRY_POOL.length;
  const geo = GEOMETRY_POOL[poolIdx];
  return { makeLo: geo.makeLo, makeHi: geo.makeHi, color: typeDef.color, name: typeDef.name };
}

const STATUS_COLORS = { draft:'#78909C', review:'#42A5F5', in_progress:'#FFA726', completed:'#66BB6A', blocked:'#EF5350', cancelled:'#808080' };
const PHASE_NAMES = ['Draft','Lead','Plan','Execute'];
const PHASE_DUR = [0.08, 0.12, 0.12, 0.68];

// Map LEO workflow phase + progress to forge animation target (0..1)
// 4 phases: Draft(0–0.08) Lead(0.08–0.20) Plan(0.20–0.32) Execute(0.32–1.0)
function computeForgeTarget(sd) {
  const status = sd.status || 'draft';
  const phase = (sd.current_phase || '').toUpperCase();
  const pct = (sd.progress_percentage ?? sd.progress ?? 0) / 100;

  if (status === 'completed') return 1.0;
  if (status === 'cancelled') return 0.04;

  // Draft phase: 0.0 → 0.08
  if (status === 'draft' && !phase) return 0.04;

  // LEAD phases: 0.08 → 0.20
  if (phase.startsWith('LEAD')) return 0.08 + pct * 0.12;

  // PLAN/PRD phases: 0.20 → 0.32
  if (phase.startsWith('PLAN') || phase.startsWith('PRD')) return 0.20 + pct * 0.12;

  // EXEC/IMPLEMENTATION phases: 0.32 → 1.0 (the big Execute fill)
  if (phase.startsWith('EXEC') || phase.startsWith('IMPL')) return 0.32 + pct * 0.68;

  // Fallback by status if phase is missing/unknown
  if (status === 'draft') return 0.04;
  if (status === 'review') return 0.20;
  if (status === 'in_progress') return 0.32 + pct * 0.68;
  if (status === 'blocked') return 0.32 + pct * 0.68;

  return 0.04;
}

// Floor = start of the current phase (prior phases shown as already complete)
function computeForgeFloor(sd) {
  const status = sd.status || 'draft';
  const phase = (sd.current_phase || '').toUpperCase();

  if (status === 'completed') return 0.32;
  if (status === 'cancelled') return 0;

  if (phase.startsWith('EXEC') || phase.startsWith('IMPL')) return 0.32;
  if (phase.startsWith('PLAN') || phase.startsWith('PRD')) return 0.20;
  if (phase.startsWith('LEAD')) return 0.08;

  if (status === 'in_progress') return 0.32;
  if (status === 'review') return 0.20;
  if (status === 'blocked') return 0.32;

  return 0;
}

// ═══════════════════════════════════════════════
// STATE
// ═══════════════════════════════════════════════
const state = {
  sds: new Map(), filter: CONFIG.DEFAULT_FILTER, typeFilter: 'all', channel: null,
  reconnectAttempts: 0, supabase: null, webglOk: true,
  slideQueue: [], slideIndex: 0, slidePaused: false, slideSpeed: 1,
  slideElapsed: 0, currentSDId: null, claimedIds: new Set(),
  liveSessions: 0, burnRate: { avgHours: null, confidence: 'default', sampleSize: 0 },
  animationFrameId: null, intervalIds: [],
  slideDurations: new Map(), sessionOrbs: [],
};

const TYPE_BASELINES_MIN = {
  infrastructure: 50, orchestrator: 155, documentation: 20, bugfix: 35,
  database: 100, feature: 145, refactor: 80, qa: 75, security: 120, default: 60
};

// ═══════════════════════════════════════════════
// THREE.JS SETUP
// ═══════════════════════════════════════════════
const cnv = document.getElementById('c');
let renderer, scene, camera, controls;
const clock = new THREE.Clock();
let shapeGroup, ghostMesh, wireMesh, facetedFillMesh, smoothMesh, outerGlow;
let faceColors, faceFillOrder, totalFaces, filledFaces, facetedNormals, smoothNormals;
const retiredShapes = [], sparks = [], orbitShapes = [];
let outgoingGroup = null, outgoingFade = 0;
let dustGeo, dustPos, dustVel;
const DUST_COUNT = 300;
let coreLight, rimLight, warmLight, groundMat;
let shapeProg = 0, slidePhase = 'animate', prevPh = -1, frame = 0, cameraBaseDistance = 18;

function initThree() {
  if (!(() => { try { const c = document.createElement('canvas'); return !!(window.WebGLRenderingContext && (c.getContext('webgl') || c.getContext('experimental-webgl'))); } catch { return false; } })()) {
    state.webglOk = false; cnv.style.display = 'none';
    document.getElementById('fallback').style.display = 'block'; return;
  }
  const W = cnv.parentElement.clientWidth, H = cnv.parentElement.clientHeight;
  renderer = new THREE.WebGLRenderer({ canvas: cnv, antialias: true });
  renderer.setSize(W, H); renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 0.85;

  scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x040410, 0.008);
  camera = new THREE.PerspectiveCamera(40, W / H, 0.1, 300);
  camera.position.set(0, 2, 18);

  controls = new OrbitControls(camera, cnv);
  controls.enableDamping = true; controls.dampingFactor = 0.05;
  controls.autoRotate = true; controls.autoRotateSpeed = 0.2;
  controls.maxDistance = 60; controls.minDistance = 8;
  let iTimer;
  cameraBaseDistance = camera.position.distanceTo(controls.target);
  const onInteract = () => { controls.autoRotate = false; clearTimeout(iTimer); iTimer = setTimeout(() => { controls.autoRotate = true; cameraBaseDistance = camera.position.distanceTo(controls.target); }, 5000); };
  cnv.addEventListener('pointerdown', onInteract); cnv.addEventListener('wheel', onInteract);

  // Lighting
  scene.add(new THREE.AmbientLight(0x101028, 0.6));
  const dirL = new THREE.DirectionalLight(0x334466, 0.5); dirL.position.set(10, 20, -10); scene.add(dirL);
  coreLight = new THREE.PointLight(0x00c8ff, 0, 50); scene.add(coreLight);
  rimLight = new THREE.PointLight(0xb388ff, 0, 40); rimLight.position.set(-8, 5, 8); scene.add(rimLight);
  warmLight = new THREE.PointLight(0x00bfa5, 0, 35); warmLight.position.set(5, -3, -5); scene.add(warmLight);

  // Ground + grid
  groundMat = new THREE.MeshStandardMaterial({ color: 0x0a0a1a, roughness: 0.95, metalness: 0.05 });
  const gr = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), groundMat);
  gr.rotation.x = -Math.PI / 2; gr.position.y = -6; scene.add(gr);
  const grid = new THREE.GridHelper(40, 40, 0x141428, 0x101020); grid.position.y = -6; scene.add(grid);

  // Dust
  dustGeo = new THREE.BufferGeometry();
  dustPos = new Float32Array(DUST_COUNT * 3); dustVel = new Float32Array(DUST_COUNT * 3);
  for (let i = 0; i < DUST_COUNT; i++) {
    dustPos[i*3]=(Math.random()-.5)*40; dustPos[i*3+1]=(Math.random()-.5)*30; dustPos[i*3+2]=(Math.random()-.5)*40;
    dustVel[i*3]=(Math.random()-.5)*.0012; dustVel[i*3+1]=(Math.random()-.5)*.0008; dustVel[i*3+2]=(Math.random()-.5)*.0012;
  }
  dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPos, 3));
  scene.add(new THREE.Points(dustGeo, new THREE.PointsMaterial({ color:0x00c8ff, size:.03, transparent:true, opacity:.28, blending:THREE.AdditiveBlending })));

  shapeGroup = new THREE.Group(); scene.add(shapeGroup);

  new ResizeObserver(() => {
    const w = cnv.parentElement.clientWidth, h = cnv.parentElement.clientHeight;
    camera.aspect = w / h; camera.updateProjectionMatrix(); renderer.setSize(w, h);
  }).observe(cnv.parentElement);
}

// ═══════════════════════════════════════════════
// FORGE: SHAPE BUILDING
// ═══════════════════════════════════════════════
function computeFlatNormals(geo) {
  const pos = geo.attributes.position.array, normals = new Float32Array(pos.length);
  const vA = new THREE.Vector3(), vB = new THREE.Vector3(), vC = new THREE.Vector3();
  const cb = new THREE.Vector3(), ab = new THREE.Vector3();
  for (let i = 0; i < pos.length; i += 9) {
    vA.set(pos[i],pos[i+1],pos[i+2]); vB.set(pos[i+3],pos[i+4],pos[i+5]); vC.set(pos[i+6],pos[i+7],pos[i+8]);
    cb.subVectors(vC, vB); ab.subVectors(vA, vB); cb.cross(ab).normalize();
    for (let v = 0; v < 3; v++) { normals[i+v*3]=cb.x; normals[i+v*3+1]=cb.y; normals[i+v*3+2]=cb.z; }
  }
  geo.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
}

function buildShape(sd) {
  while (shapeGroup.children.length) {
    const child = shapeGroup.children[0];
    shapeGroup.remove(child);
    if (child.geometry) child.geometry.dispose();
    if (child.material) child.material.dispose();
  }
  const def = getShapeForSD(sd);
  const isBlocked = sd.status === 'blocked';
  const col = isBlocked ? new THREE.Color(0xc4626a) : def.color.clone();

  const loGeo = def.makeLo();
  const loNonIdx = loGeo.index ? loGeo.toNonIndexed() : loGeo.clone();
  loNonIdx.computeVertexNormals();
  const loFlat = loNonIdx.clone(); computeFlatNormals(loFlat);
  totalFaces = loFlat.attributes.position.count / 3;

  const hiGeo = def.makeHi();
  const hiNonIdx = hiGeo.index ? hiGeo.toNonIndexed() : hiGeo.clone();
  hiNonIdx.computeVertexNormals();

  // Ghost
  ghostMesh = new THREE.Mesh(loFlat.clone(), new THREE.MeshBasicMaterial({ color:col.clone(), transparent:true, opacity:0, blending:THREE.AdditiveBlending, depthWrite:false }));
  shapeGroup.add(ghostMesh);

  // Wireframe
  wireMesh = new THREE.LineSegments(new THREE.WireframeGeometry(loFlat), new THREE.LineBasicMaterial({ color:col.clone(), transparent:true, opacity:0, blending:THREE.AdditiveBlending }));
  shapeGroup.add(wireMesh);

  // Faceted fill
  const fillGeo = loFlat.clone();
  const colors = new Float32Array(fillGeo.attributes.position.count * 3);
  fillGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  faceColors = colors;
  facetedFillMesh = new THREE.Mesh(fillGeo, new THREE.MeshStandardMaterial({ vertexColors:true, transparent:true, opacity:0, roughness:0.5, metalness:0.1, flatShading:true, emissive:0x000000, emissiveIntensity:0, side:THREE.DoubleSide }));
  shapeGroup.add(facetedFillMesh);

  facetedNormals = fillGeo.attributes.normal.array.slice();
  const smNormGeo = loFlat.clone(); smNormGeo.computeVertexNormals();
  smoothNormals = smNormGeo.attributes.normal.array.slice();

  // Smooth mesh
  smoothMesh = new THREE.Mesh(hiNonIdx, new THREE.MeshStandardMaterial({ color:col.clone(), transparent:true, opacity:0, roughness:0.2, metalness:0.25, emissive:col.clone(), emissiveIntensity:0, side:THREE.DoubleSide }));
  shapeGroup.add(smoothMesh);

  // Outer glow
  const glowGeo = hiNonIdx.clone();
  const gp = glowGeo.attributes.position.array, gn = hiNonIdx.attributes.normal.array;
  for (let i = 0; i < gp.length; i += 3) { gp[i]+=gn[i]*0.18; gp[i+1]+=gn[i+1]*0.18; gp[i+2]+=gn[i+2]*0.18; }
  outerGlow = new THREE.Mesh(glowGeo, new THREE.MeshBasicMaterial({ color:col.clone(), transparent:true, opacity:0, blending:THREE.AdditiveBlending, side:THREE.DoubleSide, depthWrite:false }));
  shapeGroup.add(outerGlow);

  // Dispose intermediate geometries no longer needed
  // Note: hiNonIdx is used by smoothMesh, glowGeo by outerGlow — keep those
  loGeo.dispose(); loNonIdx.dispose(); loFlat.dispose();
  hiGeo.dispose(); smNormGeo.dispose();

  // Face fill order
  faceFillOrder = []; for (let i = 0; i < totalFaces; i++) faceFillOrder.push(i);
  for (let i = faceFillOrder.length - 1; i > 0; i--) { const j = Math.floor(Math.random()*(i+1)); [faceFillOrder[i],faceFillOrder[j]]=[faceFillOrder[j],faceFillOrder[i]]; }
  filledFaces = 0;
}

function emitSparks(pos, color, n = 8) {
  for (let i = 0; i < n; i++) {
    const m = new THREE.MeshBasicMaterial({ color, transparent:true, opacity:1, blending:THREE.AdditiveBlending });
    const s = new THREE.Mesh(new THREE.SphereGeometry(.025,4,4), m);
    s.position.copy(pos); scene.add(s);
    sparks.push({ mesh:s, vel:new THREE.Vector3((Math.random()-.5)*.15, Math.random()*.1+.03, (Math.random()-.5)*.15), life:1 });
  }
}

function retireShape(sd) {
  if (!sd) return;
  const def = getShapeForSD(sd);
  const mini = new THREE.Mesh(def.makeHi(), new THREE.MeshBasicMaterial({ color:def.color, transparent:true, opacity:0.14, blending:THREE.AdditiveBlending }));
  const ang = retiredShapes.length * 1.0 + 0.5, rad = 14 + retiredShapes.length * 1.8;
  mini.position.set(Math.sin(ang)*rad, (Math.random()-.5)*5, Math.cos(ang)*rad);
  mini.scale.set(.25,.25,.25); scene.add(mini);
  retiredShapes.push({ mesh:mini, rs:0.15+Math.random()*0.25 });
  if (retiredShapes.length > 20) { const old = retiredShapes.shift(); scene.remove(old.mesh); old.mesh.geometry.dispose(); old.mesh.material.dispose(); }
}

function buildOrbitShapes() {
  // Clear existing orbit shapes and their mesh→SD mappings
  orbitShapes.forEach(o => { meshToSD.delete(o.mesh); scene.remove(o.mesh); o.mesh.geometry.dispose(); o.mesh.material.dispose(); });
  orbitShapes.length = 0;

  // Get all filtered SDs that are NOT the currently forging one
  const pending = getFilteredSDs().filter(sd => sd.id !== state.currentSDId);
  const maxOrbiters = Math.min(pending.length, 30);

  for (let i = 0; i < maxOrbiters; i++) {
    const sd = pending[i];
    const def = getShapeForSD(sd);
    const mesh = new THREE.Mesh(
      def.makeLo(),
      new THREE.MeshBasicMaterial({ color: def.color.clone(), transparent: true, opacity: 0.35, blending: THREE.AdditiveBlending, depthWrite: false })
    );

    // Distribute in a spherical shell around center
    const golden = 2.399963; // golden angle in radians
    const theta = golden * i;
    const y = 1 - (2 * i / (maxOrbiters - 1 || 1)); // -1 to 1
    const radiusAtY = Math.sqrt(1 - y * y);
    const orbitRadius = 16 + Math.random() * 10;
    mesh.position.set(
      Math.cos(theta) * radiusAtY * orbitRadius,
      y * 8 + (Math.random() - 0.5) * 3,
      Math.sin(theta) * radiusAtY * orbitRadius
    );

    const sc = 0.28 + Math.random() * 0.14;
    mesh.scale.set(sc, sc, sc);
    scene.add(mesh);

    meshToSD.set(mesh, sd.id);
    orbitShapes.push({
      mesh,
      orbitRadius,
      angle: theta,
      yBase: mesh.position.y,
      spinSpeed: 0.08 + Math.random() * 0.12,
      orbitSpeed: 0.01 + Math.random() * 0.015,
      bobSpeed: 0.15 + Math.random() * 0.2,
      bobAmp: 0.3 + Math.random() * 0.5,
    });
  }
}

function buildSessionOrbs() {
  state.sessionOrbs.forEach(o => { scene.remove(o.mesh); o.mesh.geometry.dispose(); o.mesh.material.dispose(); });
  state.sessionOrbs.length = 0;
  for (let i = 0; i < state.liveSessions; i++) {
    const mesh = new THREE.Mesh(
      new THREE.SphereGeometry(0.6, 12, 8),
      new THREE.MeshBasicMaterial({ color: 0xffab40, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending, depthWrite: false })
    );
    const angle = (i / Math.max(state.liveSessions, 1)) * Math.PI * 2;
    const radius = 6 + i * 1.5;
    mesh.position.set(Math.cos(angle) * radius, 8 + Math.random() * 4, Math.sin(angle) * radius);
    scene.add(mesh);
    state.sessionOrbs.push({
      mesh, angle, radius, yBase: mesh.position.y,
      orbitSpeed: 0.03 + Math.random() * 0.02,
      bobSpeed: 0.3 + Math.random() * 0.2,
      bobAmp: 0.5 + Math.random() * 0.3,
      pulseSpeed: 1.5 + Math.random() * 0.5,
    });
  }
}

// ═══════════════════════════════════════════════
// FORGE PHASE SYSTEM
// ═══════════════════════════════════════════════
function getPhase(p) {
  let acc = 0;
  for (let i = 0; i < 4; i++) { acc += PHASE_DUR[i]; if (p <= acc) return { ph:i, loc:(p-(acc-PHASE_DUR[i]))/PHASE_DUR[i] }; }
  return { ph:3, loc:1 };
}
function pulse(t, r=1) { return Math.pow(Math.sin(t*r*Math.PI)*.5+.5, 4); }

function updateForge(t, dt) {
  if (!state.currentSDId || !shapeGroup.children.length) return;
  const sd = state.sds.get(state.currentSDId);
  if (!sd) return;

  const isBlocked = sd.status === 'blocked';
  const col = isBlocked ? new THREE.Color(0xc4626a) : (SHAPE_DEFS[sd.sd_type] || SHAPE_DEFS.unknown).color.clone();
  const floor = computeForgeFloor(sd);
  const target = computeForgeTarget(sd);

  if (!state.slidePaused) state.slideElapsed += dt * state.slideSpeed;

  const slideDur = state.slideDurations.get(state.currentSDId) || CONFIG.SLIDE_DURATION;
  const ANIM_END = slideDur * 0.5;
  const HOLD_END = slideDur * 0.65;
  const TOTAL = slideDur;

  if (state.slideElapsed < ANIM_END) {
    slidePhase = 'animate'; shapeProg = floor + (target - floor) * (state.slideElapsed / ANIM_END);
  } else if (state.slideElapsed < HOLD_END) {
    slidePhase = 'hold'; shapeProg = target;
  } else if (state.slideElapsed < TOTAL) {
    slidePhase = 'fade'; shapeProg = target;
  } else { advanceSlide(); return; }

  // Progress bar
  document.getElementById('slideProg').style.width = (state.slideElapsed / TOTAL * 100) + '%';

  const { ph, loc } = getPhase(shapeProg);
  const p = pulse(t, 0.7 + ph * 0.15);

  if (ph !== prevPh) {
    prevPh = ph;
    if (ph === 0) filledFaces = 0;
    const msgs = ['Draft — sensing the form…','Lead — projecting strategy…','Plan — locking specification…','Execute — forging implementation…'];
    if (ph <= 3) addLog(msgs[ph], 'phase');
  }

  let fadeMul = 1;
  if (slidePhase === 'fade') fadeMul = Math.max(0, 1 - (state.slideElapsed - HOLD_END) / (TOTAL - HOLD_END));

  updatePhaseBar(ph);

  // Phase 0: Ghost
  if (ghostMesh) {
    const gA = ph >= 0 ? Math.min(1, ph === 0 ? loc : 1) : 0;
    ghostMesh.material.opacity = gA * 0.12 * (1+p*0.5) * fadeMul;
    const gs = .85+gA*.15+Math.sin(t*.5)*.02; ghostMesh.scale.set(gs,gs,gs);
    // Fade ghost out in late Execute (polish sub-phase)
    if (ph === 3 && loc > 0.7) ghostMesh.material.opacity *= Math.max(0, 1-(loc-0.7)/0.3);
  }

  // Phase 1: Wireframe
  if (wireMesh) {
    let wo = 0;
    if (ph===1) wo=loc*0.22; else if (ph===2) wo=0.22+loc*0.58;
    else if (ph===3) {
      // Wireframe fades during Execute: visible early, fades by mid-Execute
      if (loc < 0.5) wo=0.8*(1-loc*1.2); else wo=Math.max(0, 0.2*(1-loc));
    }
    wireMesh.material.opacity = wo*(1+p*0.2)*fadeMul;
  }

  // Phase 3: Execute — three sub-phases: fill faces (0-0.6), polish (0.6-0.85), glow (0.85-1.0)
  if (ph === 3 && faceColors && faceFillOrder) {
    const fillLoc = Math.min(loc / 0.6, 1); // 0→1 over first 60% of Execute
    const tgtFilled = Math.floor(fillLoc * totalFaces);
    while (filledFaces < tgtFilled && filledFaces < totalFaces) {
      const fi = faceFillOrder[filledFaces], vi = fi*3;
      for (let v=0; v<3; v++) { const ci=(vi+v)*3; faceColors[ci]=col.r; faceColors[ci+1]=col.g; faceColors[ci+2]=col.b; }
      filledFaces++;
      if (filledFaces%10===0 && facetedFillMesh) {
        const pos=facetedFillMesh.geometry.attributes.position.array, idx=fi*9;
        emitSparks(new THREE.Vector3((pos[idx]+pos[idx+3]+pos[idx+6])/3,(pos[idx+1]+pos[idx+4]+pos[idx+7])/3,(pos[idx+2]+pos[idx+5]+pos[idx+8])/3), isBlocked?0xc4626a:col, 3);
      }
    }
    if (facetedFillMesh) {
      facetedFillMesh.geometry.attributes.color.needsUpdate = true;
      facetedFillMesh.material.emissive.copy(col);
      if (isBlocked && slidePhase==='hold') facetedFillMesh.material.emissiveIntensity = 0.15+Math.sin(t*3)*0.15;

      if (loc < 0.6) {
        // Fill sub-phase: faces appearing
        facetedFillMesh.material.opacity = Math.min(1, fillLoc*2.5) * fadeMul;
        facetedFillMesh.material.emissiveIntensity = p*0.04;
      } else if (loc < 0.85) {
        // Polish sub-phase: faceted→smooth normals transition
        const sT = (loc - 0.6) / 0.25; // 0→1
        if (facetedNormals && smoothNormals) {
          const norms = facetedFillMesh.geometry.attributes.normal.array;
          for (let i=0; i<Math.min(norms.length,facetedNormals.length,smoothNormals.length); i++) norms[i]=facetedNormals[i]+(smoothNormals[i]-facetedNormals[i])*sT;
          facetedFillMesh.geometry.attributes.normal.needsUpdate = true;
        }
        facetedFillMesh.material.roughness = 0.5-sT*0.3; facetedFillMesh.material.metalness = 0.1+sT*0.15;
        facetedFillMesh.material.emissiveIntensity = sT*0.15+p*0.1;
        facetedFillMesh.material.opacity = (sT>0.5 ? 1-(sT-0.5)*2 : 1) * fadeMul;
        if (smoothMesh) { smoothMesh.material.opacity=Math.max(0,(sT-0.3)/0.7)*fadeMul; smoothMesh.material.emissiveIntensity=sT*0.2+p*0.12; smoothMesh.material.roughness=0.3-sT*0.15; }
        if (frame%25===0) { const ang=Math.random()*Math.PI*2,r=3+Math.random()*1.5; emitSparks(new THREE.Vector3(Math.cos(ang)*r,(Math.random()-.5)*4,Math.sin(ang)*r),0xffab40,4); }
      } else {
        // Glow sub-phase: final radiance
        const gT = (loc - 0.85) / 0.15; // 0→1
        facetedFillMesh.material.opacity = 0;
        if (smoothMesh) { smoothMesh.material.opacity=1*fadeMul; smoothMesh.material.emissiveIntensity=0.25+p*0.35; smoothMesh.material.roughness=0.12; smoothMesh.material.metalness=0.3; }
        if (outerGlow) { outerGlow.material.opacity=gT*0.2*(1+p*0.5)*fadeMul; const gs=1+gT*0.1+p*0.04; outerGlow.scale.set(gs,gs,gs); }
      }
    }
  } else if (ph < 3) {
    if (smoothMesh) smoothMesh.material.opacity = 0;
    if (outerGlow) outerGlow.material.opacity = 0;
  }

  // Lighting
  const li = ph===3 ? loc : ph*0.15;
  coreLight.intensity=li*2.5*(1+p*0.4)*fadeMul; coreLight.color.copy(col);
  rimLight.intensity=li*1*fadeMul; warmLight.intensity=li*0.7*fadeMul;

  shapeGroup.rotation.y = t*0.04; shapeGroup.rotation.x = Math.sin(t*0.028)*0.06;
}

// ═══════════════════════════════════════════════
// SLIDESHOW
// ═══════════════════════════════════════════════
function computeSlideDurations() {
  state.slideDurations.clear();
  if (state.slideQueue.length === 0) return;
  const TARGET_CYCLE = 300, MIN_SLIDE = 10, MAX_SLIDE = 40;
  let totalEffort = 0;
  const efforts = new Map();
  state.slideQueue.forEach(id => {
    const sd = state.sds.get(id);
    if (!sd) return;
    const base = TYPE_BASELINES_MIN[sd.sd_type] || TYPE_BASELINES_MIN.default;
    const pct = (sd.progress_percentage ?? sd.progress ?? 0) / 100;
    const remaining = base * (1 - pct);
    efforts.set(id, remaining);
    totalEffort += remaining;
  });
  if (totalEffort === 0) totalEffort = 1;
  efforts.forEach((effort, id) => {
    const proportion = effort / totalEffort;
    const dur = Math.max(MIN_SLIDE, Math.min(MAX_SLIDE, Math.round(TARGET_CYCLE * proportion)));
    state.slideDurations.set(id, dur);
  });
}

function rebuildSlideQueue() {
  state.slideQueue = getFilteredSDs().filter(sd => state.claimedIds.has(sd.id) || state.claimedIds.has(sd.sd_key)).map(sd => sd.id);
  if (state.slideIndex >= state.slideQueue.length) state.slideIndex = 0;
  computeSlideDurations();
  const claimCount = state.slideQueue.length;
  document.getElementById('subtitle').textContent = claimCount > 0
    ? `${state.sds.size} directives · ${claimCount} claimed`
    : `${state.sds.size} directives · none claimed`;
}

function crossfadeOut() {
  if (shapeGroup && shapeGroup.children.length > 0) {
    if (outgoingGroup) { scene.remove(outgoingGroup); disposeGroup(outgoingGroup); }
    outgoingGroup = shapeGroup;
    outgoingFade = 1;
    shapeGroup = new THREE.Group(); scene.add(shapeGroup);
  }
}

function advanceSlide() {
  crossfadeOut();
  if (state.slideQueue.length === 0) { state.currentSDId = null; document.getElementById('sdTitle').textContent = 'Awaiting claimed directives…'; document.getElementById('sdKey').textContent = ''; return; }
  state.slideIndex = (state.slideIndex + 1) % state.slideQueue.length;
  startSlide();
}

function startSlide() {
  if (state.slideQueue.length === 0) { state.currentSDId = null; return; }
  const id = state.slideQueue[state.slideIndex], sd = state.sds.get(id);
  if (!sd) { advanceSlide(); return; }
  state.currentSDId = id; state.slideElapsed = 0; shapeProg = 0; prevPh = -1; filledFaces = 0;
  buildShape(sd);
  const def = getShapeForSD(sd);
  document.getElementById('sdTitle').textContent = sd.title || def.name;
  document.getElementById('sdKey').textContent = sd.sd_key;
  addLog(`Forging ${sd.sd_key}`, 'system');
  updateQueueHighlight();
  buildOrbitShapes();
}

function disposeGroup(group) {
  group.traverse(child => {
    if (child.geometry) child.geometry.dispose();
    if (child.material) child.material.dispose();
  });
}

// ═══════════════════════════════════════════════
// CONTROLS
// ═══════════════════════════════════════════════
window.setSlide = function(mode) {
  document.querySelectorAll('.cb .bt').forEach(b => b.classList.remove('ac'));
  if (mode==='play') { state.slidePaused=false; state.slideSpeed=1; document.getElementById('btnPlay').classList.add('ac'); }
  else if (mode==='pause') { state.slidePaused=true; document.getElementById('btnPause').classList.add('ac'); }
  else if (mode==='fast') { state.slidePaused=false; state.slideSpeed=2.5; document.getElementById('btnFast').classList.add('ac'); }
  else if (mode==='next') { advanceSlide(); document.getElementById(state.slidePaused?'btnPause':(state.slideSpeed>1?'btnFast':'btnPlay')).classList.add('ac'); }
};

let claimRetryTimer = null, claimCountdownSec = 0;
window.dismissDupAlert = function() {
  document.getElementById('dup-alert').classList.remove('show');
  if (claimRetryTimer) { clearInterval(claimRetryTimer); claimRetryTimer = null; }
};

function startClaimCountdown() {
  if (claimRetryTimer) return; // already counting
  claimCountdownSec = 60;
  const cdEl = document.getElementById('dup-alert-countdown');
  cdEl.textContent = 'Rechecking in 60s…';
  claimRetryTimer = setInterval(() => {
    claimCountdownSec--;
    if (claimCountdownSec <= 0) {
      clearInterval(claimRetryTimer); claimRetryTimer = null;
      cdEl.textContent = 'Rechecking…';
      loadClaimedSDs(); // retry — will clear alert if resolved, or restart countdown if still conflicting
    } else {
      cdEl.textContent = `Rechecking in ${claimCountdownSec}s…`;
    }
  }, 1000);
}

// Emergency alert sound — 3 short warning beeps via Web Audio API
let audioCtx = null;
function playAlertSound() {
  try {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const beep = (startTime, freq) => {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'square';
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(0.15, startTime);
      gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.18);
      osc.connect(gain); gain.connect(audioCtx.destination);
      osc.start(startTime); osc.stop(startTime + 0.2);
    };
    const now = audioCtx.currentTime;
    beep(now, 880); beep(now + 0.25, 880); beep(now + 0.5, 660);
  } catch (e) { /* audio not available */ }
}

// ═══════════════════════════════════════════════
// IDLE SESSION MONITORING — yellow alert after 15min of no active sessions
// ═══════════════════════════════════════════════
let idleCheckTimer = null;
let lastActivitySeen = Date.now();
let idleDismissed = false;

window.dismissIdleAlert = function() {
  document.getElementById('idle-alert').classList.remove('show');
  idleDismissed = true;
  // Reset — will re-alert if still idle after another 15 minutes
  setTimeout(() => { idleDismissed = false; }, 15 * 60 * 1000);
};

function formatIdleDuration(ms) {
  const mins = Math.floor(ms / 60000);
  if (mins < 60) return mins + ' minute' + (mins !== 1 ? 's' : '');
  const hrs = Math.floor(mins / 60);
  const rem = mins % 60;
  return hrs + 'h ' + rem + 'm';
}

function checkIdleSessions() {
  if (!state.supabase) return;
  state.supabase.from('claude_sessions')
    .select('session_id, status, heartbeat_at')
    .in('status', ['active', 'idle'])
    .then(function(result) {
      const sessions = result.data || [];
      const now = Date.now();
      // A session is "active" if heartbeat is within 10 minutes
      const activeSessions = sessions.filter(function(s) {
        return (now - new Date(s.heartbeat_at).getTime()) < 600000;
      });

      if (activeSessions.length > 0) {
        // Activity detected — reset idle tracking
        lastActivitySeen = now;
        document.getElementById('idle-alert').classList.remove('show');
        return;
      }

      // No active sessions — check how long
      const idleMs = now - lastActivitySeen;
      const idleThreshold = 15 * 60 * 1000; // 15 minutes

      if (idleMs >= idleThreshold && !idleDismissed) {
        const durEl = document.getElementById('idle-alert-duration');
        durEl.textContent = 'Idle for ' + formatIdleDuration(idleMs);
        if (!document.getElementById('idle-alert').classList.contains('show')) {
          document.getElementById('idle-alert').classList.add('show');
        }
      }
    })
    .catch(function(err) { console.warn('Idle check failed:', err); });
}

function startIdleMonitoring() {
  if (idleCheckTimer) return;
  lastActivitySeen = Date.now();
  idleCheckTimer = setInterval(checkIdleSessions, 60000); // check every 60 seconds
}

// ═══════════════════════════════════════════════
// DIAGNOSTIC CARD — click-to-inspect
// ═══════════════════════════════════════════════
const meshToSD = new Map(); // Mesh → sd.id
const raycaster = new THREE.Raycaster();
const pointer = new THREE.Vector2();
let diagCardSDId = null;

window.closeDiagCard = function() {
  document.getElementById('diag-card').classList.remove('show');
  diagCardSDId = null;
};

function showDiagCard(sdId, screenX, screenY) {
  const sd = state.sds.get(sdId);
  if (!sd) return;
  diagCardSDId = sdId;
  const card = document.getElementById('diag-card');
  document.getElementById('dc-title').textContent = sd.title || sd.sd_key;
  document.getElementById('dc-key').textContent = sd.sd_key;

  const pct = sd.progress_percentage ?? sd.progress ?? 0;
  const statusColor = STATUS_COLORS[sd.status] || '#9E9E9E';
  let rows = `
    <div class="dc-row"><span class="dc-label">Status</span><span class="dc-value" style="color:${statusColor}">${sd.status}</span></div>
    <div class="dc-row"><span class="dc-label">Type</span><span class="dc-value">${sd.sd_type || 'unknown'}</span></div>
    <div class="dc-row"><span class="dc-label">Phase</span><span class="dc-value">${sd.current_phase || '—'}</span></div>
    <div class="dc-row"><span class="dc-label">Progress</span><span class="dc-value">${pct}%</span></div>
    <div class="dc-row"><span class="dc-label">Priority</span><span class="dc-value">${sd.priority || '—'}</span></div>
  `;
  document.getElementById('dc-body').innerHTML = rows + '<div class="dc-loading" id="dc-extra">Loading details…</div>';

  // Position card near click (clamp to viewport)
  const sceneRect = document.getElementById('scene').getBoundingClientRect();
  let left = screenX - sceneRect.left + 12;
  let top = screenY - sceneRect.top + 12;
  if (left + 300 > sceneRect.width) left = Math.max(8, left - 320);
  if (top + 200 > sceneRect.height) top = Math.max(8, top - 220);
  card.style.left = left + 'px';
  card.style.top = top + 'px';
  card.classList.add('show');

  // Lazy-load extra details from Supabase
  if (state.supabase) {
    state.supabase.from('strategic_directives_v2')
      .select('description, dependencies, target_application, created_at, updated_at')
      .eq('id', sdId).single()
      .then(({ data }) => {
        if (!data || diagCardSDId !== sdId) return;
        let extra = '';
        if (data.target_application) extra += `<div class="dc-row"><span class="dc-label">App</span><span class="dc-value">${data.target_application}</span></div>`;
        if (data.created_at) extra += `<div class="dc-row"><span class="dc-label">Created</span><span class="dc-value">${new Date(data.created_at).toLocaleDateString()}</span></div>`;
        if (data.description) extra += `<div class="dc-row"><span class="dc-label">Desc</span><span class="dc-value" title="${data.description}">${(data.description||'').slice(0,80)}${(data.description||'').length>80?'…':''}</span></div>`;
        const el = document.getElementById('dc-extra');
        if (el) el.outerHTML = extra || '';
      })
      .catch(() => { const el = document.getElementById('dc-extra'); if (el) el.outerHTML = ''; });
  } else {
    const el = document.getElementById('dc-extra'); if (el) el.outerHTML = '';
  }
}

// Raycaster on pointerup (not pointerdown, to avoid conflicting with OrbitControls drag)
let pointerDownPos = null;
cnv.addEventListener('pointerdown', (e) => { pointerDownPos = { x: e.clientX, y: e.clientY }; });
cnv.addEventListener('pointerup', (e) => {
  if (!pointerDownPos) return;
  // Only trigger if it wasn't a drag (< 5px movement)
  const dx = e.clientX - pointerDownPos.x, dy = e.clientY - pointerDownPos.y;
  if (Math.sqrt(dx*dx + dy*dy) > 5) return;

  const rect = cnv.getBoundingClientRect();
  pointer.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
  pointer.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(pointer, camera);

  // Check orbit shapes first, then main shape group
  const allMeshes = [];
  orbitShapes.forEach(o => allMeshes.push(o.mesh));
  shapeGroup.traverse(c => { if (c.isMesh) allMeshes.push(c); });

  const hits = raycaster.intersectObjects(allMeshes, false);
  if (hits.length > 0) {
    const hitMesh = hits[0].object;
    const sdId = meshToSD.get(hitMesh);
    if (sdId) showDiagCard(sdId, e.clientX, e.clientY);
    else if (state.currentSDId) showDiagCard(state.currentSDId, e.clientX, e.clientY);
  } else {
    closeDiagCard();
  }
});

// Close card on Escape
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && diagCardSDId) { closeDiagCard(); return; }
  if (e.target.tagName==='INPUT'||e.target.tagName==='SELECT') return;
  if (e.key===' ') { e.preventDefault(); setSlide(state.slidePaused?'play':'pause'); }
  else if (e.key==='ArrowRight') setSlide('next');
  else if (e.key==='r'||e.key==='R') { camera.position.set(0,2,18); controls.target.set(0,0,0); controls.update(); }
});

// ═══════════════════════════════════════════════
// UI: PHASE BAR
// ═══════════════════════════════════════════════
const dotBar = document.getElementById('dotBar'), lblBar = document.getElementById('lblBar');
PHASE_NAMES.forEach((n, i) => {
  const d = document.createElement('div'); d.className='phi-dot'; d.id='dot'+i; dotBar.appendChild(d);
  const l = document.createElement('div'); l.className='phi-lbl'; l.id='lbl'+i; l.textContent=n; lblBar.appendChild(l);
});
function updatePhaseBar(ph) { for(let i=0;i<4;i++){document.getElementById('dot'+i).className='phi-dot'+(i===ph?' on':'')+(i<ph?' dn':'');document.getElementById('lbl'+i).className='phi-lbl'+(i===ph?' on':'')+(i<ph?' dn':'');} }

// ═══════════════════════════════════════════════
// UI: ACTIVITY LOG
// ═══════════════════════════════════════════════
function addLog(msg, type='info') {
  const el = document.createElement('div'); el.className = 'log-entry fresh';
  const cls = type==='system'?'log-cs':type==='phase'?'log-cp':'';
  el.innerHTML = cls ? `<span class="${cls}">[${type}]</span> ${msg}` : msg;
  const list = document.getElementById('logList'); list.prepend(el);
  setTimeout(() => el.classList.remove('fresh'), 700);
  while (list.children.length > 12) list.removeChild(list.lastChild);
}

// ═══════════════════════════════════════════════
// FILTER + UI UPDATES
// ═══════════════════════════════════════════════
function passesFilter(sd) {
  // Status filter
  let statusOk;
  switch (state.filter) {
    case 'active': statusOk = !['completed','cancelled'].includes(sd.status); break;
    case 'not-done': statusOk = !['completed','cancelled'].includes(sd.status); break;
    case 'all': statusOk = true; break;
    default: statusOk = sd.status === state.filter;
  }
  // Type filter (AND logic)
  const typeOk = state.typeFilter === 'all' || sd.sd_type === state.typeFilter;
  return statusOk && typeOk;
}
function getFilteredSDs() { return [...state.sds.values()].filter(passesFilter); }

document.getElementById('filterSel').addEventListener('change', (e) => {
  state.filter = e.target.value; rebuildSlideQueue(); updateUI();
  crossfadeOut(); state.slideIndex = 0; startSlide();
});
document.getElementById('typeSel').addEventListener('change', (e) => {
  state.typeFilter = e.target.value; rebuildSlideQueue(); updateUI();
  crossfadeOut(); state.slideIndex = 0; startSlide();
});

let uiTimer = null;
function scheduleUI() { if (uiTimer) return; uiTimer = setTimeout(() => { uiTimer = null; updateUI(); }, 200); }

function formatSDEstimate(sd) {
  const base = TYPE_BASELINES_MIN[sd.sd_type] || TYPE_BASELINES_MIN.default;
  const pct = (sd.progress_percentage ?? sd.progress ?? 0) / 100;
  const remain = base * (1 - pct);
  if (remain >= 60) return `~${(remain / 60).toFixed(1)}h`;
  return `~${Math.round(remain)}m`;
}

function updateUI() {
  const all = [...state.sds.values()], filtered = getFilteredSDs();
  document.getElementById('st-total').textContent = all.length;
  document.getElementById('st-active').textContent = all.filter(s => !['completed','cancelled'].includes(s.status)).length;
  document.getElementById('st-done').textContent = all.filter(s => s.status==='completed').length;
  document.getElementById('queueHeader').innerHTML = `Queue · ${filtered.length} <a class="q-toggle" id="historyToggle" onclick="toggleHistory()">${historyVisible ? 'Queue' : 'History'}</a>`;

  const sorted = [...filtered].sort((a,b) => {
    const aClaimed = state.claimedIds.has(a.id) || state.claimedIds.has(a.sd_key) ? 0 : 1;
    const bClaimed = state.claimedIds.has(b.id) || state.claimedIds.has(b.sd_key) ? 0 : 1;
    if (aClaimed !== bClaimed) return aClaimed - bClaimed;
    const o = {in_progress:0,review:1,planning:2,blocked:3,draft:4,completed:5,cancelled:6};
    return (o[a.status]??6)-(o[b.status]??6);
  });
  const queueEl = document.getElementById('queue');
  queueEl.innerHTML = sorted.map(sd => {
    const c = STATUS_COLORS[sd.status]||'#9E9E9E', act = sd.id===state.currentSDId;
    const claimed = state.claimedIds.has(sd.id) || state.claimedIds.has(sd.sd_key);
    return `<div class="q-item${act?' active':''}${claimed?' claimed':''}" data-id="${sd.id}" title="${sd.title||''}\nType: ${sd.sd_type||'unknown'}\nStatus: ${sd.status}\nProgress: ${sd.progress_percentage??sd.progress??0}%${claimed?'\n⚡ Claimed':''}"><span class="q-dot" style="background:${c}${claimed?';box-shadow:0 0 6px '+c:''}"></span><span class="q-key">${sd.sd_key}</span><span class="q-est">${formatSDEstimate(sd)}</span></div>`;
  }).join('');
  queueEl.querySelectorAll('.q-item').forEach(el => el.addEventListener('click', () => {
    const idx = state.slideQueue.indexOf(el.dataset.id);
    if (idx !== -1) { crossfadeOut(); state.slideIndex=idx; startSlide(); }
  }));
  document.getElementById('sr-summary').textContent = `${all.length} strategic directives. Showing ${filtered.length}.`;
  document.getElementById('no-data').style.display = all.length===0?'block':'none';
  updateEstimate();
  if (!state.webglOk) { const tb=document.getElementById('fb-body'); tb.innerHTML=[...state.sds.values()].map(sd=>`<tr><td>${sd.sd_key}</td><td>${sd.title||''}</td><td>${sd.sd_type||''}</td><td>${sd.status}</td><td>${sd.priority||''}</td><td>${sd.progress_percentage??sd.progress??0}%</td></tr>`).join(''); }
}

function updateQueueHighlight() { document.querySelectorAll('.q-item').forEach(el => el.classList.toggle('active', el.dataset.id===state.currentSDId)); }

// ═══════════════════════════════════════════════
// MAIN ANIMATION LOOP
// ═══════════════════════════════════════════════
function animate() {
  if (!state.webglOk) return;
  state.animationFrameId = requestAnimationFrame(animate);
  const dt = clock.getDelta(), t = clock.getElapsedTime(); frame++;
  // Smooth camera breathe: oscillate around stored base distance
  if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
    const dir = camera.position.clone().sub(controls.target).normalize();
    const targetDist = Math.max(controls.minDistance, Math.min(controls.maxDistance, cameraBaseDistance + Math.sin(t * 0.1) * 0.5));
    camera.position.copy(controls.target).addScaledVector(dir, targetDist);
  }
  controls.update();
  updateForge(t, dt);
  updateErrorCascade(t);
  updateBananaParticles(dt);
  // Crossfade: fade out outgoing shape over ~4 seconds
  if (outgoingGroup) {
    outgoingFade -= dt * 1.0;
    if (outgoingFade <= 0) {
      scene.remove(outgoingGroup); disposeGroup(outgoingGroup); outgoingGroup = null; outgoingFade = 0;
    } else {
      outgoingGroup.rotation.y = t*0.04;
      outgoingGroup.traverse(child => { if (child.material && child.material.opacity !== undefined) child.material.opacity = Math.min(child.material.opacity, outgoingFade * 0.5); });
    }
  }
  retiredShapes.forEach(cs => { cs.mesh.rotation.y=t*cs.rs*0.4; cs.mesh.material.opacity=0.12+pulse(t,0.12)*0.04; });
  // Orbit shapes: orbit, spin, bob
  orbitShapes.forEach(o => {
    o.angle += o.orbitSpeed * dt;
    o.mesh.position.x = Math.cos(o.angle) * o.orbitRadius;
    o.mesh.position.z = Math.sin(o.angle) * o.orbitRadius;
    o.mesh.position.y = o.yBase + Math.sin(t * o.bobSpeed) * o.bobAmp;
    o.mesh.rotation.y += o.spinSpeed * dt;
    o.mesh.rotation.x += o.spinSpeed * dt * 0.3;
  });
  // Session orbs: drift + bob + pulse
  state.sessionOrbs.forEach(o => {
    o.angle += o.orbitSpeed * dt;
    o.mesh.position.x = Math.cos(o.angle) * o.radius;
    o.mesh.position.z = Math.sin(o.angle) * o.radius;
    o.mesh.position.y = o.yBase + Math.sin(t * o.bobSpeed) * o.bobAmp;
    o.mesh.material.opacity = 0.4 + Math.sin(t * o.pulseSpeed) * 0.2;
  });
  for (let i=sparks.length-1; i>=0; i--) { const s=sparks[i]; s.vel.y-=.002; s.mesh.position.add(s.vel); s.life-=.02; s.mesh.material.opacity=Math.max(0,s.life); if(s.life<=0){scene.remove(s.mesh);s.mesh.geometry.dispose();s.mesh.material.dispose();sparks.splice(i,1);} }
  const dp=dustGeo.attributes.position.array;
  for(let i=0;i<DUST_COUNT;i++){dp[i*3]+=dustVel[i*3];dp[i*3+1]+=dustVel[i*3+1];dp[i*3+2]+=dustVel[i*3+2];if(Math.abs(dp[i*3])>20)dustVel[i*3]*=-1;if(Math.abs(dp[i*3+1])>15)dustVel[i*3+1]*=-1;if(Math.abs(dp[i*3+2])>20)dustVel[i*3+2]*=-1;}
  dustGeo.attributes.position.needsUpdate=true;
  renderer.render(scene, camera);
}

document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    clock.stop();
    if (state.animationFrameId) { cancelAnimationFrame(state.animationFrameId); state.animationFrameId = null; }
  } else {
    clock.start();
    if (state.webglOk && !state.animationFrameId) animate();
  }
});

// ═══════════════════════════════════════════════
// SUPABASE CONNECTION
// ═══════════════════════════════════════════════
function addOrUpdateSD(sd) {
  state.sds.set(sd.id, sd); rebuildSlideQueue(); scheduleUI();
  if (!state.currentSDId && state.slideQueue.length > 0) { state.slideIndex = 0; startSlide(); }
}
function removeSD(id) {
  state.sds.delete(id); rebuildSlideQueue(); scheduleUI();
  if (state.currentSDId === id) advanceSlide();
}

async function loadClaimedSDs() {
  if (!state.supabase) return;
  try {
    // Load ALL active/idle sessions (with and without claims)
    const { data: allSessions } = await state.supabase.from('claude_sessions')
      .select('sd_id, session_id, status, heartbeat_at')
      .in('status', ['active', 'idle']);

    const withClaims = (allSessions || []).filter(s => s.sd_id);
    const claimedKeys = withClaims.map(s => s.sd_id);
    state.claimedIds = new Set(claimedKeys);

    // Detect claim conflict: multiple live sessions + at least one claim
    // When a claim is taken over, the bumped session loses sd_id but is still active.
    // If 2+ sessions are alive and any SD is claimed, another session may have been bumped.
    const liveSessions = (allSessions || []).filter(s => {
      const age = (Date.now() - new Date(s.heartbeat_at).getTime()) / 1000;
      return age < 600; // active within last 10 minutes
    });
    const claimedSDs = liveSessions.filter(s => s.sd_id);
    const unclaimedLive = liveSessions.filter(s => !s.sd_id);

    // Reset idle tracker when any live sessions exist
    if (liveSessions.length > 0) {
      lastActivitySeen = Date.now();
      if (document.getElementById('idle-alert').classList.contains('show')) {
        document.getElementById('idle-alert').classList.remove('show');
      }
    }

    if (claimedSDs.length > 0 && unclaimedLive.length > 0) {
      // There are live sessions without claims alongside sessions with claims — possible takeover
      const listEl = document.getElementById('dup-alert-list');
      const items = claimedSDs.map(s =>
        `<li>${s.sd_id} — claimed by 1 session, ${unclaimedLive.length} other live session${unclaimedLive.length > 1 ? 's' : ''} without claims</li>`
      );
      listEl.innerHTML = items.join('');
      document.getElementById('dup-alert-title').textContent = 'CLAIM CONFLICT DETECTED';
      document.getElementById('dup-alert-msg').textContent =
        `${liveSessions.length} active sessions detected. A claim may have been silently taken over.`;
      if (!document.getElementById('dup-alert').classList.contains('show')) {
        document.getElementById('dup-alert').classList.add('show');
        playAlertSound();
      }
      startClaimCountdown();
    } else {
      document.getElementById('dup-alert').classList.remove('show');
      if (claimRetryTimer) { clearInterval(claimRetryTimer); claimRetryTimer = null; }
    }

    // Ensure claimed SDs are loaded even if they weren't in the initial batch
    const missing = claimedKeys.filter(k => ![...state.sds.values()].some(sd => sd.sd_key === k || sd.id === k));
    if (missing.length > 0) {
      const { data: extras } = await state.supabase.from('strategic_directives_v2')
        .select('id, sd_key, title, sd_type, status, current_phase, priority, progress_percentage, created_at, updated_at')
        .in('sd_key', missing);
      (extras || []).forEach(sd => state.sds.set(sd.id, sd));
    }

    rebuildSlideQueue(); updateUI();
    if (state.slideQueue.length > 0 && !state.currentSDId) { state.slideIndex = 0; startSlide(); }
    else { buildOrbitShapes(); }
  } catch (err) { console.warn('Failed to load claims:', err); }
}

async function initSupabase() {
  if (!CONFIG.SUPABASE_URL || !CONFIG.SUPABASE_KEY) {
    setConn('err', 'Not configured');
    addLog('Run: npm run playground:config  (or add ?sb_url=...&sb_key=... to URL)', 'system');
    return;
  }
  // Strip credentials from URL bar/history if passed as query params
  if (_params.get('sb_url') || _params.get('sb_key')) {
    _params.delete('sb_url'); _params.delete('sb_key');
    const clean = _params.toString() ? `${location.pathname}?${_params}` : location.pathname;
    history.replaceState(null, '', clean);
  }
  try {
    const { createClient } = await import('https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm');
    state.supabase = createClient(CONFIG.SUPABASE_URL, CONFIG.SUPABASE_KEY);
    const { data, error } = await state.supabase.from('strategic_directives_v2')
      .select('id, sd_key, title, sd_type, status, current_phase, priority, progress_percentage, created_at, updated_at')
      .not('status', 'in', '("completed","cancelled")')
      .order('updated_at', { ascending: false })
      .limit(CONFIG.MAX_SDS);
    if (error) throw error;
    data.forEach(sd => addOrUpdateSD(sd));
    await loadClaimedSDs();
    setConn('ok', 'Connected');
    subscribeRealtime();
    startIdleMonitoring();
    fetchBurnRate(); fetchLiveSessions();
    state.intervalIds.push(setInterval(fetchLiveSessions, 60000));
    state.intervalIds.push(setInterval(fetchBurnRate, 300000));
  } catch (err) { console.error('Supabase init failed:', err); setConn('err', 'Offline'); addLog('Connection failed: '+err.message, 'system'); }
}

function subscribeRealtime() {
  if (!state.supabase) return;
  state.channel = state.supabase.channel('sd-changes')
    .on('postgres_changes', { event:'*', schema:'public', table:'strategic_directives_v2' }, (payload) => {
      if (payload.eventType==='DELETE') removeSD(payload.old.id);
      else {
        // Payload trim: keep only the 7 columns we use (Supabase realtime sends full rows)
        const r = payload.new;
        const trimmed = { id:r.id, sd_key:r.sd_key, title:r.title, sd_type:r.sd_type, status:r.status, current_phase:r.current_phase, progress_percentage:r.progress_percentage, priority:r.priority, created_at:r.created_at, updated_at:r.updated_at };
        addOrUpdateSD(trimmed); addLog(`${payload.eventType}: ${trimmed.sd_key}`, 'system');
      }
    })
    .on('postgres_changes', { event:'*', schema:'public', table:'claude_sessions' }, () => {
      loadClaimedSDs();
    })
    .subscribe((status) => {
      if (status==='SUBSCRIBED') { setConn('ok','Live'); state.reconnectAttempts=0; }
      else if (status==='CLOSED'||status==='CHANNEL_ERROR') handleDisconnect();
    });
}

function handleDisconnect() {
  state.reconnectAttempts++;
  if (state.reconnectAttempts > CONFIG.RECONNECT_MAX) { setConn('err','Polling'); startPolling(); return; }
  setConn('wait','Reconnecting');
  const delay = Math.min(CONFIG.RECONNECT_BASE_MS * Math.pow(2, state.reconnectAttempts-1), 30000);
  setTimeout(() => { if(state.channel) state.channel.unsubscribe(); subscribeRealtime(); }, delay);
}

function startPolling() {
  state.intervalIds.push(setInterval(async () => {
    if (!state.supabase) return;
    const { data } = await state.supabase.from('strategic_directives_v2')
      .select('id, sd_key, title, sd_type, status, current_phase, priority, progress_percentage, created_at, updated_at')
      .limit(CONFIG.MAX_SDS);
    if (data) { const ids=new Set(data.map(d=>d.id)); state.sds.forEach((_,id)=>{if(!ids.has(id))removeSD(id);}); data.forEach(sd=>addOrUpdateSD(sd)); }
  }, CONFIG.POLL_INTERVAL_MS));
}

function setConn(type, text) { document.getElementById('connDot').className='conn-dot '+type; document.getElementById('connText').textContent=text; }

// ═══════════════════════════════════════════════
// ESTIMATED REMAINING DURATION
// ═══════════════════════════════════════════════
async function fetchBurnRate() {
  if (!state.supabase) return;
  try {
    const { data, error } = await state.supabase.from('sd_execution_actuals')
      .select('actual_effort_hours').eq('status', 'completed').not('actual_effort_hours', 'is', null);
    if (error || !data || data.length === 0) return;
    const total = data.reduce((sum, r) => sum + r.actual_effort_hours, 0);
    state.burnRate = { avgHours: total / data.length, confidence: data.length >= 10 ? 'high' : 'low', sampleSize: data.length };
  } catch (e) { console.warn('fetchBurnRate:', e); }
  updateEstimate();
}

async function fetchLiveSessions() {
  if (!state.supabase) return;
  try {
    const cutoff = new Date(Date.now() - 10 * 60 * 1000).toISOString();
    const { data, error } = await state.supabase.from('claude_sessions')
      .select('session_id').in('status', ['active', 'idle']).gte('heartbeat_at', cutoff);
    if (!error && data) {
      const prev = state.liveSessions;
      state.liveSessions = data.length;
      if (state.webglOk) buildSessionOrbs();
      if (data.length > prev && prev > 0) spawnBananas(Math.min(data.length * 8, BANANA_MAX));
    }
  } catch (e) { console.warn('fetchLiveSessions:', e); }
  updateEstimate();
}

function updateEstimate() {
  const sds = [...state.sds.values()];
  const remaining = sds.filter(s => s.status !== 'completed' && s.status !== 'cancelled');
  const remainingCount = remaining.length;
  const sessions = Math.max(1, state.liveSessions);
  const durEl = document.getElementById('est-dur');
  const detailEl = document.getElementById('est-detail');
  const confEl = document.getElementById('est-conf');

  if (remainingCount === 0) { durEl.textContent = 'All SDs complete'; durEl.style.color = '#66BB6A'; detailEl.textContent = ''; confEl.textContent = ''; return; }
  durEl.style.color = 'rgba(0,200,255,1.0)';

  let avgHours, confidenceLabel;
  if (state.burnRate.avgHours !== null) {
    avgHours = state.burnRate.avgHours;
    confidenceLabel = `${state.burnRate.confidence} confidence (${state.burnRate.sampleSize} SDs)`;
  } else {
    let totalMin = 0;
    remaining.forEach(sd => { totalMin += TYPE_BASELINES_MIN[sd.sd_type] || TYPE_BASELINES_MIN.default; });
    avgHours = (totalMin / remainingCount) / 60;
    confidenceLabel = 'estimate (default baselines)';
  }

  const totalHours = (remainingCount * avgHours) / sessions;
  durEl.textContent = `~${totalHours.toFixed(1)}h`;
  const sessionText = state.liveSessions === 0 ? 'no active sessions' : `${sessions} session${sessions > 1 ? 's' : ''}`;
  detailEl.textContent = `${remainingCount} remaining · ${sessionText} · ~${avgHours.toFixed(1)}h avg`;
  confEl.textContent = confidenceLabel;
}

// ═══════════════════════════════════════════════
// HISTORY VIEW
// ═══════════════════════════════════════════════
let historyVisible = false;
window.toggleHistory = function() {
  historyVisible = !historyVisible;
  document.getElementById('queue').style.display = historyVisible ? 'none' : '';
  document.getElementById('history-panel').style.display = historyVisible ? 'block' : 'none';
  document.getElementById('historyToggle').textContent = historyVisible ? 'Queue' : 'History';
  if (historyVisible) loadHistory();
};

async function loadHistory() {
  if (!state.supabase) return;
  const venture = document.getElementById('histVenture').value;
  const period = document.getElementById('histPeriod').value;
  try {
    let query = state.supabase.from('strategic_directives_v2')
      .select('id, sd_key, title, sd_type, target_application, completion_date, updated_at')
      .eq('status', 'completed')
      .order('updated_at', { ascending: false })
      .limit(100);
    if (venture) query = query.eq('target_application', venture);
    if (period !== 'all') {
      const since = new Date(Date.now() - parseInt(period) * 86400000).toISOString();
      query = query.gte('updated_at', since);
    }
    const { data, error } = await query;
    if (error) throw error;
    populateVentureDropdown(data || []);
    renderHistory(data || []);
  } catch (e) { console.warn('loadHistory:', e); }
}

function populateVentureDropdown(items) {
  const sel = document.getElementById('histVenture');
  const current = sel.value;
  const ventures = [...new Set(items.map(d => d.target_application).filter(Boolean))].sort();
  sel.innerHTML = '<option value="">All Ventures</option>' + ventures.map(v => `<option value="${v}"${v === current ? ' selected' : ''}>${v}</option>`).join('');
}

function renderHistory(items) {
  const grouped = {};
  items.forEach(sd => {
    const key = sd.target_application || 'Unassigned';
    if (!grouped[key]) grouped[key] = [];
    grouped[key].push(sd);
  });
  const html = Object.entries(grouped).map(([venture, sds]) =>
    `<div class="h-group"><div class="h-group-title">${venture} (${sds.length})</div>${sds.map(sd => {
      const date = sd.completion_date || sd.updated_at;
      const dateStr = date ? new Date(date).toLocaleDateString() : '';
      return `<div class="h-item">${sd.sd_key} — ${sd.title || ''}<span class="h-date">${dateStr}</span></div>`;
    }).join('')}</div>`
  ).join('');
  document.getElementById('histList').innerHTML = html || '<div style="padding:12px;font-size:9px;color:rgba(224,220,212,0.36)">No completed SDs found for this period.</div>';
}

// ═══════════════════════════════════════════════
// ANALYTICS (Phase D)
// ═══════════════════════════════════════════════
const anState = {
  open: false,
  tab: 'burndown',
  charts: { burndown: null, gates: null, phases: null, blocking: null },
  channel: null,
  initialized: false,
};

const AN_STATUS_COLORS = {
  draft:'rgba(224,220,212,0.5)', planning:'rgba(100,180,255,0.7)', in_progress:'rgba(0,200,255,0.8)',
  completed:'rgba(74,158,125,0.8)', blocked:'rgba(196,98,106,0.8)', review:'rgba(255,200,100,0.7)',
  cancelled:'rgba(128,128,128,0.5)'
};
const PHASE_COLORS = {
  DRAFT:'#666', LEAD:'#ffcc66', PLAN:'#64b4ff', PLAN_PRD:'#809fff', EXEC:'#00c8ff',
  PLAN_VERIFICATION:'#bf80ff', LEAD_FINAL_APPROVAL:'#4a9e7d'
};

window.toggleAnalytics = function() {
  anState.open = !anState.open;
  const el = document.getElementById('analytics');
  el.classList.toggle('open', anState.open);
  document.getElementById('btnAnalytics').classList.toggle('ac', anState.open);
  // Trigger ResizeObserver on #scene after CSS transition completes
  setTimeout(() => window.dispatchEvent(new Event('resize')), 350);
  if (anState.open && !anState.initialized) { anState.initialized = true; initAnalytics(); }
};

window.switchAnalyticsTab = function(tab) {
  anState.tab = tab;
  document.querySelectorAll('.an-tab').forEach(t => t.classList.toggle('active', t.dataset.tab === tab));
  ['burndown','gates','phases','blocking','sankey'].forEach(t => {
    const el = document.getElementById('an-'+t);
    if (el) el.style.display = t === tab ? '' : 'none';
  });
};

window.exportChartPNG = function() {
  const chart = anState.charts[anState.tab];
  if (!chart) return;
  const url = chart.canvas.toDataURL('image/png');
  const a = document.createElement('a');
  a.href = url;
  a.download = `playground-${anState.tab}-${new Date().toISOString().slice(0,10)}.png`;
  a.click();
  showAnToast('PNG exported');
};

function showAnToast(msg) {
  const el = document.getElementById('anToast');
  el.textContent = msg; el.classList.add('show');
  setTimeout(() => el.classList.remove('show'), 2000);
}

async function initAnalytics() {
  if (!state.supabase || !window.Chart) return;
  await populateAppFilter();
  await loadBurndownData();
  await loadGateFailuresData();
  await loadTimeInPhaseData();
  await loadBlockingCausesData();
  await loadSankeyData();
  subscribeAnalytics();
}

async function populateAppFilter() {
  try {
    const { data } = await state.supabase.from('strategic_directives_v2')
      .select('target_application').not('target_application','is',null);
    const apps = [...new Set((data||[]).map(d=>d.target_application).filter(Boolean))].sort();
    const sel = document.getElementById('anAppFilter');
    sel.innerHTML = '<option value="">All Applications</option>' + apps.map(a=>`<option value="${a}">${a}</option>`).join('');
  } catch(e) { console.warn('populateAppFilter:', e); }
}

window.loadBurndownData = async function() {
  if (!state.supabase) return;
  try {
    let query = state.supabase.from('strategic_directives_v2')
      .select('id, status, created_at, updated_at, target_application')
      .order('created_at', { ascending: true });
    const app = document.getElementById('anAppFilter')?.value;
    if (app) query = query.eq('target_application', app);
    const { data, error } = await query;
    if (error) throw error;
    renderBurndownChart(data || []);
  } catch(e) { console.warn('loadBurndownData:', e); }
};

function renderBurndownChart(sds) {
  if (!sds.length) return;
  // Build weekly time buckets
  const statuses = ['draft','planning','in_progress','review','blocked'];
  const firstDate = new Date(sds[0].created_at);
  const now = new Date();
  const weeks = [];
  const d = new Date(firstDate); d.setHours(0,0,0,0);
  d.setDate(d.getDate() - d.getDay()); // start of week
  while (d <= now) { weeks.push(new Date(d)); d.setDate(d.getDate()+7); }
  if (weeks.length < 2) weeks.push(new Date(now));

  // At each week boundary, count SDs by status
  const datasets = statuses.map(s => ({ label:s, data:[], backgroundColor:AN_STATUS_COLORS[s], fill:true, tension:0.3 }));
  weeks.forEach(weekEnd => {
    const cutoff = weekEnd.getTime();
    statuses.forEach((s, i) => {
      // Count SDs that existed by this date and had this status
      // Approximation: if SD was created before cutoff and current status matches, count it
      // For completed/cancelled, exclude them from active statuses
      const count = sds.filter(sd => {
        const created = new Date(sd.created_at).getTime();
        if (created > cutoff) return false;
        const updated = new Date(sd.updated_at).getTime();
        if (sd.status === 'completed' || sd.status === 'cancelled') {
          // Only count if it wasn't completed yet at this point
          if (updated <= cutoff) return false;
          return s === 'in_progress'; // approximate: was probably in progress
        }
        return sd.status === s;
      }).length;
      datasets[i].data.push(count);
    });
  });

  // ETA projection: 7-day completion velocity
  const recentCompleted = sds.filter(sd => sd.status === 'completed' &&
    (now - new Date(sd.updated_at)) < 7*86400000).length;
  const velocity = recentCompleted / 7; // per day
  const remaining = sds.filter(sd => !['completed','cancelled'].includes(sd.status)).length;
  const etaDays = velocity > 0 ? Math.ceil(remaining / velocity) : null;

  // Add projection points
  if (etaDays && etaDays < 365) {
    const projLabels = [];
    const projData = [];
    for (let i = 0; i <= Math.min(etaDays, 90); i += 7) {
      projLabels.push(new Date(now.getTime() + i*86400000));
      projData.push(Math.max(0, remaining - Math.round(velocity * i)));
    }
    // Extend weeks with projection dates
    projLabels.forEach((pd, i) => {
      if (i > 0) { weeks.push(pd); statuses.forEach((_, si) => datasets[si].data.push(null)); }
    });
    datasets.push({
      label: `ETA: ${etaDays}d (${velocity.toFixed(1)}/day)`,
      data: Array(weeks.length - projLabels.length).fill(null).concat(projData.slice(0, projLabels.length)),
      borderColor: 'rgba(255,200,100,0.8)', borderDash:[6,4], borderWidth:2,
      pointRadius:0, fill:false, tension:0.2
    });
  }

  const labels = weeks.map(w => w.toLocaleDateString('en-US',{month:'short',day:'numeric'}));
  if (anState.charts.burndown) anState.charts.burndown.destroy();
  anState.charts.burndown = new Chart(document.getElementById('burndownCanvas'), {
    type:'line',
    data:{ labels, datasets },
    options:{
      responsive:true, maintainAspectRatio:false,
      scales:{
        x:{ ticks:{ color:'rgba(224,220,212,0.4)', font:{size:8}, maxRotation:45 }, grid:{ color:'rgba(0,200,255,0.06)' }},
        y:{ stacked:true, ticks:{ color:'rgba(224,220,212,0.4)', font:{size:8} }, grid:{ color:'rgba(0,200,255,0.06)' }}
      },
      plugins:{
        legend:{ labels:{ color:'rgba(224,220,212,0.6)', font:{size:8}, boxWidth:10 }},
        tooltip:{ titleFont:{size:9}, bodyFont:{size:9} }
      }
    }
  });
}

async function loadGateFailuresData() {
  if (!state.supabase) return;
  try {
    const { data, error } = await state.supabase.from('sd_phase_handoffs')
      .select('handoff_type, validation_score, status')
      .eq('status', 'failed')
      .order('created_at', { ascending: false })
      .limit(500);
    if (error) throw error;
    renderGateFailuresChart(data || []);
  } catch(e) { console.warn('loadGateFailuresData:', e); }
}

function renderGateFailuresChart(handoffs) {
  // Count failures per handoff_type
  const counts = {};
  handoffs.forEach(h => { counts[h.handoff_type] = (counts[h.handoff_type]||0) + 1; });
  const sorted = Object.entries(counts).sort((a,b)=>b[1]-a[1]);
  if (!sorted.length) {
    if (anState.charts.gates) { anState.charts.gates.destroy(); anState.charts.gates = null; }
    document.getElementById('an-gates').innerHTML = '<div class="an-empty">No gate failures recorded</div><div class="an-chart-wrap"><canvas id="gatesCanvas"></canvas></div>';
    return;
  }
  const total = sorted.reduce((s,e)=>s+e[1], 0);
  let cumulative = 0;
  const cumData = sorted.map(e => { cumulative += e[1]; return Math.round(cumulative/total*100); });

  if (anState.charts.gates) anState.charts.gates.destroy();
  anState.charts.gates = new Chart(document.getElementById('gatesCanvas'), {
    type:'bar',
    data:{
      labels: sorted.map(e=>e[0]),
      datasets:[
        { label:'Failures', data:sorted.map(e=>e[1]), backgroundColor:'rgba(196,98,106,0.7)', borderRadius:2, barPercentage:0.7 },
        { label:'Cumulative %', data:cumData, type:'line', borderColor:'rgba(255,200,100,0.8)', borderWidth:2,
          pointRadius:3, pointBackgroundColor:'rgba(255,200,100,0.8)', fill:false, yAxisID:'y1' }
      ]
    },
    options:{
      indexAxis:'y', responsive:true, maintainAspectRatio:false,
      scales:{
        x:{ ticks:{ color:'rgba(224,220,212,0.4)', font:{size:8} }, grid:{ color:'rgba(0,200,255,0.06)' }},
        y:{ ticks:{ color:'rgba(224,220,212,0.4)', font:{size:8} }, grid:{ color:'rgba(0,200,255,0.06)' }},
        y1:{ position:'right', min:0, max:100, ticks:{ color:'rgba(255,200,100,0.5)', font:{size:8}, callback:v=>v+'%' }, grid:{ display:false }}
      },
      plugins:{
        legend:{ labels:{ color:'rgba(224,220,212,0.6)', font:{size:8}, boxWidth:10 }},
        tooltip:{ titleFont:{size:9}, bodyFont:{size:9} }
      }
    }
  });
}

async function loadTimeInPhaseData() {
  if (!state.supabase) return;
  try {
    const { data, error } = await state.supabase.from('sd_phase_handoffs')
      .select('sd_id, handoff_type, created_at, status')
      .eq('status', 'completed')
      .order('created_at', { ascending: true })
      .limit(2000);
    if (error) throw error;
    renderTimeInPhaseChart(data || []);
  } catch(e) { console.warn('loadTimeInPhaseData:', e); }
}

function renderTimeInPhaseChart(handoffs) {
  // Group by sd_id, compute time deltas between consecutive handoffs
  const bySd = {};
  handoffs.forEach(h => { if (!bySd[h.sd_id]) bySd[h.sd_id] = []; bySd[h.sd_id].push(h); });

  const phaseDurations = {};
  Object.values(bySd).forEach(sdHandoffs => {
    sdHandoffs.sort((a,b) => new Date(a.created_at) - new Date(b.created_at));
    for (let i = 0; i < sdHandoffs.length - 1; i++) {
      const phase = sdHandoffs[i].handoff_type;
      const days = (new Date(sdHandoffs[i+1].created_at) - new Date(sdHandoffs[i].created_at)) / 86400000;
      if (days >= 0 && days < 365) {
        if (!phaseDurations[phase]) phaseDurations[phase] = [];
        phaseDurations[phase].push(days);
      }
    }
  });

  // Compute median per phase
  const median = arr => { const s = [...arr].sort((a,b)=>a-b); const m = Math.floor(s.length/2); return s.length%2 ? s[m] : (s[m-1]+s[m])/2; };
  const p90 = arr => { const s = [...arr].sort((a,b)=>a-b); return s[Math.floor(s.length*0.9)] || s[s.length-1]; };
  const phases = Object.keys(phaseDurations).sort();

  if (!phases.length) {
    if (anState.charts.phases) { anState.charts.phases.destroy(); anState.charts.phases = null; }
    document.getElementById('an-phases').innerHTML = '<div class="an-empty">No phase transition data</div><div class="an-chart-wrap"><canvas id="phasesCanvas"></canvas></div>';
    return;
  }

  const medians = phases.map(p => +median(phaseDurations[p]).toFixed(2));
  const p90s = phases.map(p => +p90(phaseDurations[p]).toFixed(2));
  const colors = phases.map(p => {
    const key = p.replace('LEAD-TO-PLAN','LEAD').replace('PLAN-TO-EXEC','PLAN').replace('EXEC-TO-PLAN','EXEC').replace('PLAN-TO-LEAD','PLAN_VERIFICATION').replace('LEAD-FINAL-APPROVAL','LEAD_FINAL_APPROVAL');
    return PHASE_COLORS[key] || '#00c8ff';
  });

  if (anState.charts.phases) anState.charts.phases.destroy();
  anState.charts.phases = new Chart(document.getElementById('phasesCanvas'), {
    type:'bar',
    data:{
      labels: phases,
      datasets:[
        { label:'Median (days)', data:medians, backgroundColor:colors.map(c=>c+'cc'), borderRadius:2, barPercentage:0.6 },
        { label:'p90 (days)', data:p90s, backgroundColor:colors.map(c=>c+'44'), borderColor:colors, borderWidth:1, borderRadius:2, barPercentage:0.6 }
      ]
    },
    options:{
      indexAxis:'y', responsive:true, maintainAspectRatio:false,
      scales:{
        x:{ title:{ display:true, text:'Days', color:'rgba(224,220,212,0.4)', font:{size:8} },
          ticks:{ color:'rgba(224,220,212,0.4)', font:{size:8} }, grid:{ color:'rgba(0,200,255,0.06)' }},
        y:{ ticks:{ color:'rgba(224,220,212,0.4)', font:{size:8} }, grid:{ color:'rgba(0,200,255,0.06)' }}
      },
      plugins:{
        legend:{ labels:{ color:'rgba(224,220,212,0.6)', font:{size:8}, boxWidth:10 }},
        tooltip:{ titleFont:{size:9}, bodyFont:{size:9},
          callbacks:{ afterLabel:(ctx)=>{ const p = phases[ctx.dataIndex]; const arr = phaseDurations[p]; return `n=${arr.length} samples`; }}
        }
      }
    }
  });
}

function subscribeAnalytics() {
  if (!state.supabase) return;
  const dot = document.getElementById('anConnDot');
  anState.channel = state.supabase.channel('analytics-changes')
    .on('postgres_changes', { event:'*', schema:'public', table:'sd_phase_handoffs' }, () => {
      loadGateFailuresData(); loadTimeInPhaseData(); loadBlockingCausesData();
    })
    .on('postgres_changes', { event:'*', schema:'public', table:'claude_sessions' }, () => {
      // Session changes can affect burndown velocity
    })
    .subscribe((status) => {
      if (status === 'SUBSCRIBED') { dot.className = 'an-status ok'; dot.title = 'Live'; }
      else if (status === 'CLOSED' || status === 'CHANNEL_ERROR') { dot.className = 'an-status off'; dot.title = 'Disconnected'; }
    });
}

// ═══════════════════════════════════════════════
// ERROR COLOR CASCADE
// ═══════════════════════════════════════════════
const errorCascade = { ratio: 0, targetRatio: 0, lastCheck: 0 };
const CASCADE_NORMAL = new THREE.Color(0x040408);
const CASCADE_ERROR = new THREE.Color(0x1a0808);
const CASCADE_LERP = new THREE.Color();

function updateErrorCascade(t) {
  // Recompute every 30s from state data
  if (t - errorCascade.lastCheck > 30) {
    errorCascade.lastCheck = t;
    let total = 0, failed = 0;
    state.sds.forEach(sd => {
      if (sd.status !== 'completed' && sd.status !== 'cancelled') {
        total++;
        if (sd.status === 'blocked') failed++;
      }
    });
    errorCascade.targetRatio = total > 0 ? Math.min(1, failed / total) : 0;
  }
  // Smooth lerp
  errorCascade.ratio += (errorCascade.targetRatio - errorCascade.ratio) * 0.02;
  const r = errorCascade.ratio;
  if (r > 0.01 && scene && scene.fog) {
    CASCADE_LERP.copy(CASCADE_NORMAL).lerp(CASCADE_ERROR, r);
    scene.fog.color.copy(CASCADE_LERP);
    scene.background.copy(CASCADE_LERP);
    if (groundMat) groundMat.color.lerp(new THREE.Color(0.15, 0.04, 0.04), r * 0.3);
  } else if (scene && scene.fog) {
    scene.fog.color.copy(CASCADE_NORMAL);
    scene.background.copy(CASCADE_NORMAL);
  }
}

// ═══════════════════════════════════════════════
// NANO BANANA PARTICLES
// ═══════════════════════════════════════════════
let bananaParticles = null;
const BANANA_MAX = 50;

function initBananaParticles() {
  const geo = new THREE.BufferGeometry();
  const positions = new Float32Array(BANANA_MAX * 3);
  const velocities = new Float32Array(BANANA_MAX * 3);
  const lifetimes = new Float32Array(BANANA_MAX);
  geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  const mat = new THREE.PointsMaterial({
    color: 0xffe066, size: 0.12, transparent: true, opacity: 0.7,
    blending: THREE.AdditiveBlending, depthWrite: false
  });
  const mesh = new THREE.Points(geo, mat);
  scene.add(mesh);
  bananaParticles = { geo, mat, mesh, velocities, lifetimes, active: 0 };
}

function spawnBananas(count) {
  if (!bananaParticles) return;
  const pos = bananaParticles.geo.attributes.position.array;
  const vel = bananaParticles.velocities;
  const life = bananaParticles.lifetimes;
  for (let i = 0; i < Math.min(count, BANANA_MAX); i++) {
    const idx = i * 3;
    pos[idx] = (Math.random() - 0.5) * 2;
    pos[idx+1] = 3 + Math.random() * 2;
    pos[idx+2] = (Math.random() - 0.5) * 2;
    vel[idx] = (Math.random() - 0.5) * 0.03;
    vel[idx+1] = 0.02 + Math.random() * 0.04;
    vel[idx+2] = (Math.random() - 0.5) * 0.03;
    life[i] = 1.0;
  }
  bananaParticles.active = Math.min(count, BANANA_MAX);
  bananaParticles.geo.attributes.position.needsUpdate = true;
}

function updateBananaParticles(dt) {
  if (!bananaParticles || bananaParticles.active === 0) return;
  const pos = bananaParticles.geo.attributes.position.array;
  const vel = bananaParticles.velocities;
  const life = bananaParticles.lifetimes;
  let anyAlive = false;
  for (let i = 0; i < bananaParticles.active; i++) {
    if (life[i] <= 0) continue;
    anyAlive = true;
    const idx = i * 3;
    vel[idx+1] -= 0.001 * dt * 60; // gravity
    pos[idx] += vel[idx]; pos[idx+1] += vel[idx+1]; pos[idx+2] += vel[idx+2];
    life[i] -= 0.008 * dt * 60;
    if (life[i] <= 0) { pos[idx+1] = -100; } // hide
  }
  bananaParticles.mat.opacity = 0.7;
  bananaParticles.geo.attributes.position.needsUpdate = true;
  if (!anyAlive) bananaParticles.active = 0;
}

// ═══════════════════════════════════════════════
// SESSION TIMELINE
// ═══════════════════════════════════════════════
let sessionTimelineInterval = null;

async function loadSessionTimeline() {
  if (!state.supabase) return;
  try {
    const { data } = await state.supabase.from('claude_sessions')
      .select('session_id, status, heartbeat_at, sd_id, metadata')
      .order('heartbeat_at', { ascending: false })
      .limit(20);
    if (!data) return;
    renderSessionTimeline(data);
  } catch(e) { console.warn('loadSessionTimeline:', e); }
}

function renderSessionTimeline(sessions) {
  const now = Date.now();
  const list = document.getElementById('st-list');
  const bar = document.getElementById('st-bar');
  if (!list || !bar) return;

  // Status bar
  let alive = 0, stale = 0, dead = 0;
  sessions.forEach(s => {
    const age = now - new Date(s.heartbeat_at).getTime();
    if (s.status === 'active' && age < 120000) alive++;
    else if (s.status === 'active' && age < 900000) stale++;
    else dead++;
  });
  const total = sessions.length || 1;
  bar.innerHTML =
    (alive ? `<div class="st-bar-seg" style="flex:${alive};background:#4a9e7d" title="${alive} active"></div>` : '') +
    (stale ? `<div class="st-bar-seg" style="flex:${stale};background:#ffab40" title="${stale} stale"></div>` : '') +
    (dead ? `<div class="st-bar-seg" style="flex:${dead};background:rgba(196,98,106,0.5)" title="${dead} ended"></div>` : '');

  // Session rows (show top 8)
  list.innerHTML = sessions.slice(0, 8).map(s => {
    const age = now - new Date(s.heartbeat_at).getTime();
    const cls = s.status === 'active' && age < 120000 ? 'alive' : s.status === 'active' && age < 900000 ? 'stale' : 'dead';
    const ageStr = age < 60000 ? '<1m' : age < 3600000 ? Math.round(age/60000) + 'm' : Math.round(age/3600000) + 'h';
    const id = s.session_id?.slice(-8) || '?';
    return `<div class="st-row"><span class="st-dot ${cls}"></span><span class="st-id" title="${s.session_id}">${id}</span><span class="st-age">${ageStr} ago</span></div>`;
  }).join('');
}

// ═══════════════════════════════════════════════
// BLOCKING CAUSES (Analytics Tab 4)
// ═══════════════════════════════════════════════
async function loadBlockingCausesData() {
  if (!state.supabase) return;
  try {
    const { data, error } = await state.supabase.from('sd_phase_handoffs')
      .select('handoff_type, validation_details, status')
      .in('status', ['failed', 'rejected'])
      .order('created_at', { ascending: false })
      .limit(500);
    if (error) throw error;
    renderBlockingCausesChart(data || []);
  } catch(e) { console.warn('loadBlockingCausesData:', e); }
}

function renderBlockingCausesChart(handoffs) {
  const causes = {};
  handoffs.forEach(h => {
    const reason = h.validation_details?.reason || h.validation_details?.message || h.handoff_type || 'unknown';
    // Extract short cause from reason string
    const short = reason.length > 40 ? reason.slice(0, 40) + '...' : reason;
    causes[short] = (causes[short] || 0) + 1;
  });
  const sorted = Object.entries(causes).sort((a, b) => b[1] - a[1]).slice(0, 8);

  if (!sorted.length) {
    document.getElementById('an-blocking').innerHTML = '<div class="an-empty">No blocking causes recorded</div><div class="an-chart-wrap"><canvas id="blockingCanvas"></canvas></div>';
    return;
  }

  // Pareto chart
  const total = sorted.reduce((s, e) => s + e[1], 0);
  let cum = 0;
  const cumData = sorted.map(e => { cum += e[1]; return Math.round(cum / total * 100); });
  const colors = sorted.map((_, i) => `hsla(${350 - i * 20}, 60%, 55%, 0.7)`);

  if (anState.charts.blocking) anState.charts.blocking.destroy();
  anState.charts.blocking = new Chart(document.getElementById('blockingCanvas'), {
    type: 'bar',
    data: {
      labels: sorted.map(e => e[0]),
      datasets: [
        { label: 'Count', data: sorted.map(e => e[1]), backgroundColor: colors, borderRadius: 2, barPercentage: 0.7 },
        { label: 'Cumulative %', data: cumData, type: 'line', borderColor: 'rgba(255,200,100,0.8)', borderWidth: 2,
          pointRadius: 3, pointBackgroundColor: 'rgba(255,200,100,0.8)', fill: false, yAxisID: 'y1' }
      ]
    },
    options: {
      indexAxis: 'y', responsive: true, maintainAspectRatio: false,
      scales: {
        x: { ticks: { color: 'rgba(224,220,212,0.4)', font: { size: 8 } }, grid: { color: 'rgba(0,200,255,0.06)' } },
        y: { ticks: { color: 'rgba(224,220,212,0.4)', font: { size: 7 } }, grid: { color: 'rgba(0,200,255,0.06)' } },
        y1: { position: 'right', min: 0, max: 100, ticks: { color: 'rgba(255,200,100,0.5)', font: { size: 8 }, callback: v => v + '%' }, grid: { display: false } }
      },
      plugins: {
        legend: { labels: { color: 'rgba(224,220,212,0.6)', font: { size: 8 }, boxWidth: 10 } },
        tooltip: { titleFont: { size: 9 }, bodyFont: { size: 9 } }
      }
    }
  });
}

// ═══════════════════════════════════════════════
// SANKEY INBOX FLOW (Analytics Tab 5)
// ═══════════════════════════════════════════════
async function loadSankeyData() {
  if (!state.supabase) return;
  try {
    const { data, error } = await state.supabase.from('issue_patterns')
      .select('category, severity, status')
      .limit(500);
    if (error) throw error;
    renderSankey(data || []);
  } catch(e) { console.warn('loadSankeyData:', e); }
}

function renderSankey(patterns) {
  const canvas = document.getElementById('sankeyCanvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  canvas.width = canvas.offsetWidth * dpr;
  canvas.height = 280 * dpr;
  ctx.scale(dpr, dpr);
  const W = canvas.offsetWidth, H = 280;
  ctx.clearRect(0, 0, W, H);

  if (!patterns.length) {
    ctx.fillStyle = 'rgba(224,220,212,0.36)';
    ctx.font = '9px "JetBrains Mono", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('No issue pattern data', W / 2, H / 2);
    return;
  }

  // Build flows: Category → Severity → Status
  const catCounts = {}, sevCounts = {}, statusCounts = {};
  const catToSev = {}, sevToStatus = {};
  patterns.forEach(p => {
    const cat = p.category || 'unknown';
    const sev = p.severity || 'medium';
    const st = p.status || 'open';
    catCounts[cat] = (catCounts[cat] || 0) + 1;
    sevCounts[sev] = (sevCounts[sev] || 0) + 1;
    statusCounts[st] = (statusCounts[st] || 0) + 1;
    const csKey = cat + '→' + sev;
    catToSev[csKey] = (catToSev[csKey] || 0) + 1;
    const ssKey = sev + '→' + st;
    sevToStatus[ssKey] = (sevToStatus[ssKey] || 0) + 1;
  });

  const cats = Object.entries(catCounts).sort((a, b) => b[1] - a[1]).slice(0, 6);
  const sevs = Object.entries(sevCounts).sort((a, b) => b[1] - a[1]);
  const stats = Object.entries(statusCounts).sort((a, b) => b[1] - a[1]);
  const total = patterns.length;

  // Column positions
  const colX = [30, W / 2 - 20, W - 80];
  const nodeW = 14;

  // Draw nodes and compute y positions
  const nodeColor = { critical: '#c4626a', high: '#ff8844', medium: '#ffab40', low: '#4a9e7d', unknown: '#666',
    open: '#ffab40', resolved: '#4a9e7d', investigating: '#00c8ff', monitoring: '#64b4ff' };

  function drawColumn(entries, x, totalN) {
    const gap = 4;
    const available = H - 30 - (entries.length - 1) * gap;
    const positions = [];
    let y = 15;
    entries.forEach(([name, count]) => {
      const h = Math.max(8, (count / totalN) * available);
      const color = nodeColor[name] || 'rgba(0,200,255,0.5)';
      ctx.fillStyle = color;
      ctx.fillRect(x, y, nodeW, h);
      ctx.fillStyle = 'rgba(224,220,212,0.6)';
      ctx.font = '7px "JetBrains Mono", monospace';
      ctx.textAlign = x < W / 2 ? 'left' : 'right';
      const textX = x < W / 2 ? x + nodeW + 4 : x - 4;
      ctx.fillText(`${name} (${count})`, textX, y + h / 2 + 3);
      positions.push({ name, y, h, count });
      y += h + gap;
    });
    return positions;
  }

  const catPos = drawColumn(cats, colX[0], total);
  ctx.textAlign = 'left';
  const sevPos = drawColumn(sevs, colX[1], total);
  const statPos = drawColumn(stats, colX[2], total);

  // Draw flows
  ctx.globalAlpha = 0.15;
  function drawFlows(fromPos, toPos, flowMap, fromX, toX) {
    const fromOffsets = {};
    const toOffsets = {};
    fromPos.forEach(p => { fromOffsets[p.name] = 0; });
    toPos.forEach(p => { toOffsets[p.name] = 0; });

    Object.entries(flowMap).forEach(([key, count]) => {
      const [fromName, toName] = key.split('→');
      const from = fromPos.find(p => p.name === fromName);
      const to = toPos.find(p => p.name === toName);
      if (!from || !to) return;
      const fh = (count / from.count) * from.h;
      const th = (count / to.count) * to.h;
      const fy = from.y + (fromOffsets[fromName] || 0);
      const ty = to.y + (toOffsets[toName] || 0);
      fromOffsets[fromName] = (fromOffsets[fromName] || 0) + fh;
      toOffsets[toName] = (toOffsets[toName] || 0) + th;

      ctx.beginPath();
      ctx.moveTo(fromX + nodeW, fy);
      const cp = (toX - fromX - nodeW) / 2;
      ctx.bezierCurveTo(fromX + nodeW + cp, fy, toX - cp, ty, toX, ty);
      ctx.lineTo(toX, ty + th);
      ctx.bezierCurveTo(toX - cp, ty + th, fromX + nodeW + cp, fy + fh, fromX + nodeW, fy + fh);
      ctx.closePath();
      ctx.fillStyle = nodeColor[fromName] || 'rgba(0,200,255,0.5)';
      ctx.fill();
    });
  }

  drawFlows(catPos, sevPos, catToSev, colX[0], colX[1]);
  drawFlows(sevPos, statPos, sevToStatus, colX[1], colX[2]);
  ctx.globalAlpha = 1.0;

  // Column headers
  ctx.fillStyle = 'rgba(224,220,212,0.35)';
  ctx.font = '7px "JetBrains Mono", monospace';
  ctx.textAlign = 'center';
  ctx.fillText('CATEGORY', colX[0] + nodeW / 2, 10);
  ctx.fillText('SEVERITY', colX[1] + nodeW / 2, 10);
  ctx.fillText('STATUS', colX[2] + nodeW / 2, 10);
}

// ═══════════════════════════════════════════════
// INIT
// ═══════════════════════════════════════════════
initThree();
if (state.webglOk) { initBananaParticles(); animate(); }
initSupabase();
addLog('Forge initialized — awaiting directives', 'system');
// Session timeline: load initially and refresh every 30s
setTimeout(() => { loadSessionTimeline(); sessionTimelineInterval = setInterval(loadSessionTimeline, 30000); state.intervalIds.push(sessionTimelineInterval); }, 2000);
window.addEventListener('beforeunload', () => {
  state.intervalIds.forEach(id => clearInterval(id));
  if (state.animationFrameId) cancelAnimationFrame(state.animationFrameId);
  if (anState.channel) anState.channel.unsubscribe();
});
</script>
</body>
</html>
