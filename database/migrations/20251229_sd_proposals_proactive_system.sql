-- ============================================================================
-- LEO Protocol v4.4: Proactive SD Proposal System
-- Migration: sd_proposals table and supporting infrastructure
-- SD: SD-LEO-PROACTIVE-001
-- ============================================================================

-- Drop existing objects if they exist (for idempotency)
DROP VIEW IF EXISTS v_proposal_learning;
DROP FUNCTION IF EXISTS fn_create_sd_from_proposal(UUID);
DROP INDEX IF EXISTS idx_sd_proposals_dedupe_active;
DROP INDEX IF EXISTS idx_sd_proposals_pending;
DROP INDEX IF EXISTS idx_sd_proposals_trigger;
DROP INDEX IF EXISTS idx_sd_proposals_venture;
DROP TABLE IF EXISTS sd_proposals;

-- ============================================================================
-- 1. Create sd_proposals table
-- ============================================================================
CREATE TABLE sd_proposals (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Scoping (multi-venture/app support)
  venture_id UUID REFERENCES ventures(id) ON DELETE CASCADE,
  target_application TEXT,  -- 'EHG', 'EHG_Engineer', etc.

  -- Proposal Content
  title VARCHAR(200) NOT NULL,
  description TEXT NOT NULL,
  proposed_scope JSONB NOT NULL DEFAULT '{}'::jsonb,  -- { objectives, success_criteria, risks }
  evidence_data JSONB DEFAULT '{}'::jsonb,  -- supporting data from triggers

  -- Source & Trigger (with provenance)
  trigger_type VARCHAR(40) NOT NULL,
  trigger_source_id TEXT,  -- FK to retrospective, npm audit result, etc.
  trigger_event_type VARCHAR(60),
  trigger_trace_id UUID,  -- Optional FK to agent traces (may not exist)
  correlation_id UUID,  -- for tracing related events

  -- Actor tracking (prevents infinite loops)
  created_by TEXT NOT NULL DEFAULT 'manual',  -- 'observer:retrospective', 'observer:dependency', etc.

  -- Scoring (0-1 range with CHECK constraints)
  confidence_score NUMERIC(3,2) NOT NULL CHECK (confidence_score BETWEEN 0 AND 1),
  impact_score NUMERIC(3,2) NOT NULL CHECK (impact_score BETWEEN 0 AND 1),
  urgency_level VARCHAR(20) NOT NULL DEFAULT 'medium',

  -- Deduplication (deterministic hash)
  dedupe_key TEXT NOT NULL,  -- format: {trigger_type}:{scope}:{target_hash}

  -- Lifecycle
  status VARCHAR(20) NOT NULL DEFAULT 'pending',
  seen_at TIMESTAMPTZ,
  approved_at TIMESTAMPTZ,
  dismissed_at TIMESTAMPTZ,
  snoozed_until TIMESTAMPTZ,  -- for snooze functionality
  dismissal_reason VARCHAR(30),

  -- Linkage (TEXT to match strategic_directives_v2.id which is VARCHAR(50))
  created_sd_id TEXT REFERENCES strategic_directives_v2(id),
  linked_alert_id UUID,  -- chairman_alerts entry for critical

  -- Timestamps (tiered expiration)
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  expires_at TIMESTAMPTZ,  -- varies by urgency: critical=7d, medium=14d, low=30d

  -- CHECK constraints for ENUM-like fields
  CONSTRAINT check_trigger_type CHECK (trigger_type IN (
    'retrospective_pattern',
    'code_health',
    'dependency_update',
    'manual'
  )),

  CONSTRAINT check_urgency_level CHECK (urgency_level IN (
    'low',
    'medium',
    'critical'
  )),

  CONSTRAINT check_status CHECK (status IN (
    'pending',
    'seen',
    'approved',
    'dismissed',
    'snoozed',
    'expired'
  )),

  CONSTRAINT check_dismissal_reason CHECK (dismissal_reason IS NULL OR dismissal_reason IN (
    'not_relevant',
    'wrong_timing',
    'duplicate',
    'too_small',
    'too_large',
    'already_fixed',
    'other'
  ))
);

-- Add table comment
COMMENT ON TABLE sd_proposals IS 'Proactive SD proposals generated by observer agents - LEO Protocol v4.4';

-- ============================================================================
-- 2. Create indexes
-- ============================================================================

-- Partial unique: only active proposals must be unique (allows re-propose after expiry)
CREATE UNIQUE INDEX idx_sd_proposals_dedupe_active
  ON sd_proposals(dedupe_key)
  WHERE status IN ('pending', 'seen', 'snoozed');

-- Query indexes for common access patterns
CREATE INDEX idx_sd_proposals_pending
  ON sd_proposals(status, urgency_level DESC, created_at DESC)
  WHERE status = 'pending';

CREATE INDEX idx_sd_proposals_trigger
  ON sd_proposals(trigger_type, created_at DESC);

CREATE INDEX idx_sd_proposals_venture
  ON sd_proposals(venture_id, status, created_at DESC)
  WHERE venture_id IS NOT NULL;

CREATE INDEX idx_sd_proposals_expires
  ON sd_proposals(expires_at)
  WHERE status IN ('pending', 'seen', 'snoozed') AND expires_at IS NOT NULL;

-- ============================================================================
-- 3. Enable RLS with chairman-only access
-- ============================================================================
ALTER TABLE sd_proposals ENABLE ROW LEVEL SECURITY;

-- Service role: Full access (observers use service_role)
CREATE POLICY sd_proposals_service_role ON sd_proposals
  FOR ALL TO service_role
  USING (true) WITH CHECK (true);

-- Authenticated users: Read-only for chairman
CREATE POLICY sd_proposals_select ON sd_proposals
  FOR SELECT TO authenticated
  USING (fn_is_chairman());

-- Chairman can update lifecycle fields only
CREATE POLICY sd_proposals_update_lifecycle ON sd_proposals
  FOR UPDATE TO authenticated
  USING (fn_is_chairman())
  WITH CHECK (fn_is_chairman());

-- ============================================================================
-- 4. Create fn_create_sd_from_proposal() - Idempotent approval function
-- ============================================================================
CREATE OR REPLACE FUNCTION fn_create_sd_from_proposal(proposal_id UUID)
RETURNS TEXT AS $$
DECLARE
  v_proposal sd_proposals%ROWTYPE;
  v_new_sd_id TEXT;
BEGIN
  -- Lock the proposal row to prevent race conditions
  SELECT * INTO v_proposal FROM sd_proposals
  WHERE id = proposal_id FOR UPDATE;

  -- Check proposal exists
  IF v_proposal.id IS NULL THEN
    RAISE EXCEPTION 'Proposal not found: %', proposal_id;
  END IF;

  -- Idempotency: if already approved, return existing SD
  IF v_proposal.status = 'approved' AND v_proposal.created_sd_id IS NOT NULL THEN
    RETURN v_proposal.created_sd_id;
  END IF;

  -- Validate: must be pending or seen
  IF v_proposal.status NOT IN ('pending', 'seen') THEN
    RAISE EXCEPTION 'Proposal not in approvable state: %', v_proposal.status;
  END IF;

  -- Generate new SD ID
  v_new_sd_id := 'SD-PROPOSAL-' || UPPER(SUBSTRING(gen_random_uuid()::TEXT FROM 1 FOR 8));

  -- Create SD in draft status (NEVER auto-advance)
  INSERT INTO strategic_directives_v2 (
    id,
    title,
    description,
    status,
    current_phase,
    priority,
    category,
    target_application,
    metadata
  ) VALUES (
    v_new_sd_id,
    v_proposal.title,
    v_proposal.description,
    'draft',  -- Always draft, never auto-trigger active states
    'LEAD',   -- Start in LEAD phase for validation
    'medium',
    'feature',
    v_proposal.target_application,
    jsonb_build_object(
      'source', 'proactive_proposal',
      'proposal_id', proposal_id,
      'trigger_type', v_proposal.trigger_type,
      'confidence_score', v_proposal.confidence_score,
      'proposed_scope', v_proposal.proposed_scope,
      'evidence_data', v_proposal.evidence_data
    )
  );

  -- Update proposal
  UPDATE sd_proposals SET
    status = 'approved',
    approved_at = NOW(),
    updated_at = NOW(),
    created_sd_id = v_new_sd_id
  WHERE id = proposal_id;

  -- Log system event if function exists
  BEGIN
    PERFORM fn_log_system_event(
      'PROPOSAL_APPROVED',
      v_proposal.correlation_id,
      jsonb_build_object('proposal_id', proposal_id, 'created_sd_id', v_new_sd_id)
    );
  EXCEPTION WHEN undefined_function THEN
    -- fn_log_system_event may not exist, that's OK
    NULL;
  END;

  RETURN v_new_sd_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION fn_create_sd_from_proposal(UUID) IS 'Idempotent function to create SD from approved proposal';

-- ============================================================================
-- 5. Create v_proposal_learning analytics view
-- ============================================================================
CREATE VIEW v_proposal_learning AS
SELECT
  trigger_type,
  COUNT(*) as total_proposals,
  COUNT(*) FILTER (WHERE status = 'approved') as approved_count,
  COUNT(*) FILTER (WHERE status = 'dismissed') as dismissed_count,
  COUNT(*) FILTER (WHERE status = 'expired') as expired_count,
  ROUND(
    100.0 * COUNT(*) FILTER (WHERE status = 'approved') / NULLIF(COUNT(*), 0),
    1
  ) as approval_rate,
  MODE() WITHIN GROUP (ORDER BY dismissal_reason) as most_common_dismissal,
  ROUND(AVG(confidence_score) FILTER (WHERE status = 'approved'), 2) as avg_approved_confidence,
  ROUND(AVG(confidence_score) FILTER (WHERE status = 'dismissed'), 2) as avg_dismissed_confidence,
  MIN(created_at) as first_proposal,
  MAX(created_at) as last_proposal
FROM sd_proposals
WHERE created_at > NOW() - INTERVAL '30 days'
GROUP BY trigger_type;

COMMENT ON VIEW v_proposal_learning IS 'Analytics view for proposal approval rates by trigger type (30-day window)';

-- ============================================================================
-- 6. Create trigger for automatic expiration setting
-- ============================================================================
CREATE OR REPLACE FUNCTION fn_set_proposal_expiration()
RETURNS TRIGGER AS $$
BEGIN
  -- Set expires_at based on urgency level if not already set
  IF NEW.expires_at IS NULL THEN
    CASE NEW.urgency_level
      WHEN 'critical' THEN
        NEW.expires_at := NOW() + INTERVAL '7 days';
      WHEN 'medium' THEN
        NEW.expires_at := NOW() + INTERVAL '14 days';
      WHEN 'low' THEN
        NEW.expires_at := NOW() + INTERVAL '30 days';
      ELSE
        NEW.expires_at := NOW() + INTERVAL '14 days';
    END CASE;
  END IF;

  -- Set updated_at
  NEW.updated_at := NOW();

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_set_proposal_expiration
  BEFORE INSERT OR UPDATE ON sd_proposals
  FOR EACH ROW
  EXECUTE FUNCTION fn_set_proposal_expiration();

-- ============================================================================
-- 7. Grant permissions
-- ============================================================================
GRANT SELECT ON sd_proposals TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON sd_proposals TO service_role;
GRANT SELECT ON v_proposal_learning TO authenticated;
GRANT SELECT ON v_proposal_learning TO service_role;
GRANT EXECUTE ON FUNCTION fn_create_sd_from_proposal(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION fn_create_sd_from_proposal(UUID) TO service_role;

-- ============================================================================
-- Migration complete
-- ============================================================================
