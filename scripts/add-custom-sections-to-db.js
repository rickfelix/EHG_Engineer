#!/usr/bin/env node
/**
 * Add Custom Sections to LEO Protocol Database
 * Stores PR Size Guidelines, Parallel Execution, Sub-Agent Parallel Execution
 */

import { createClient } from '@supabase/supabase-js';
import dotenv from 'dotenv';

dotenv.config();

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
);

async function addCustomSections() {
  console.log('üîÑ Adding custom sections to LEO Protocol database...\n');

  // Get active protocol
  const { data: protocol, error: protocolError } = await supabase
    .from('leo_protocols')
    .select('id')
    .eq('status', 'active')
    .single();

  if (protocolError || !protocol) {
    console.error('‚ùå Could not find active protocol:', protocolError);
    return;
  }

  console.log(`üìã Active Protocol: ${protocol.id}\n`);

  const sections = [
    {
      section_type: 'file_warning',
      title: '‚ö†Ô∏è DO NOT EDIT THIS FILE DIRECTLY',
      content: `**This file is AUTO-GENERATED from the database.**

## To Make Changes:
1. **For dynamic content** (agents, sub-agents, triggers): Update database tables directly
2. **For static sections** (guides, examples, instructions): Add/update in \`leo_protocol_sections\` table
3. **Regenerate file**: Run \`node scripts/generate-claude-md-from-db.js\`

**Any direct edits to this file will be lost on next regeneration!**

See documentation for table structure: \`database/schema/007_leo_protocol_schema_fixed.sql\``,
      order_index: 0
    },
    {
      section_type: 'pr_size_guidelines',
      title: 'PR Size Guidelines',
      content: `**Philosophy**: Balance AI capability with human review capacity. Modern AI can handle larger changes, but humans still need to review them.

**Three Tiers**:

1. **‚â§100 lines (Sweet Spot)** - No justification needed
   - Simple bug fixes
   - Single feature additions
   - Configuration changes
   - Documentation updates

2. **101-200 lines (Acceptable)** - Brief justification in PR description
   - Multi-component features
   - Refactoring with tests
   - Database migrations with updates
   - Example: "Adds authentication UI (3 components) + tests"

3. **201-400 lines (Requires Strong Justification)** - Detailed rationale required
   - Complex features that cannot be reasonably split
   - Large refactorings with extensive test coverage
   - Third-party integrations with configuration
   - Must explain why splitting would create more risk/complexity
   - Example: "OAuth integration requires provider config, UI flows, session management, and error handling as atomic unit"

**Over 400 lines**: Generally prohibited. Split into multiple PRs unless exceptional circumstances (emergency hotfix, external dependency forcing bundled changes).

**Key Principle**: If you can split it without creating incomplete/broken intermediate states, you should split it.`,
      order_index: 50
    },
    {
      section_type: 'parallel_execution',
      title: 'Parallel Execution',
      content: `**When to Use**: Modern AI supports parallel tool execution for independent operations. Use conservatively.

**Safe for Parallel Execution**:
- ‚úÖ Reading multiple independent files for analysis
- ‚úÖ Running multiple independent database queries
- ‚úÖ Executing multiple read-only Git commands (status, log, diff)
- ‚úÖ Multiple WebFetch calls to different URLs
- ‚úÖ Batch file searches (multiple Glob operations)

**NOT Safe for Parallel Execution**:
- ‚ùå Write operations (Edit, Write tools)
- ‚ùå Database mutations (INSERT, UPDATE, DELETE)
- ‚ùå Any operations where order matters
- ‚ùå Operations that depend on each other's results
- ‚ùå Git operations that modify state (commit, push, merge)

**Critical Constraint**: Context sharing between parallel operations is limited. Each operation receives the same initial context but cannot see other parallel operations' results until they all complete.

**Example Use Case**:
\`\`\`
"Read the following 3 files for analysis:"
- Read src/component.tsx
- Read src/types.ts
- Read tests/component.test.tsx
\`\`\`

**Anti-Pattern**:
\`\`\`
"Read file A, then based on what you find, read file B"
(Must be sequential - second read depends on first)
\`\`\``,
      order_index: 60
    },
    {
      section_type: 'subagent_parallel_execution',
      title: 'Sub-Agent Parallel Execution',
      content: `**Overview**: Sub-agents are independent specialists. When multiple sub-agents provide non-overlapping assessments, call them in parallel to reduce latency.

**When Parallel Execution is Beneficial**:

1. **LEAD Initial Assessment**
   - Parallel: Security Architect + Database Architect + Business Analyst
   - Why: Each evaluates different aspects of an SD (security posture, data model feasibility, business alignment)
   - Context sharing: Not required - each has independent assessment criteria

2. **PLAN Supervisor Verification**
   - Parallel: QA Director + Security Architect + Performance Lead + Database Architect
   - Why: Final "done done" check across all quality dimensions simultaneously
   - Context sharing: Not required - each validates their domain independently

3. **EXEC Pre-Implementation Checks**
   - Parallel: Systems Analyst (duplicate check) + Security Architect (auth requirements) + Database Architect (schema changes)
   - Why: Gather all constraints before coding begins
   - Context sharing: Not required - each identifies risks independently

**When Sequential Execution is Required**:

- ‚ùå One sub-agent's output feeds another's input
- ‚ùå Database schema must be reviewed before security assessment
- ‚ùå Any workflow where order creates dependencies

**Implementation Pattern**:

\`\`\`javascript
// ‚úÖ Parallel - Independent assessments
const results = await Promise.all([
  callSubAgent('security-architect', sd_id),
  callSubAgent('database-architect', sd_id),
  callSubAgent('qa-director', sd_id)
]);

// ‚ùå Sequential - One depends on another
const schema = await callSubAgent('database-architect', sd_id);
const securityReview = await callSubAgent('security-architect', schema); // Needs schema first
\`\`\`

**Critical Constraints**:
- Each sub-agent receives the same initial context
- Sub-agents cannot see each other's results until all complete
- Aggregate results AFTER all sub-agents finish
- If any sub-agent fails, gracefully handle in aggregation phase

**Benefits**:
- Reduces total verification time (4 sub-agents in 30s vs. 2min sequential)
- No context sharing limitations since assessments are independent
- Each specialist works from fresh context without bias from others`,
      order_index: 70
    }
  ];

  console.log('üìù Inserting sections...\n');

  for (const section of sections) {
    const { error: insertError } = await supabase
      .from('leo_protocol_sections')
      .insert({
        protocol_id: protocol.id,
        section_type: section.section_type,
        title: section.title,
        content: section.content,
        order_index: section.order_index,
        metadata: {}
      });

    if (insertError) {
      console.error(`‚ùå Error inserting ${section.section_type}:`, insertError);
    } else {
      console.log(`‚úÖ Added: ${section.title}`);
    }
  }

  console.log('\nüéâ Custom sections added to database!');
  console.log('üìã Next step: Update generator to pull these sections dynamically');
}

addCustomSections();