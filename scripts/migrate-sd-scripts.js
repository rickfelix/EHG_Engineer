#!/usr/bin/env node

/**
 * SD Script Migration Tool
 * Converts SD-specific scripts to use universal templates
 * Generated by DOCMON sub-agent analysis
 */

import fs from 'fs/promises';
import path from 'path';
import chalk from 'chalk';

const SCRIPT_DIR = 'scripts';
const MIGRATION_DIR = 'scripts/migrated';

async function analyzeScript(filename) {
  const content = await fs.readFile(path.join(SCRIPT_DIR, filename), 'utf8');

  // Extract SD ID from filename or content
  const sdIdMatch = filename.match(/(SD-[0-9]{3}|sd-?[0-9]{3}|sd[0-9]{3})/i);
  const sdId = sdIdMatch ? sdIdMatch[1].toUpperCase() : null;

  // Determine script type
  let scriptType = 'unknown';
  let fromPhase = null;
  let toPhase = null;
  let phase = null;

  if (filename.includes('handoff')) {
    scriptType = 'handoff';
    if (filename.includes('lead-plan')) {
      fromPhase = 'LEAD';
      toPhase = 'PLAN';
    } else if (filename.includes('plan-exec')) {
      fromPhase = 'PLAN';
      toPhase = 'EXEC';
    } else if (filename.includes('exec-verification')) {
      fromPhase = 'EXEC';
      toPhase = 'VERIFICATION';
    }
  } else if (filename.includes('generate-prd')) {
    scriptType = 'prd';
    phase = 'PLAN';
  } else if (filename.includes('execute') && !filename.includes('handoff')) {
    scriptType = 'execute';
    phase = 'EXEC'; // Default to EXEC, but could be any phase
  }

  return {
    filename,
    sdId,
    scriptType,
    fromPhase,
    toPhase,
    phase,
    hasLeoProtocol: content.includes('LEO Protocol') || content.includes('leo-protocol')
  };
}

function generateMigrationCommand(analysis) {
  const { sdId, scriptType, fromPhase, toPhase, phase } = analysis;

  if (!sdId) {
    return `# Unable to extract SD ID from ${analysis.filename}`;
  }

  switch (scriptType) {
    case 'handoff':
      if (fromPhase && toPhase) {
        return `node templates/create-handoff.js ${fromPhase} ${toPhase} ${sdId}`;
      }
      return `# Handoff phases unclear for ${analysis.filename}`;

    case 'prd':
      return `node templates/generate-prd.js ${sdId}`;

    case 'execute':
      if (phase) {
        return `node templates/execute-phase.js ${phase} ${sdId}`;
      }
      return `# Phase unclear for ${analysis.filename} - try: node templates/execute-phase.js EXEC ${sdId}`;

    default:
      return `# Unknown script type for ${analysis.filename}`;
  }
}

async function createMigrationGuide() {
  console.log(chalk.blue.bold('ðŸ”„ SD Script Migration Analysis'));
  console.log(chalk.gray('â•'.repeat(60)));

  try {
    // Ensure migration directory exists
    await fs.mkdir(MIGRATION_DIR, { recursive: true });

    // Get all SD-specific scripts
    const allFiles = await fs.readdir(SCRIPT_DIR);
    const sdScripts = allFiles.filter(f =>
      f.match(/sd[0-9]|SD-[0-9]|generate-prd-sd|exec.*sd|plan.*sd|handoff.*sd/) &&
      f.endsWith('.js') &&
      !f.includes('template') &&
      !f.includes('migrate')
    );

    console.log(chalk.cyan(`\nðŸ“Š Found ${sdScripts.length} SD-specific scripts to migrate`));

    const analyses = [];
    const migrationCommands = [];

    // Analyze each script
    for (const script of sdScripts) {
      try {
        const analysis = await analyzeScript(script);
        analyses.push(analysis);

        const command = generateMigrationCommand(analysis);
        migrationCommands.push({
          original: script,
          command,
          sdId: analysis.sdId,
          type: analysis.scriptType
        });
      } catch (error) {
        console.log(chalk.yellow(`   âš ï¸  Could not analyze ${script}: ${error.message}`));
      }
    }

    // Group by type
    const byType = {
      handoff: migrationCommands.filter(m => m.type === 'handoff'),
      prd: migrationCommands.filter(m => m.type === 'prd'),
      execute: migrationCommands.filter(m => m.type === 'execute'),
      unknown: migrationCommands.filter(m => m.type === 'unknown')
    };

    console.log(chalk.cyan('\nðŸ“‹ Migration Summary:'));
    console.log(`   Handoff scripts: ${byType.handoff.length}`);
    console.log(`   PRD scripts: ${byType.prd.length}`);
    console.log(`   Execute scripts: ${byType.execute.length}`);
    console.log(`   Unknown/Manual: ${byType.unknown.length}`);

    // Generate migration script
    const migrationScript = `#!/bin/bash

# SD Script Migration Commands
# Generated by migrate-sd-scripts.js
# Run these commands to replace SD-specific scripts with template calls

echo "ðŸ”„ Migrating SD-specific scripts to template system..."
echo "======================================================="

# HANDOFF SCRIPTS
echo "ðŸ“‹ Migrating handoff scripts..."
${byType.handoff.map(m => `echo "Replacing ${m.original}..."
# ${m.command}`).join('\n')}

# PRD GENERATION SCRIPTS
echo "ðŸ“ Migrating PRD generation scripts..."
${byType.prd.map(m => `echo "Replacing ${m.original}..."
# ${m.command}`).join('\n')}

# EXECUTION SCRIPTS
echo "ðŸš€ Migrating execution scripts..."
${byType.execute.map(m => `echo "Replacing ${m.original}..."
# ${m.command}`).join('\n')}

${byType.unknown.length > 0 ? `
# MANUAL REVIEW NEEDED
echo "âš ï¸  Manual review needed for:"
${byType.unknown.map(m => `echo "  ${m.original} - ${m.command}"`).join('\n')}
` : ''}

echo "âœ… Migration commands generated!"
echo "ðŸ’¡ Remove '#' from commands above to execute them"
echo "ðŸ’¡ Test each template command before removing original scripts"
`;

    await fs.writeFile(path.join(MIGRATION_DIR, 'migration-commands.sh'), migrationScript);

    // Generate detailed analysis
    const detailedAnalysis = `# SD Script Migration Analysis
Generated: ${new Date().toISOString()}

## Summary
- Total scripts found: ${sdScripts.length}
- Handoff scripts: ${byType.handoff.length}
- PRD scripts: ${byType.prd.length}
- Execute scripts: ${byType.execute.length}
- Need manual review: ${byType.unknown.length}

## Migration Commands

### Handoff Scripts
${byType.handoff.map(m => `- \`${m.original}\` â†’ \`${m.command}\``).join('\n')}

### PRD Generation Scripts
${byType.prd.map(m => `- \`${m.original}\` â†’ \`${m.command}\``).join('\n')}

### Execution Scripts
${byType.execute.map(m => `- \`${m.original}\` â†’ \`${m.command}\``).join('\n')}

${byType.unknown.length > 0 ? `
### Manual Review Needed
${byType.unknown.map(m => `- \`${m.original}\` - ${m.command}`).join('\n')}
` : ''}

## Next Steps
1. Test template commands before removing originals
2. Update any automation that calls these scripts
3. Archive original scripts after validation
4. Update team documentation with new commands
`;

    await fs.writeFile(path.join(MIGRATION_DIR, 'migration-analysis.md'), detailedAnalysis);

    console.log(chalk.green('\nâœ… Migration files generated:'));
    console.log(`   ðŸ“„ ${MIGRATION_DIR}/migration-commands.sh`);
    console.log(`   ðŸ“„ ${MIGRATION_DIR}/migration-analysis.md`);

    console.log(chalk.cyan('\nðŸŽ¯ Recommended Actions:'));
    console.log('   1. Review migration commands in migration-commands.sh');
    console.log('   2. Test template commands with a few scripts first');
    console.log('   3. Update any automation calling these scripts');
    console.log('   4. Archive original scripts after validation');

    return {
      totalScripts: sdScripts.length,
      migrationCommands,
      byType
    };

  } catch (error) {
    console.error(chalk.red('âŒ Migration analysis failed:'), error.message);
    throw error;
  }
}

// Run migration analysis
createMigrationGuide()
  .then(result => {
    console.log(chalk.green.bold(`\nðŸŽ‰ Migration analysis complete! ${result.totalScripts} scripts analyzed.`));
  })
  .catch(error => {
    console.error(chalk.red('Fatal error:'), error);
    process.exit(1);
  });