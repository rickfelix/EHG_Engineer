/**
 * Placeholder Content Detection Gate for LEAD-TO-PLAN
 * SD-LEO-INFRA-PROTOCOL-FILE-STATE-001
 *
 * Warns when SD fields contain only default template text from leo-create-sd.js.
 * These placeholders pass validation gates but carry zero real information,
 * wasting the LEAD review phase.
 *
 * This gate issues WARNINGS only (does not block handoff).
 */

/**
 * Known placeholder patterns generated by buildDefaultStrategicObjectives(),
 * buildDefaultKeyChanges(), and buildDefaultSuccessCriteria() in leo-create-sd.js.
 *
 * Each pattern is a regex that matches the template text regardless of the
 * SD title interpolated into it.
 */
const PLACEHOLDER_PATTERNS = [
  // From buildDefaultStrategicObjectives()
  /^Implement .+ as specified in the SD scope$/,
  /^Maintain backward compatibility with existing functionality$/,
  /^Deliver user-facing value with clear acceptance criteria$/,
  /^Ensure comprehensive test coverage for new functionality$/,
  /^Address root cause to prevent recurrence$/,
  /^Improve code quality without changing external behavior$/,
  /^Eliminate identified security vulnerabilities$/,

  // From buildDefaultKeyChanges()
  /^Implement core changes for: .+$/,
  /^Add UI components or API endpoints as required$/,
  /^Add tests for new functionality$/,
  /^Update documentation for new feature$/,
  /^Fix identified defect and add regression test$/,
  /^Update related documentation if needed$/,
  /^Update infrastructure components$/,
  /^Verify deployment and operational readiness$/,
  /^Restructure code while preserving behavior$/,
  /^Add or update tests to verify no regressions$/,

  // From buildDefaultSuccessCriteria()
  /^All implementation items from scope are complete$/,
  /^Code passes lint and type checks$/,
  /^PR reviewed and approved$/,
  /^Root cause addressed, not just symptoms$/,
  /^Feature accessible to target users$/,
];

/**
 * Check if a string matches any known placeholder pattern.
 * @param {string} text - Text to check
 * @returns {boolean} True if the text matches a placeholder pattern
 */
export function isPlaceholderText(text) {
  if (!text || typeof text !== 'string') return false;
  const trimmed = text.trim();
  return PLACEHOLDER_PATTERNS.some(pattern => pattern.test(trimmed));
}

/**
 * Analyze an array field for placeholder content.
 * Returns the count and percentage of placeholder entries.
 *
 * @param {Array} items - Array of strings or objects with string values
 * @param {string} [textKey] - If items are objects, the key to check (e.g., 'change')
 * @returns {{ total: number, placeholders: number, percentage: number }}
 */
export function analyzePlaceholderContent(items, textKey) {
  if (!Array.isArray(items) || items.length === 0) {
    return { total: 0, placeholders: 0, percentage: 0 };
  }

  let total = 0;
  let placeholders = 0;

  for (const item of items) {
    const text = textKey && typeof item === 'object' ? item[textKey] : item;
    if (typeof text === 'string') {
      total++;
      if (isPlaceholderText(text)) {
        placeholders++;
      }
    }
  }

  return {
    total,
    placeholders,
    percentage: total > 0 ? Math.round((placeholders / total) * 100) : 0
  };
}

/**
 * Validate SD fields for placeholder content.
 *
 * Checks:
 * - strategic_objectives for template defaults
 * - key_changes for template defaults
 * - success_criteria for template defaults
 * - description for very short or generic text
 *
 * @param {Object} sd - Strategic Directive
 * @returns {Object} Validation result with warnings
 */
export async function validatePlaceholderContent(sd) {
  const warnings = [];
  let score = 100;

  console.log('   Checking for placeholder/template content...');

  // Check strategic_objectives
  const objectives = sd.strategic_objectives || [];
  const objAnalysis = analyzePlaceholderContent(objectives);
  if (objAnalysis.placeholders > 0) {
    const msg = `strategic_objectives: ${objAnalysis.placeholders}/${objAnalysis.total} entries are default templates (${objAnalysis.percentage}%)`;
    warnings.push(msg);
    console.log(`   âš ï¸  ${msg}`);
    score -= objAnalysis.percentage >= 100 ? 30 : 15;
  } else if (objAnalysis.total > 0) {
    console.log(`   âœ… strategic_objectives: ${objAnalysis.total} custom entries`);
  }

  // Check key_changes (may be objects with 'change' key)
  const changes = sd.key_changes || [];
  const changeAnalysis = analyzePlaceholderContent(changes, 'change');
  if (changeAnalysis.placeholders > 0) {
    const msg = `key_changes: ${changeAnalysis.placeholders}/${changeAnalysis.total} entries are default templates (${changeAnalysis.percentage}%)`;
    warnings.push(msg);
    console.log(`   âš ï¸  ${msg}`);
    score -= changeAnalysis.percentage >= 100 ? 30 : 15;
  } else if (changeAnalysis.total > 0) {
    console.log(`   âœ… key_changes: ${changeAnalysis.total} custom entries`);
  }

  // Check success_criteria
  const criteria = sd.success_criteria || [];
  const criteriaAnalysis = analyzePlaceholderContent(criteria);
  if (criteriaAnalysis.placeholders > 0) {
    const msg = `success_criteria: ${criteriaAnalysis.placeholders}/${criteriaAnalysis.total} entries are default templates (${criteriaAnalysis.percentage}%)`;
    warnings.push(msg);
    console.log(`   âš ï¸  ${msg}`);
    score -= criteriaAnalysis.percentage >= 100 ? 20 : 10;
  } else if (criteriaAnalysis.total > 0) {
    console.log(`   âœ… success_criteria: ${criteriaAnalysis.total} custom entries`);
  }

  // Check description length (very short descriptions are likely placeholders)
  const desc = sd.description || '';
  if (desc.length > 0 && desc.length < 50) {
    warnings.push(`description is very short (${desc.length} chars) - consider adding detail`);
    console.log(`   âš ï¸  description is very short (${desc.length} chars)`);
    score -= 10;
  } else if (desc.length > 0) {
    console.log(`   âœ… description has substance (${desc.length} chars)`);
  }

  const totalPlaceholders = objAnalysis.placeholders + changeAnalysis.placeholders + criteriaAnalysis.placeholders;
  if (totalPlaceholders === 0) {
    console.log('   âœ… No placeholder content detected');
  } else {
    console.log(`\n   âš ï¸  ${totalPlaceholders} placeholder(s) found - consider enriching SD before PLAN phase`);
  }

  return {
    pass: true, // Always pass - this is a warning-only gate
    score: Math.max(score, 50),
    max_score: 100,
    issues: [], // No blocking issues
    warnings
  };
}

/**
 * Create the placeholder content detection gate.
 *
 * @returns {Object} Gate configuration
 */
export function createPlaceholderContentGate() {
  return {
    name: 'GATE_PLACEHOLDER_CONTENT_DETECTION',
    validator: async (ctx) => {
      console.log('\nğŸ“ GATE: Placeholder Content Detection');
      console.log('-'.repeat(50));
      return validatePlaceholderContent(ctx.sd);
    },
    required: false, // Warning-only gate
    remediation: 'Enrich SD fields with specific, actionable content before proceeding to PLAN phase. Replace template text in strategic_objectives, key_changes, and success_criteria with real requirements.'
  };
}
