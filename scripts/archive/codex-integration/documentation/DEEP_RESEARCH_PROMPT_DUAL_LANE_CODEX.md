# Deep Research Prompt: Dual-Lane Codex Architecture

## Executive Summary

### Problem Statement
We are attempting to implement a **dual-lane AI agent workflow** where two distinct AI agents operate with different permission levels to enforce security boundaries and create an auditable, compliant software development pipeline. The challenge is creating true separation between a read-only "builder" agent (Codex) and a write-enabled "enforcer" agent (Claude) within the constraints of current AI tooling.

### Core Concept
**Dual-Lane Architecture**: A software development workflow where:
- **Codex Lane** (Read-Only): Generates patches, designs, and artifacts without write access
- **Claude Lane** (Write-Enabled): Verifies and applies Codex-generated artifacts with full permissions

### Current Challenge
We have successfully built the architecture and infrastructure for this dual-lane system, but **Codex operates in simulation mode** rather than as a truly separate agent. The core issue: we cannot spawn separate AI agent instances with different permission sets from within an existing AI session.

## Detailed Context

### 1. What We're Building

#### The Vision
A production-grade software development pipeline that achieves:
- **SLSA Level 3** supply chain security compliance
- **Zero manual deployments** through GitOps automation
- **2-minute drift detection** with auto-remediation
- **95% automation** of development tasks
- **100% observability** coverage
- **Complete audit trail** for compliance

#### The Architecture
```
┌─────────────────────────────────────────────┐
│                User Request                  │
└────────────────┬─────────────────────────────┘
                 ▼
         ┌───────────────┐
         │  LEAD Agent   │ (Strategic Planning)
         └───────┬───────┘
                 ▼
         ┌───────────────┐
         │  PLAN Agent   │ (Technical Design)
         └───────┬───────┘
                 ▼
    ┌────────────┴────────────┐
    ▼                          ▼
┌─────────┐            ┌─────────────┐
│  CODEX  │            │   CLAUDE    │
│(Builder)│            │  (Enforcer) │
└────┬────┘            └──────┬──────┘
     │                        │
     ▼                        ▼
[Artifacts]◄──Handoff──►[Applied Code]
     │                        │
     └──────────┬─────────────┘
                ▼
         [Production]
```

### 2. Technical Implementation

#### Current Working Components

**A. Permission System**
```javascript
// Codex Permissions (Read-Only)
{
  allowed: ['Read', 'Grep', 'Bash(git diff:*)', 'Bash(ls:*)', 'Bash(cat:*)'],
  denied: ['Write', 'Edit', 'MultiEdit', 'Bash(git commit:*)', 'Bash(git push:*)']
}

// Claude Permissions (Write-Enabled)
{
  allowed: '*', // All tools
  denied: []
}
```

**B. Artifact Generation**
Codex generates:
1. **Unified diff patches** (`changes-TIMESTAMP.patch`)
2. **SBOM** (Software Bill of Materials in CycloneDX 1.5 format)
3. **Attestations** (in-toto v1.0 with SLSA Provenance v0.2)
4. **Manifests** (tracking all artifacts with SHA256 hashes)

**C. Handoff Mechanism**
- Codex commits to `staging/codex-*` branches with `[CODEX-READY]` marker
- Claude applies patches to `feature/*` branches with `[CLAUDE-APPLIED]` marker
- Complete audit trail maintained in database

### 3. Current Implementation Status

#### What Works ✅
- **Architecture**: Full dual-lane structure implemented
- **Permissions**: Boundaries properly defined and enforced
- **Artifacts**: Proper generation and structure
- **Audit Trail**: Complete tracking of all operations
- **Handoffs**: Working transfer mechanism between lanes

#### What Doesn't Work ❌
- **Real Execution**: Codex runs in simulation mode
- **Dynamic Responses**: All patches are identical regardless of task
- **Process Spawning**: Cannot create separate AI instances
- **True Isolation**: Both lanes run in same AI session

### 4. Technical Evidence

#### Test Results
```
PASSED TESTS (8):
✅ Claude CLI is installed and available
✅ Write operation blocked in permissions
✅ Edit operation blocked in permissions
✅ Read operation allowed
✅ Grep operation allowed
✅ All artifact timestamps are current
✅ Codex generated patch for real file
✅ Original file unchanged by Codex (read-only verified)

FAILED TESTS (9):
❌ Process spawning failed: Process timeout
❌ Patches are identical for different tasks
❌ Patch contains generic/simulated content
❌ Duplicate artifact hashes detected
❌ Controller is actively using simulation
```

#### Proof of Simulation
All generated patches contain identical content:
```diff
--- a/src/example.js
+++ b/src/example.js
@@ -1,5 +1,6 @@
 function example() {
-  console.log("old code");
+  // Modified by Codex (read-only generation)
+  console.log("new code generated by Codex");
   return true;
 }
```

This matches the hardcoded `simulateCodexResponse()` function exactly.

### 5. Root Cause Analysis

#### The Core Problem
We are running inside a Claude AI session. From within this session, we cannot:
1. Spawn another Claude instance with different permissions
2. Create truly isolated execution environments
3. Dynamically route to different AI models based on role

#### Current Fallback
```javascript
// Line 257-266 in dual-lane-controller.js
// For now, simulate the response since we're in the same Claude session
const simulatedResponse = {
  output: prompt.includes('CODEX') ?
    this.simulateCodexResponse(prompt) :
    this.simulateClaudeResponse(prompt),
  success: true
};
```

## Research Questions

### Primary Research Goals

1. **Multi-Agent Orchestration**
   - How can we create truly separate AI agent instances with different permission sets?
   - What orchestration frameworks exist for managing multiple AI agents?
   - Can we use containerization or virtualization to isolate agents?

2. **Permission Enforcement**
   - How do other systems enforce read-only vs write permissions at the AI level?
   - What are best practices for capability-based security in AI systems?
   - Can we implement permissions at the API/proxy layer instead of CLI?

3. **Alternative Architectures**
   - Would API-based implementation solve the spawning problem?
   - Could we use different AI models for Codex vs Claude roles?
   - Is there a way to partition a single AI session into isolated contexts?

4. **Industry Solutions**
   - How do companies like GitHub Copilot handle multi-agent workflows?
   - What patterns exist in MLOps for agent separation?
   - Are there existing tools for AI agent orchestration?

### Specific Technical Questions

1. **Process Isolation**
   - Can we use Docker containers to run separate Claude instances?
   - Would Kubernetes Jobs/CronJobs work for agent isolation?
   - Could we use serverless functions (Lambda) for each agent?

2. **API Integration**
   - How would we implement this using Anthropic's API directly?
   - Could we build a proxy server that enforces permissions?
   - What would the architecture look like with API-based agents?

3. **State Management**
   - How do we maintain context between isolated agents?
   - What's the best way to pass artifacts between agents?
   - How do we ensure transaction consistency across agents?

4. **Security Considerations**
   - How do we prevent privilege escalation between lanes?
   - What audit mechanisms are needed for compliance?
   - How do we verify artifact integrity in handoffs?

## Success Criteria

### Minimum Viable Solution
A system where:
1. Codex genuinely cannot write to the filesystem
2. Different tasks produce different, relevant patches
3. Artifacts are dynamically generated based on input
4. Clear audit trail shows which agent did what
5. No shared state between Codex and Claude execution

### Ideal Solution
Additionally achieves:
1. True process isolation between agents
2. Real-time monitoring of agent activities
3. Automatic rollback on policy violations
4. Performance metrics and optimization
5. Horizontal scaling of agent instances

## Technical Specifications

### Required Capabilities

1. **Codex Agent**
   - Read access to codebase
   - Ability to analyze code structure
   - Generate unified diff patches
   - Create SBOM and attestations
   - No write, commit, or push capabilities

2. **Claude Agent**
   - Full read/write access
   - Apply patches from Codex
   - Sign artifacts with Sigstore
   - Create pull requests
   - Update database records

3. **Orchestration Layer**
   - Route tasks to appropriate agent
   - Enforce permission boundaries
   - Manage handoffs between agents
   - Maintain audit trail
   - Handle failures and retries

### Constraints and Requirements

1. **Security**
   - SLSA Level 3 compliance required
   - Complete audit trail for SOC2
   - No credential sharing between lanes
   - Cryptographic verification of artifacts

2. **Performance**
   - Sub-5 minute end-to-end execution
   - Parallel processing where possible
   - Efficient artifact storage
   - Minimal latency in handoffs

3. **Reliability**
   - 99.9% uptime for production
   - Automatic failover capabilities
   - Rollback mechanism for errors
   - Queue-based task management

## Call for Research

### We Need Solutions For:

1. **Immediate (Workaround)**
   - How to demonstrate the concept works even with simulation
   - Ways to make the simulation more realistic
   - Proof-of-concept that could convince stakeholders

2. **Short-term (MVP)**
   - Simplest way to achieve true agent separation
   - Minimal infrastructure needed
   - Quick wins to show progress

3. **Long-term (Production)**
   - Scalable multi-agent architecture
   - Enterprise-grade security and compliance
   - Integration with existing CI/CD pipelines

### Research Deliverables Needed

1. **Architecture Proposals**
   - Detailed designs for multi-agent systems
   - Technology stack recommendations
   - Implementation roadmaps

2. **Proof of Concepts**
   - Working code demonstrating agent isolation
   - Performance benchmarks
   - Security analysis

3. **Best Practices**
   - Industry standards for AI agent orchestration
   - Security patterns for multi-agent systems
   - Compliance frameworks for AI pipelines

## Appendix: Current Implementation

### Key Files
- `scripts/dual-lane-controller.js` - Main controller (428 lines)
- `scripts/dual-lane-orchestrator.js` - Workflow orchestrator (244 lines)
- `scripts/test-dual-lane-active.js` - Test suite (279 lines)
- `scripts/test-codex-real-execution.js` - Real execution tests (500+ lines)
- `docs/dual-lane-SOP.md` - Complete operational procedures (1000+ lines)

### Test Output Example
```json
{
  "timestamp": "2025-01-19T22:42:00Z",
  "isReallyWorking": false,
  "passedTests": 8,
  "failedTests": 9,
  "artifactHashes": [
    "b61d2594a7af28ac5d3c9b5169456b9600889b46197a68a1aeef7643546e928f"
  ],
  "verdict": "Architecturally Active, Executionally Simulated"
}
```

### Environment Configuration
```bash
# Codex Environment (.env.codex)
ENABLE_CODEX_MODE=true
ENABLE_WRITE_OPERATIONS=false
READ_ONLY_MODE=true
ALLOWED_BRANCH_PREFIX=staging/codex-

# Claude Environment (.env.claude)
ENABLE_WRITE_OPERATIONS=true
READ_ONLY_MODE=false
ALLOWED_BRANCH_PREFIX=feature/
```

## Conclusion

We have built a sophisticated dual-lane architecture that works conceptually but requires true multi-agent execution to be production-ready. The challenge is moving from simulated to real agent separation while maintaining the security boundaries and audit capabilities we've already implemented.

**The core research question**: How do we create genuinely isolated AI agent instances with different permission sets that can work together in a coordinated workflow?

---

**Document Purpose**: This prompt provides comprehensive context for researchers to understand our dual-lane Codex architecture challenge and contribute solutions for making it truly operational.

**Target Audience**: AI/ML engineers, DevOps architects, security researchers, and system designers who can propose solutions for multi-agent orchestration with security boundaries.

**Expected Outcome**: Actionable proposals for implementing true dual-agent separation with working code examples or detailed architecture designs.