#!/usr/bin/env node
/**
 * Event Catalog Generator
 * SD: SD-MAN-ORCH-VISION-HEAL-SCORE-93-002-01-A
 *
 * Generates a markdown event catalog from the schema registry
 * and handler registry, showing all event types, their schemas,
 * routing modes, and handler bindings.
 *
 * Usage: node scripts/generate-event-catalog.js [--output <path>]
 */

import { listSchemas, getSchema } from '../lib/eva/event-bus/event-schema-registry.js';
import { registerDefaultSchemas } from '../lib/eva/event-bus/event-schema-registry.js';
import { classifyRoutingMode, classifyModality } from '../lib/eva/event-bus/event-router.js';
import { listRegisteredTypes, getHandlers, getHandler } from '../lib/eva/event-bus/handler-registry.js';
import { initializeEventBus } from '../lib/eva/event-bus/index.js';
import fs from 'fs';
import path from 'path';

// Parse CLI args
const args = process.argv.slice(2);
const outputIdx = args.indexOf('--output');
const outputPath = outputIdx >= 0 ? args[outputIdx + 1] : path.join(process.cwd(), 'docs', 'reference', 'event-catalog.md');

async function generateCatalog() {
  // Register schemas (may already be registered if bus is initialized)
  registerDefaultSchemas();

  const schemas = listSchemas();
  const registeredTypes = listRegisteredTypes();

  // Combine all known event types
  const allTypes = new Set([
    ...schemas.map(s => s.eventType),
    ...registeredTypes,
  ]);

  const lines = [];
  lines.push('# EVA Event Bus Catalog');
  lines.push('');
  lines.push('> Auto-generated by `scripts/generate-event-catalog.js`');
  lines.push(`> Generated: ${new Date().toISOString()}`);
  lines.push('');
  lines.push('## Summary');
  lines.push('');
  lines.push(`- **Event Types**: ${allTypes.size}`);
  lines.push(`- **Schemas Registered**: ${schemas.reduce((acc, s) => acc + s.versions.length, 0)}`);
  lines.push(`- **Handlers Registered**: ${registeredTypes.length}`);
  lines.push('');
  lines.push('## Routing Modes');
  lines.push('');
  lines.push('| Mode | Description | Max Latency |');
  lines.push('|------|-------------|-------------|');
  lines.push('| EVENT | Immediate handler execution | 5ms |');
  lines.push('| ROUND | Cadence-based via master scheduler | 60s |');
  lines.push('| PRIORITY_QUEUE | Urgent governance via sub_agent_queue | 300s |');
  lines.push('');
  lines.push('## Event Types');
  lines.push('');

  const sorted = Array.from(allTypes).sort();

  for (const eventType of sorted) {
    const schema = getSchema(eventType);
    const handlers = getHandlers(eventType);
    const routingMode = classifyRoutingMode(eventType, {});
    const modality = classifyModality(eventType, {});

    lines.push(`### \`${eventType}\``);
    lines.push('');
    lines.push(`| Property | Value |`);
    lines.push(`|----------|-------|`);
    lines.push(`| Routing Mode | ${routingMode} |`);
    lines.push(`| Modality | ${modality} |`);
    lines.push(`| Schema Version | ${schema ? schema.version : 'none'} |`);
    lines.push(`| Handlers | ${handlers.length > 0 ? handlers.map(h => h.name).join(', ') : 'none'} |`);
    lines.push('');

    if (schema) {
      lines.push('**Required Fields:**');
      lines.push('');
      lines.push('| Field | Type |');
      lines.push('|-------|------|');
      for (const [field, type] of Object.entries(schema.schema.required)) {
        lines.push(`| \`${field}\` | ${type} |`);
      }
      lines.push('');

      if (schema.schema.optional && Object.keys(schema.schema.optional).length > 0) {
        lines.push('**Optional Fields:**');
        lines.push('');
        lines.push('| Field | Type |');
        lines.push('|-------|------|');
        for (const [field, type] of Object.entries(schema.schema.optional)) {
          lines.push(`| \`${field}\` | ${type} |`);
        }
        lines.push('');
      }
    }

    if (handlers.length > 0) {
      lines.push('**Handler Details:**');
      lines.push('');
      for (const h of handlers) {
        lines.push(`- **${h.name}**: retryable=${h.retryable}, maxRetries=${h.maxRetries}`);
      }
      lines.push('');
    }

    lines.push('---');
    lines.push('');
  }

  const content = lines.join('\n');

  // Ensure output directory exists
  const dir = path.dirname(outputPath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }

  fs.writeFileSync(outputPath, content, 'utf-8');
  console.log(`Event catalog generated: ${outputPath}`);
  console.log(`  Event types: ${allTypes.size}`);
  console.log(`  Schemas: ${schemas.reduce((acc, s) => acc + s.versions.length, 0)}`);
  console.log(`  Handlers: ${registeredTypes.length}`);
}

generateCatalog().catch(err => {
  console.error('Failed to generate event catalog:', err.message);
  process.exit(1);
});
