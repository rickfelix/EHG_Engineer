#!/usr/bin/env node
/**
 * Insert User Stories for SD-BLUEPRINT-ENGINE-001
 * Stage 1 Blueprint Engine v1 (Medium-Weight, Capability-Aware, Portfolio-Aware)
 *
 * Generated by: USER_STORY_CONTEXT_SUB_AGENT
 * Date: 2025-11-30
 */

import { createClient } from '@supabase/supabase-js';
import dotenv from 'dotenv';

dotenv.config();

const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_SERVICE_ROLE_KEY
);

const SD_ID = 'SD-BLUEPRINT-ENGINE-001';

const userStories = [
  // EPIC-001: Blueprint Browsing
  {
    story_key: 'US-BLUEPRINT-001',
    sd_id: SD_ID,
    title: 'Browse Intelligent Blueprints with Strategic Context',
    description: 'As Chairman, I want to browse a curated list of intelligent blueprints with strategic context so that I can quickly identify promising venture opportunities without manual research.',
    acceptance_criteria: JSON.stringify([
      'Given Chairman is authenticated AND on the Stage 1 venture creation page, When Chairman clicks "Browse Blueprints" button, Then System displays a grid/list of at least 10 blueprints AND each blueprint shows title, category, and summary AND page loads in under 2 seconds',
      'Given Blueprint list is displayed, When Chairman views any blueprint card, Then Card shows blueprint title AND category/industry AND 1-2 sentence description AND capability alignment score (0-100) AND portfolio alignment score (0-100) AND visual indicator for overall fit',
      'Given Blueprint list is displayed, When Chairman selects a category filter, Then List updates to show only blueprints in selected category AND filter state is visually indicated AND "Clear filter" option is available',
      'Given Blueprint list is displayed, When Chairman selects "Sort by Portfolio Fit", Then List reorders with highest portfolio alignment scores at top AND sort direction can be toggled',
      'Given Chairman is on Stage 1 page, When Blueprint API returns error, Then User sees friendly error message AND retry button is displayed AND error is logged to system'
    ]),
    priority: 'must_have',
    story_points: 5,
    status: 'pending',
    epic: 'Blueprint Browsing',
    implementation_context: 'Create BlueprintBrowser component with card grid layout. Use existing ventures table structure as reference. Blueprint data stored in new "blueprints" table with capability_score and portfolio_score columns calculated via database functions. Consider pagination for performance (limit 20 per page).',
    architecture_references: JSON.stringify([
      'database/migrations/20251130_ehg_app_schema_migration.sql - ventures table structure',
      'Existing card grid patterns in venture list components',
      'Supabase real-time subscription pattern for live updates'
    ]),
    example_code_patterns: JSON.stringify([
      {
        pattern: 'Blueprint fetch query',
        code: 'const { data: blueprints, error } = await supabase.from("blueprints").select("*, capability_score, portfolio_score").order("portfolio_score", { ascending: false }).limit(20);'
      }
    ]),
    testing_scenarios: JSON.stringify([
      { id: 'TC-001-1', scenario: 'Verify blueprint list renders with required fields', priority: 'P0' },
      { id: 'TC-001-2', scenario: 'Verify filtering by category works', priority: 'P1' },
      { id: 'TC-001-3', scenario: 'Verify sorting by alignment score', priority: 'P1' },
      { id: 'TC-001-4', scenario: 'Verify error handling on API failure', priority: 'P1' }
    ]),
    e2e_test_path: 'tests/e2e/blueprint-engine/US-001-browse-blueprints.spec.ts'
  },
  {
    story_key: 'US-BLUEPRINT-002',
    sd_id: SD_ID,
    title: 'View Capability Alignment Scores',
    description: 'As Chairman, I want to see capability alignment scores for each blueprint so that I can understand if EHG has the skills and resources to build this venture successfully.',
    acceptance_criteria: JSON.stringify([
      'Given Blueprint card is displayed, When Chairman views the capability alignment section, Then Score is shown as percentage (0-100%) AND visual gauge/bar indicates score level AND tooltip explains what capability alignment means',
      'Given Blueprint card with capability score is visible, When Chairman hovers over or clicks the capability score, Then Popup/tooltip shows breakdown: Technical Skills match (%), Resource Availability (%), Historical Success Rate (%)',
      'Given Blueprint has capability score below 50%, When Chairman views the blueprint card, Then Warning indicator (yellow/red) is shown AND tooltip explains risk factors AND "View Details" links to specific capability gaps',
      'Given Blueprint exists but capability assessment not completed, When Chairman views the blueprint card, Then Shows "Assessment Pending" badge AND "Request Assessment" button is available'
    ]),
    priority: 'must_have',
    story_points: 3,
    status: 'pending',
    epic: 'Blueprint Browsing',
    implementation_context: 'Capability score is calculated by comparing blueprint requirements against EHG registered capabilities. Score calculation: (matched_capabilities / required_capabilities) * 100, weighted by importance. Display using radial progress component.',
    architecture_references: JSON.stringify([
      'database/migrations/20251130_ehg_app_schema_migration.sql - companies.settings JSONB for capability storage',
      'Consider creating "ehg_capabilities" table for more structured capability tracking'
    ]),
    example_code_patterns: JSON.stringify([
      {
        pattern: 'Capability score calculation (database function)',
        code: 'CREATE OR REPLACE FUNCTION calculate_capability_score(blueprint_id UUID) RETURNS DECIMAL...'
      }
    ]),
    testing_scenarios: JSON.stringify([
      { id: 'TC-002-1', scenario: 'Verify capability score displays correctly', priority: 'P0' },
      { id: 'TC-002-2', scenario: 'Verify score breakdown popup', priority: 'P1' },
      { id: 'TC-002-3', scenario: 'Verify low score warning display', priority: 'P1' }
    ]),
    e2e_test_path: 'tests/e2e/blueprint-engine/US-002-capability-scores.spec.ts'
  },
  {
    story_key: 'US-BLUEPRINT-003',
    sd_id: SD_ID,
    title: 'View Portfolio Alignment Scores',
    description: 'As Chairman, I want to see portfolio alignment scores for each blueprint so that I can understand if this venture fills a strategic gap in my portfolio.',
    acceptance_criteria: JSON.stringify([
      'Given Blueprint card is displayed AND Chairman has existing ventures in portfolio, When Chairman views the portfolio alignment section, Then Score is shown as percentage (0-100%) AND visual indicator shows gap-filling potential AND color coding indicates strategic fit',
      'Given Blueprint card with portfolio score is visible, When Chairman clicks on portfolio score for details, Then Modal shows: Industry Diversity Impact (%), Revenue Model Diversity (%), Risk Profile Balance (%)',
      'Given Blueprint fills a portfolio gap, When Chairman views portfolio score details, Then System highlights which specific gap this blueprint addresses AND shows "Gap Filled" badge',
      'Given Chairman has no existing ventures, When Chairman views portfolio alignment scores, Then All blueprints show 100% portfolio fit AND informational message explains this'
    ]),
    priority: 'must_have',
    story_points: 5,
    status: 'pending',
    epic: 'Blueprint Browsing',
    implementation_context: 'Portfolio alignment calculated by analyzing current portfolio composition vs. blueprint attributes. Use portfolio gap analysis function. Consider: industry distribution, stage distribution, risk profile distribution.',
    architecture_references: JSON.stringify([
      'database/migrations/20251130_ehg_app_schema_migration.sql - portfolios table',
      'database/migrations/20251130_ehg_app_schema_migration.sql - ventures table with industry, risk_score fields'
    ]),
    example_code_patterns: JSON.stringify([
      {
        pattern: 'Portfolio gap analysis query',
        code: 'WITH current_portfolio AS (SELECT industry, COUNT(*) as count FROM ventures WHERE portfolio_id = $1 AND status = "active" GROUP BY industry)...'
      }
    ]),
    testing_scenarios: JSON.stringify([
      { id: 'TC-003-1', scenario: 'Verify portfolio score with existing ventures', priority: 'P0' },
      { id: 'TC-003-2', scenario: 'Verify portfolio score with empty portfolio', priority: 'P1' },
      { id: 'TC-003-3', scenario: 'Verify gap identification display', priority: 'P1' }
    ]),
    e2e_test_path: 'tests/e2e/blueprint-engine/US-003-portfolio-scores.spec.ts'
  },
  // EPIC-002: Scaffold Preview
  {
    story_key: 'US-BLUEPRINT-004',
    sd_id: SD_ID,
    title: 'Preview Scaffold Content Before Selection',
    description: 'As Chairman, I want to preview the full scaffold content before selecting a blueprint so that I understand exactly what I am getting and can make an informed decision.',
    acceptance_criteria: JSON.stringify([
      'Given Chairman is viewing blueprint list, When Chairman clicks "Preview" button on a blueprint card, Then Full-screen modal opens AND displays complete scaffold content AND modal has clear close button',
      'Given Preview modal is open, When Chairman views the Problem Framing tab/section, Then Shows: Problem Statement (2-3 sentences) AND Target Customer Profile AND Pain Points (bulleted list) AND Current Alternatives',
      'Given Preview modal is open, When Chairman views the Market Hypothesis tab/section, Then Shows: Market Size Estimate (TAM/SAM/SOM) AND Growth Rate Projection AND Key Assumptions AND Validation Approach',
      'Given Preview modal is open, When Chairman views the Competitors tab/section, Then Shows: List of 3-5 key competitors AND Competitive positioning matrix AND Differentiation opportunities',
      'Given Preview modal is open, When Chairman navigates between sections, Then Tab navigation allows switching between sections AND current section is highlighted'
    ]),
    priority: 'must_have',
    story_points: 5,
    status: 'pending',
    epic: 'Scaffold Preview',
    implementation_context: 'Create BlueprintPreviewModal component with tabbed navigation. Scaffold content stored in "blueprint_scaffolds" table with JSONB content field. Tabs: Overview, Problem Framing, Market Hypothesis, Competitors, Technical Requirements. Use shadcn/ui Dialog and Tabs components.',
    architecture_references: JSON.stringify([
      'shadcn/ui Dialog component for modal',
      'shadcn/ui Tabs component for section navigation'
    ]),
    example_code_patterns: JSON.stringify([
      {
        pattern: 'Preview modal structure',
        code: '<Dialog open={previewOpen} onOpenChange={setPreviewOpen}><DialogContent className="max-w-4xl max-h-[90vh] overflow-y-auto">...</DialogContent></Dialog>'
      }
    ]),
    testing_scenarios: JSON.stringify([
      { id: 'TC-004-1', scenario: 'Verify preview modal opens on click', priority: 'P0' },
      { id: 'TC-004-2', scenario: 'Verify all scaffold sections display', priority: 'P0' },
      { id: 'TC-004-3', scenario: 'Verify tab navigation works', priority: 'P1' }
    ]),
    e2e_test_path: 'tests/e2e/blueprint-engine/US-004-scaffold-preview.spec.ts'
  },
  {
    story_key: 'US-BLUEPRINT-005',
    sd_id: SD_ID,
    title: 'View Scaffold Head Start Content',
    description: 'As Chairman, I want to see problem framing, market hypothesis, and competitor analysis in the preview so that I have a head start on Stage 2 research when I select a blueprint.',
    acceptance_criteria: JSON.stringify([
      'Given Preview modal is open on Problem Framing section, When Chairman reviews the content, Then Problem statement is specific and actionable AND includes quantified impact where possible AND ready to copy/paste into venture form',
      'Given Preview modal is open on Market Hypothesis section, When Chairman reviews the content, Then Market size includes source citations or estimation methodology AND key assumptions are listed with validation suggestions',
      'Given Preview modal is open on Competitors section, When Chairman reviews the content, Then Each competitor has: Name, Website, Key Features, Weaknesses AND positioning opportunities are highlighted',
      'Given Chairman is viewing any scaffold section, When Chairman clicks "Copy Section" button, Then Section content is copied to clipboard AND toast confirms successful copy'
    ]),
    priority: 'should_have',
    story_points: 3,
    status: 'pending',
    epic: 'Scaffold Preview',
    implementation_context: 'Ensure scaffold content is pre-populated with high-quality, research-ready content. Include source references where applicable. Add "Copy" buttons to each section. Content should be structured to reduce Stage 2 research time by 40%.',
    architecture_references: JSON.stringify([
      'Content should match ventures table fields for easy population'
    ]),
    example_code_patterns: JSON.stringify([
      {
        pattern: 'Copy to clipboard handler',
        code: 'const copyToClipboard = async (content: string, section: string) => { await navigator.clipboard.writeText(content); toast.success(`${section} copied to clipboard`); };'
      }
    ]),
    testing_scenarios: JSON.stringify([
      { id: 'TC-005-1', scenario: 'Verify content quality metrics', priority: 'P1' },
      { id: 'TC-005-2', scenario: 'Verify copy to clipboard works', priority: 'P1' }
    ]),
    e2e_test_path: 'tests/e2e/blueprint-engine/US-005-head-start-content.spec.ts'
  },
  // EPIC-003: Blueprint Selection
  {
    story_key: 'US-BLUEPRINT-006',
    sd_id: SD_ID,
    title: 'Select Blueprint and Populate Venture',
    description: 'As Chairman, I want to select a blueprint and have it automatically populate my new venture so that I save time and do not need to manually enter scaffold information.',
    acceptance_criteria: JSON.stringify([
      'Given Chairman is viewing a blueprint, When Chairman clicks "Select Blueprint" or "Start Venture" button, Then New venture is created in "draft_idea" stage AND venture fields populated from blueprint scaffold AND Chairman is redirected to venture detail page',
      'Given Chairman selects a blueprint, When Venture is created, Then Blueprint.title -> venture.name AND Blueprint.problem_framing -> venture.problem_statement AND source_blueprint_id is set',
      'Given Chairman clicks "Select Blueprint", When Selection is initiated, Then Confirmation dialog shows: Blueprint name, Fields that will be populated, "Confirm" and "Cancel" buttons',
      'Given Chairman confirms blueprint selection, When Database insert fails, Then Error message is shown AND Chairman stays on blueprint page AND can retry',
      'Given Venture is successfully created from blueprint, When Creation completes, Then Venture.source_blueprint_id = blueprint.id AND blueprint.selection_count is incremented'
    ]),
    priority: 'must_have',
    story_points: 5,
    status: 'pending',
    epic: 'Blueprint Selection',
    implementation_context: 'Use ventures table from EHG schema. Set source_blueprint_id to track origin. Increment blueprint.selection_count for popularity tracking. Create venture in "draft_idea" stage. Ensure proper RLS for venture creation.',
    architecture_references: JSON.stringify([
      'database/migrations/20251130_ehg_app_schema_migration.sql - ventures table with source_blueprint_id column'
    ]),
    example_code_patterns: JSON.stringify([
      {
        pattern: 'Venture creation from blueprint',
        code: 'const createVentureFromBlueprint = async (blueprintId: string, portfolioId: string) => { const { data: blueprint } = await supabase.from("blueprints").select("*").eq("id", blueprintId).single(); ... };'
      }
    ]),
    testing_scenarios: JSON.stringify([
      { id: 'TC-006-1', scenario: 'Verify venture creation from blueprint', priority: 'P0' },
      { id: 'TC-006-2', scenario: 'Verify field mapping is correct', priority: 'P0' },
      { id: 'TC-006-3', scenario: 'Verify source_blueprint_id tracking', priority: 'P1' },
      { id: 'TC-006-4', scenario: 'Verify error handling on creation failure', priority: 'P1' }
    ]),
    e2e_test_path: 'tests/e2e/blueprint-engine/US-006-select-blueprint.spec.ts'
  },
  {
    story_key: 'US-BLUEPRINT-007',
    sd_id: SD_ID,
    title: 'Track Blueprint Selection for System Learning',
    description: 'As Chairman, I want my blueprint selection to be tracked so that the system learns my preferences and improves future recommendations.',
    acceptance_criteria: JSON.stringify([
      'Given Chairman selects a blueprint, When Venture is created successfully, Then Selection event is logged with: user_id, blueprint_id, timestamp, portfolio_id, session_duration',
      'Given Chairman selects a blueprint, When Event is logged, Then Context includes: blueprints_viewed_before_selection, filters_applied, sort_order_used, time_spent_previewing',
      'Given Chairman uses blueprint browser for first time, When Page loads, Then Unobtrusive notice explains: "Your interactions help improve recommendations" AND link to preferences is available'
    ]),
    priority: 'should_have',
    story_points: 3,
    status: 'pending',
    epic: 'Blueprint Selection',
    implementation_context: 'Create "blueprint_interactions" table to store all user events. Use this data for preference learning (US-008, US-009). Events: view, expand, select. Include session context for better ML training data.',
    architecture_references: JSON.stringify([
      'Consider pattern from database/schema/009_context_learning_schema.sql for context tracking'
    ]),
    example_code_patterns: JSON.stringify([
      {
        pattern: 'Selection event tracking',
        code: 'const trackSelection = async (blueprintId: string, context: SelectionContext) => { await supabase.from("blueprint_interactions").insert({ user_id: currentUser.id, blueprint_id: blueprintId, event_type: "selected", event_context: {...} }); };'
      }
    ]),
    testing_scenarios: JSON.stringify([
      { id: 'TC-007-1', scenario: 'Verify selection event is logged', priority: 'P0' },
      { id: 'TC-007-2', scenario: 'Verify context data is captured', priority: 'P1' }
    ]),
    e2e_test_path: 'tests/e2e/blueprint-engine/US-007-selection-tracking.spec.ts'
  },
  // EPIC-004: Preference Learning
  {
    story_key: 'US-BLUEPRINT-008',
    sd_id: SD_ID,
    title: 'Capture View, Expand, and Select Signals',
    description: 'As System, I want to capture user interaction signals (view, expand, select) so that I can learn Chairman preferences and improve recommendations.',
    acceptance_criteria: JSON.stringify([
      'Given Blueprint card is rendered in viewport, When Card is visible for more than 2 seconds, Then View event is logged with: blueprint_id, viewport_position, timestamp',
      'Given Chairman clicks to preview a blueprint, When Preview modal opens, Then Expand event is logged with: blueprint_id, previous_views_count, expand_duration',
      'Given Chairman confirms blueprint selection, When Venture is created, Then Select event is logged with weight=1.0 AND includes full interaction history for session',
      'Given Chairman views blueprint preview, When Chairman closes preview without selecting (after 10+ seconds), Then Skip event is logged with weight=-0.3',
      'Given Chairman rapidly scrolls through list, When Multiple blueprints flash in viewport, Then Only blueprints viewed for >2s are logged AND system debounces rapid scroll events'
    ]),
    priority: 'should_have',
    story_points: 5,
    status: 'pending',
    epic: 'Preference Learning',
    implementation_context: 'Use Intersection Observer API for view tracking. Implement client-side debouncing to reduce noise. Batch events and send to server every 30 seconds or on page unload. Store in "blueprint_interactions" table with event_type and signal_weight columns.',
    architecture_references: JSON.stringify([
      'Intersection Observer API for viewport detection',
      'Consider pattern from analytics/tracking systems'
    ]),
    example_code_patterns: JSON.stringify([
      {
        pattern: 'View tracking with Intersection Observer',
        code: 'const observer = new IntersectionObserver((entries) => { entries.forEach(entry => { if (entry.isIntersecting) { const timer = setTimeout(() => { trackView(entry.target.dataset.blueprintId); }, 2000); ... } }); }, { threshold: 0.5 });'
      }
    ]),
    testing_scenarios: JSON.stringify([
      { id: 'TC-008-1', scenario: 'Verify view event after 2s visibility', priority: 'P0' },
      { id: 'TC-008-2', scenario: 'Verify expand event on preview', priority: 'P0' },
      { id: 'TC-008-3', scenario: 'Verify skip signal on conscious rejection', priority: 'P1' },
      { id: 'TC-008-4', scenario: 'Verify debounce prevents noise', priority: 'P1' }
    ]),
    e2e_test_path: 'tests/e2e/blueprint-engine/US-008-signal-capture.spec.ts'
  },
  {
    story_key: 'US-BLUEPRINT-009',
    sd_id: SD_ID,
    title: 'Aggregate Preference Data for Recommendation Improvement',
    description: 'As System, I want to aggregate preference data across interactions so that future blueprint recommendations improve based on Chairman patterns.',
    acceptance_criteria: JSON.stringify([
      'Given User interaction events exist in database, When Daily aggregation job runs (midnight), Then User preference profile is updated with: category_preferences, complexity_preferences, industry_preferences',
      'Given User has interacted with blueprints, When Preferences are calculated, Then Score = SUM(signal_weight * recency_decay) for each category AND scores are normalized to 0-100 range',
      'Given New user with no interaction history, When Preferences are requested, Then System falls back to global popularity scores AND returns "cold_start: true" flag',
      'Given User has old interaction data (>30 days), When Preferences are recalculated, Then Older interactions have reduced weight AND very old data (>90 days) is excluded from calculation'
    ]),
    priority: 'could_have',
    story_points: 8,
    status: 'pending',
    epic: 'Preference Learning',
    implementation_context: 'Create database function or scheduled job for aggregation. Store preferences in "user_blueprint_preferences" table. Use time-weighted scoring with exponential decay. Consider using Supabase edge functions or pg_cron for scheduling.',
    architecture_references: JSON.stringify([
      'database/schema/009_context_learning_schema.sql for learning patterns',
      'Consider pg_cron extension for scheduling'
    ]),
    example_code_patterns: JSON.stringify([
      {
        pattern: 'Preference aggregation function',
        code: 'CREATE OR REPLACE FUNCTION aggregate_user_preferences(p_user_id UUID) RETURNS VOID AS $$ DECLARE decay_factor CONSTANT DECIMAL := 0.95; BEGIN INSERT INTO user_blueprint_preferences (user_id, category, preference_score, updated_at) SELECT p_user_id, b.category, SUM(i.signal_weight * POWER(decay_factor, EXTRACT(DAY FROM NOW() - i.created_at))), NOW() FROM blueprint_interactions i JOIN blueprints b ON i.blueprint_id = b.id WHERE i.user_id = p_user_id AND i.created_at > NOW() - INTERVAL "90 days" GROUP BY b.category ON CONFLICT (user_id, category) DO UPDATE SET preference_score = EXCLUDED.preference_score, updated_at = NOW(); END; $$ LANGUAGE plpgsql;'
      }
    ]),
    testing_scenarios: JSON.stringify([
      { id: 'TC-009-1', scenario: 'Verify daily aggregation runs', priority: 'P1' },
      { id: 'TC-009-2', scenario: 'Verify preference scores are normalized', priority: 'P1' },
      { id: 'TC-009-3', scenario: 'Verify cold start fallback', priority: 'P1' },
      { id: 'TC-009-4', scenario: 'Verify old data is excluded', priority: 'P2' }
    ]),
    e2e_test_path: 'tests/e2e/blueprint-engine/US-009-preference-aggregation.spec.ts'
  },
  // EPIC-005: Portfolio Awareness
  {
    story_key: 'US-BLUEPRINT-010',
    sd_id: SD_ID,
    title: 'Evaluate Blueprints Against Portfolio Gaps',
    description: 'As System, I want to evaluate each blueprint against current portfolio gaps so that recommendations prioritize strategic gap-filling opportunities.',
    acceptance_criteria: JSON.stringify([
      'Given User has existing ventures in portfolio, When Blueprint list is loaded, Then Each blueprint has portfolio_gap_score calculated AND score indicates how well blueprint fills identified gaps',
      'Given Portfolio has 3 tech ventures, 0 healthcare ventures, When Gap analysis runs, Then Healthcare blueprints receive higher gap scores AND tech blueprints receive lower scores (diminishing returns)',
      'Given Portfolio has mostly early-stage ventures, When Gap analysis runs, Then Blueprints targeting later stages receive higher gap scores AND provides stage balance',
      'Given Portfolio is heavily weighted to high-risk ventures, When Gap analysis runs, Then Lower-risk blueprints receive higher gap scores AND helps balance portfolio risk',
      'Given Blueprints have been scored for gaps, When Default sort is applied, Then Blueprints are sorted by composite score: (0.4 * capability) + (0.4 * portfolio_gap) + (0.2 * preference)'
    ]),
    priority: 'must_have',
    story_points: 8,
    status: 'pending',
    epic: 'Portfolio Awareness',
    implementation_context: 'Create database function "calculate_portfolio_gap_score(blueprint_id, portfolio_id)". Analyze: industry distribution, stage distribution, risk profile distribution, revenue model diversity. Higher gap = more valuable. Cache scores and refresh on portfolio change.',
    architecture_references: JSON.stringify([
      'database/migrations/20251130_ehg_app_schema_migration.sql - ventures table for portfolio analysis',
      'database/migrations/20251130_ehg_app_schema_migration.sql - portfolios table'
    ]),
    example_code_patterns: JSON.stringify([
      {
        pattern: 'Portfolio gap analysis function',
        code: 'CREATE OR REPLACE FUNCTION calculate_portfolio_gap_score(p_blueprint_id UUID, p_portfolio_id UUID) RETURNS DECIMAL AS $$ DECLARE industry_gap DECIMAL; stage_gap DECIMAL; risk_gap DECIMAL; total_ventures INT; blueprint_industry TEXT; BEGIN ... RETURN (industry_gap * 0.5) + (stage_gap * 0.3) + (risk_gap * 0.2); END; $$ LANGUAGE plpgsql;'
      }
    ]),
    testing_scenarios: JSON.stringify([
      { id: 'TC-010-1', scenario: 'Verify gap score calculation', priority: 'P0' },
      { id: 'TC-010-2', scenario: 'Verify industry gap boosts underrepresented industries', priority: 'P0' },
      { id: 'TC-010-3', scenario: 'Verify composite sort order', priority: 'P1' }
    ]),
    e2e_test_path: 'tests/e2e/blueprint-engine/US-010-gap-evaluation.spec.ts'
  },
  {
    story_key: 'US-BLUEPRINT-011',
    sd_id: SD_ID,
    title: 'Flag Cannibalization Risks',
    description: 'As System, I want to flag blueprints that may cannibalize existing ventures so that Chairman is informed of potential conflicts before selection.',
    acceptance_criteria: JSON.stringify([
      'Given Blueprint targets same industry and market as existing venture, When Cannibalization analysis runs, Then Cannibalization risk flag is set AND risk score calculated (0-100) AND affected venture(s) identified',
      'Given Blueprint has cannibalization risk > 50, When Blueprint card is displayed, Then Warning badge shows on card AND tooltip lists affected ventures AND "View Conflict" link available',
      'Given Chairman clicks "View Conflict" on cannibalization warning, When Conflict modal opens, Then Shows: Blueprint vs Existing Venture comparison AND overlapping target markets AND potential revenue impact AND mitigation suggestions',
      'Given Blueprint has cannibalization warning, When Chairman clicks "Select Blueprint", Then Additional confirmation shows warning AND requires explicit acknowledgment AND logs informed decision',
      'Given Blueprint is in same industry but targets different segment, When Cannibalization analysis runs, Then Low or no cannibalization risk flagged AND system recognizes complementary positioning'
    ]),
    priority: 'should_have',
    story_points: 5,
    status: 'pending',
    epic: 'Portfolio Awareness',
    implementation_context: 'Create cannibalization detection function that compares: industry, target_market, value_proposition, pricing_tier. Use text similarity or embedding comparison for value_proposition matching. Cache results per portfolio composition.',
    architecture_references: JSON.stringify([
      'database/migrations/20251130_ehg_app_schema_migration.sql - ventures with industry, target_market fields',
      'Consider using pg_trgm extension for text similarity'
    ]),
    example_code_patterns: JSON.stringify([
      {
        pattern: 'Cannibalization risk calculation',
        code: 'CREATE OR REPLACE FUNCTION calculate_cannibalization_risk(p_blueprint_id UUID, p_portfolio_id UUID) RETURNS TABLE(venture_id UUID, venture_name TEXT, risk_score DECIMAL, overlap_factors JSONB) AS $$ BEGIN RETURN QUERY SELECT v.id, v.name, (CASE WHEN v.industry = b.industry THEN 40 ELSE 0 END + CASE WHEN similarity(v.target_market, b.target_market) > 0.5 THEN 30 ELSE 0 END + ...)::DECIMAL as risk_score, jsonb_build_object(...) FROM ventures v CROSS JOIN blueprints b WHERE v.portfolio_id = p_portfolio_id AND b.id = p_blueprint_id AND v.status = "active" ORDER BY risk_score DESC; END; $$ LANGUAGE plpgsql;'
      }
    ]),
    testing_scenarios: JSON.stringify([
      { id: 'TC-011-1', scenario: 'Verify cannibalization detected for overlapping ventures', priority: 'P0' },
      { id: 'TC-011-2', scenario: 'Verify warning badge displays', priority: 'P0' },
      { id: 'TC-011-3', scenario: 'Verify conflict modal shows details', priority: 'P1' },
      { id: 'TC-011-4', scenario: 'Verify complementary ventures do not trigger false positives', priority: 'P1' }
    ]),
    e2e_test_path: 'tests/e2e/blueprint-engine/US-011-cannibalization-flags.spec.ts'
  },
  {
    story_key: 'US-BLUEPRINT-012',
    sd_id: SD_ID,
    title: 'Strategic Recommendation Summary',
    description: 'As Chairman, I want to see a strategic recommendation summary for each blueprint so that I can quickly understand the overall strategic fit.',
    acceptance_criteria: JSON.stringify([
      'Given Blueprint card is displayed, When Chairman views the card, Then Strategic fit badge shows: "Highly Recommended", "Recommended", "Consider", or "Caution" AND badge color matches recommendation level',
      'Given Strategic badge is displayed, When Chairman hovers over badge, Then Tooltip shows: Top 3 reasons for recommendation AND key score breakdown AND potential concerns if any',
      'Given Blueprint has all scores calculated, When Strategic recommendation is determined, Then Score = weighted average: 35% portfolio_gap + 35% capability_fit + 20% preference_match + 10% popularity AND cannibalization penalty applied if flagged',
      'Given Chairman views blueprint details, When Recommendation section is displayed, Then Shows personalized text: "This blueprint is {recommendation} because it {top_reason} and aligns with your preference for {preference_type}"'
    ]),
    priority: 'should_have',
    story_points: 5,
    status: 'pending',
    epic: 'Portfolio Awareness',
    implementation_context: 'Create composite scoring function that combines all signals. Generate human-readable recommendation text based on score breakdown. Use template strings with dynamic substitution.',
    architecture_references: JSON.stringify([
      'US-002, US-003, US-010, US-011 provide input scores'
    ]),
    example_code_patterns: JSON.stringify([
      {
        pattern: 'Strategic recommendation generation',
        code: 'const generateRecommendation = (blueprint: BlueprintWithScores): Recommendation => { let score = (blueprint.portfolio_gap_score * 0.35 + blueprint.capability_score * 0.35 + blueprint.preference_score * 0.20 + blueprint.popularity_score * 0.10); if (blueprint.cannibalization_risk > 50) { score -= 20; } const level = score >= 80 ? "highly_recommended" : score >= 60 ? "recommended" : score >= 40 ? "consider" : "caution"; ... return { level, score, reasons, text: generateText(level, reasons) }; };'
      }
    ]),
    testing_scenarios: JSON.stringify([
      { id: 'TC-012-1', scenario: 'Verify badge displays correct level', priority: 'P0' },
      { id: 'TC-012-2', scenario: 'Verify tooltip shows reasoning', priority: 'P1' },
      { id: 'TC-012-3', scenario: 'Verify cannibalization penalty applies', priority: 'P1' },
      { id: 'TC-012-4', scenario: 'Verify personalized text generation', priority: 'P2' }
    ]),
    e2e_test_path: 'tests/e2e/blueprint-engine/US-012-strategic-summary.spec.ts'
  }
];

async function insertUserStories() {
  console.log('='.repeat(60));
  console.log('User Story Insertion for SD-BLUEPRINT-ENGINE-001');
  console.log('='.repeat(60));
  console.log(`Total stories to insert: ${userStories.length}`);
  console.log('');

  // Verify SD exists
  const { data: sd, error: sdError } = await supabase
    .from('strategic_directives_v2')
    .select('id, title, status')
    .eq('id', SD_ID)
    .single();

  if (sdError || !sd) {
    console.error(`ERROR: SD ${SD_ID} not found in database`);
    console.error('Please ensure the SD exists before inserting user stories.');
    process.exit(1);
  }

  console.log(`Found SD: ${sd.title}`);
  console.log(`Status: ${sd.status}`);
  console.log('');

  // Check for existing stories
  const { data: existingStories, error: existingError } = await supabase
    .from('user_stories')
    .select('story_key')
    .eq('sd_id', SD_ID);

  if (existingStories && existingStories.length > 0) {
    console.log(`WARNING: Found ${existingStories.length} existing stories for this SD`);
    console.log('Existing keys:', existingStories.map(s => s.story_key).join(', '));
    console.log('');

    // Delete existing stories for clean insert
    const { error: deleteError } = await supabase
      .from('user_stories')
      .delete()
      .eq('sd_id', SD_ID);

    if (deleteError) {
      console.error('Failed to delete existing stories:', deleteError.message);
      process.exit(1);
    }
    console.log('Deleted existing stories for clean insert.');
    console.log('');
  }

  // Insert stories
  let successCount = 0;
  let errorCount = 0;
  const errors = [];

  for (const story of userStories) {
    const { data, error } = await supabase
      .from('user_stories')
      .insert(story)
      .select()
      .single();

    if (error) {
      errorCount++;
      errors.push({ story_key: story.story_key, error: error.message });
      console.log(`[FAIL] ${story.story_key}: ${error.message}`);
    } else {
      successCount++;
      console.log(`[OK] ${story.story_key}: ${story.title}`);
    }
  }

  console.log('');
  console.log('='.repeat(60));
  console.log('Summary');
  console.log('='.repeat(60));
  console.log(`Successfully inserted: ${successCount}/${userStories.length}`);
  console.log(`Failed: ${errorCount}/${userStories.length}`);

  if (errors.length > 0) {
    console.log('');
    console.log('Errors:');
    errors.forEach(e => console.log(`  - ${e.story_key}: ${e.error}`));
  }

  // Store sub-agent execution result
  const executionResult = {
    sd_id: SD_ID,
    sub_agent_id: 'stories-sub',
    sub_agent_name: 'User Story Context Engineering',
    execution_type: 'user_story_generation',
    status: errorCount === 0 ? 'success' : 'partial_success',
    result: JSON.stringify({
      epics_count: 5,
      stories_count: userStories.length,
      stories_inserted: successCount,
      stories_failed: errorCount,
      confidence_score: 92,
      success_criteria_mapping: {
        'SC-001': ['US-BLUEPRINT-001', 'US-BLUEPRINT-002', 'US-BLUEPRINT-003', 'US-BLUEPRINT-008', 'US-BLUEPRINT-009'],
        'SC-002': ['US-BLUEPRINT-004', 'US-BLUEPRINT-005'],
        'SC-003': ['US-BLUEPRINT-010', 'US-BLUEPRINT-011', 'US-BLUEPRINT-012'],
        'SC-004': ['US-BLUEPRINT-001', 'US-BLUEPRINT-002', 'US-BLUEPRINT-003', 'US-BLUEPRINT-004', 'US-BLUEPRINT-005', 'US-BLUEPRINT-006', 'US-BLUEPRINT-007']
      },
      total_story_points: userStories.reduce((sum, s) => sum + s.story_points, 0)
    }),
    errors: errors.length > 0 ? JSON.stringify(errors) : null,
    started_at: new Date().toISOString(),
    completed_at: new Date().toISOString()
  };

  const { error: resultError } = await supabase
    .from('sub_agent_execution_results')
    .insert(executionResult);

  if (resultError) {
    console.log('');
    console.log('WARNING: Failed to store execution result:', resultError.message);
  } else {
    console.log('');
    console.log('Execution result stored in sub_agent_execution_results table.');
  }

  console.log('');
  console.log('User Story Generation Complete!');
  console.log(`Total Story Points: ${userStories.reduce((sum, s) => sum + s.story_points, 0)}`);
}

insertUserStories().catch(console.error);
