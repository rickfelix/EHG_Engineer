#!/usr/bin/env node
/**
 * Insert User Stories for SD-ARCH-EHG-005
 * Governance API Integration - Connect Governance Mode UI to Database
 *
 * Generated by STORIES sub-agent following v2.0.0 guidelines:
 * - INVEST criteria validated
 * - Given-When-Then acceptance criteria format
 * - Rich implementation context
 * - Architecture references included
 *
 * PRD: PRD-ARCH-EHG-005
 * SD UUID: ebfddfeb-8c4f-4de4-a00d-107db9d9cb07
 *
 * Functional Requirements Coverage:
 * - FR-001: Stage Contracts API
 * - FR-002: Supervision Policies API
 * - FR-003: Compliance Overview API
 * - FR-004: Audit Log API
 * - FR-005: LEO Protocol Status API
 * - UI-001 to UI-006: Replace mock data with real hooks
 */

import { createClient } from '@supabase/supabase-js';
import dotenv from 'dotenv';

dotenv.config();

const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_SERVICE_ROLE_KEY
);

const SD_ID = 'ebfddfeb-8c4f-4de4-a00d-107db9d9cb07';
const SD_KEY = 'SD-ARCH-EHG-005';
const PRD_ID = 'PRD-ARCH-EHG-005';

// ============================================================================
// USER STORIES DEFINITION
// ============================================================================

const userStories = [
  // ============================================================================
  // US-001: Stage Contracts API (FR-001)
  // ============================================================================
  {
    story_key: `${SD_KEY}:US-001`,
    title: 'Stage Contracts API Endpoint',
    user_role: 'governance administrator',
    user_want: 'fetch stage data contracts from the database via API',
    user_benefit: 'view the actual contract definitions that govern each IDEATION stage instead of hardcoded mock data',
    story_points: 3,
    priority: 'must_have',
    status: 'draft',
    acceptance_criteria: [
      {
        id: 'AC-001-1',
        scenario: 'Happy path - fetch all stage contracts',
        given: 'stage_data_contracts table contains records for stages 1-6',
        when: 'GET /api/governance/stage-contracts is called',
        then: 'API returns array of all stage contracts with id, stage_number, contract_name, input_schema, output_schema, and version fields'
      },
      {
        id: 'AC-001-2',
        scenario: 'Filter by stage number',
        given: 'API called with stage_number query parameter',
        when: 'GET /api/governance/stage-contracts?stage_number=3 is called',
        then: 'API returns only contracts for stage 3'
      },
      {
        id: 'AC-001-3',
        scenario: 'Empty database handling',
        given: 'stage_data_contracts table is empty',
        when: 'GET /api/governance/stage-contracts is called',
        then: 'API returns empty array [] with 200 status, not error'
      },
      {
        id: 'AC-001-4',
        scenario: 'Database error handling',
        given: 'Database connection fails',
        when: 'GET /api/governance/stage-contracts is called',
        then: 'API returns 500 status with error message, no sensitive details leaked'
      }
    ],
    definition_of_done: [
      'API endpoint created at pages/api/governance/stage-contracts.ts',
      'TypeScript types defined for StageContract interface',
      'Supabase query fetches from stage_data_contracts table',
      'Unit tests for API handler with >80% coverage',
      'E2E test verifying endpoint returns valid data'
    ],
    technical_notes: 'Follow existing pattern from pages/api/leo/metrics.ts. Use Supabase client with service role key for server-side queries.',
    implementation_approach: 'Create Next.js API route with GET handler. Query stage_data_contracts table. Support optional stage_number filter parameter.',
    implementation_context: JSON.stringify({
      files: ['pages/api/governance/stage-contracts.ts'],
      dependencies: ['@supabase/supabase-js'],
      database_tables: ['stage_data_contracts'],
      patterns: ['Next.js API route pattern from pages/api/leo/metrics.ts']
    }),
    architecture_references: JSON.stringify([
      'pages/api/leo/metrics.ts - API handler pattern',
      'database/schema/stage_data_contracts - table schema'
    ]),
    example_code_patterns: JSON.stringify([
      {
        pattern: 'Supabase query with optional filter',
        code: `let query = supabase.from('stage_data_contracts').select('*');
if (stageNumber) query = query.eq('stage_number', stageNumber);
const { data, error } = await query;`
      }
    ]),
    testing_scenarios: JSON.stringify([
      { id: 'TS-001-1', scenario: 'Fetch all contracts', expected: '6 stage contracts returned' },
      { id: 'TS-001-2', scenario: 'Filter stage 1', expected: 'Only stage 1 contract returned' },
      { id: 'TS-001-3', scenario: 'Empty table', expected: 'Empty array, 200 status' }
    ]),
    maps_to_requirement: 'FR-001'
  },

  // ============================================================================
  // US-002: Supervision Policies API (FR-002)
  // ============================================================================
  {
    story_key: `${SD_KEY}:US-002`,
    title: 'Supervision Policies API Endpoint',
    user_role: 'governance administrator',
    user_want: 'fetch LEO supervision policies from the database via API',
    user_benefit: 'view the actual supervision rules that govern protocol compliance instead of mock placeholder data',
    story_points: 3,
    priority: 'must_have',
    status: 'draft',
    acceptance_criteria: [
      {
        id: 'AC-002-1',
        scenario: 'Happy path - fetch all policies',
        given: 'leo_supervision_policies table contains active policies',
        when: 'GET /api/governance/supervision-policies is called',
        then: 'API returns array of policies with id, policy_name, phase, rule_type, threshold, action, and is_active fields'
      },
      {
        id: 'AC-002-2',
        scenario: 'Filter by phase',
        given: 'API called with phase query parameter',
        when: 'GET /api/governance/supervision-policies?phase=PLAN is called',
        then: 'API returns only policies applicable to PLAN phase'
      },
      {
        id: 'AC-002-3',
        scenario: 'Filter active only',
        given: 'API called with active_only=true parameter',
        when: 'GET /api/governance/supervision-policies?active_only=true is called',
        then: 'API returns only policies where is_active=true'
      },
      {
        id: 'AC-002-4',
        scenario: 'Include policy metadata',
        given: 'Policies have metadata JSONB field',
        when: 'GET /api/governance/supervision-policies is called',
        then: 'Response includes metadata field for each policy'
      }
    ],
    definition_of_done: [
      'API endpoint created at pages/api/governance/supervision-policies.ts',
      'TypeScript types defined for SupervisionPolicy interface',
      'Supports phase and active_only query parameters',
      'Unit tests with >80% coverage',
      'E2E test verifying endpoint returns valid data'
    ],
    technical_notes: 'leo_supervision_policies table contains rules for LEO Protocol enforcement. Policies define thresholds, actions (warn, block, escalate), and applicable phases.',
    implementation_approach: 'Create Next.js API route. Query leo_supervision_policies with optional filters. Return typed response.',
    implementation_context: JSON.stringify({
      files: ['pages/api/governance/supervision-policies.ts'],
      dependencies: ['@supabase/supabase-js'],
      database_tables: ['leo_supervision_policies'],
      patterns: ['Filtered query pattern with multiple optional parameters']
    }),
    architecture_references: JSON.stringify([
      'pages/api/leo/metrics.ts - API handler pattern',
      'database/migrations/20251128_leo_v433_ui_parity_governance.sql - policy context'
    ]),
    testing_scenarios: JSON.stringify([
      { id: 'TS-002-1', scenario: 'Fetch all policies', expected: 'All policies returned' },
      { id: 'TS-002-2', scenario: 'Filter PLAN phase', expected: 'Only PLAN policies returned' },
      { id: 'TS-002-3', scenario: 'Active only filter', expected: 'Only is_active=true policies' }
    ]),
    maps_to_requirement: 'FR-002'
  },

  // ============================================================================
  // US-003: Compliance Overview API (FR-003)
  // ============================================================================
  {
    story_key: `${SD_KEY}:US-003`,
    title: 'Compliance Overview API Endpoint',
    user_role: 'governance administrator',
    user_want: 'fetch aggregated governance overview metrics from a database view via API',
    user_benefit: 'see a dashboard summary of protocol compliance status across all SDs and PRDs',
    story_points: 5,
    priority: 'must_have',
    status: 'draft',
    acceptance_criteria: [
      {
        id: 'AC-003-1',
        scenario: 'Happy path - fetch overview metrics',
        given: 'v_governance_overview view contains aggregated metrics',
        when: 'GET /api/governance/overview is called',
        then: 'API returns compliance metrics including total_sds, compliant_sds, violation_count, gate_pass_rate, and recent_activity'
      },
      {
        id: 'AC-003-2',
        scenario: 'Include time-based breakdown',
        given: 'Overview includes temporal metrics',
        when: 'GET /api/governance/overview is called',
        then: 'Response includes metrics_by_day for last 7 days with date, compliance_rate, and activity_count'
      },
      {
        id: 'AC-003-3',
        scenario: 'Include phase distribution',
        given: 'SDs are distributed across LEAD, PLAN, EXEC phases',
        when: 'GET /api/governance/overview is called',
        then: 'Response includes phase_distribution with count per phase'
      },
      {
        id: 'AC-003-4',
        scenario: 'View not exists fallback',
        given: 'v_governance_overview view does not exist',
        when: 'GET /api/governance/overview is called',
        then: 'API returns 503 with message indicating view needs to be created, not 500 error'
      }
    ],
    definition_of_done: [
      'API endpoint created at pages/api/governance/overview.ts',
      'TypeScript types defined for GovernanceOverview interface',
      'Queries v_governance_overview materialized view',
      'Includes fallback if view not found',
      'Unit tests with >80% coverage',
      'E2E test verifying dashboard integration'
    ],
    technical_notes: 'v_governance_overview is a materialized view aggregating metrics from story_drafts, leo_gate_reviews, governance_audit_log, and compliance_alerts tables.',
    implementation_approach: 'Create API route querying materialized view. If view missing, return structured error with creation instructions.',
    implementation_context: JSON.stringify({
      files: ['pages/api/governance/overview.ts'],
      dependencies: ['@supabase/supabase-js'],
      database_tables: ['v_governance_overview (view)'],
      patterns: ['Materialized view query', 'Graceful degradation for missing views']
    }),
    architecture_references: JSON.stringify([
      'pages/api/leo/metrics.ts - aggregated metrics pattern',
      'database/views/ - view creation patterns'
    ]),
    testing_scenarios: JSON.stringify([
      { id: 'TS-003-1', scenario: 'Fetch overview', expected: 'Aggregated metrics returned' },
      { id: 'TS-003-2', scenario: 'View missing', expected: '503 with setup instructions' },
      { id: 'TS-003-3', scenario: 'Empty data', expected: 'Zeros for all metrics, not errors' }
    ]),
    maps_to_requirement: 'FR-003'
  },

  // ============================================================================
  // US-004: Audit Log API (FR-004)
  // ============================================================================
  {
    story_key: `${SD_KEY}:US-004`,
    title: 'Audit Log API Endpoint with Pagination',
    user_role: 'governance administrator',
    user_want: 'fetch governance audit logs with pagination and filtering',
    user_benefit: 'review historical changes to PRDs, SDs, and compliance events without loading entire log history',
    story_points: 5,
    priority: 'must_have',
    status: 'draft',
    acceptance_criteria: [
      {
        id: 'AC-004-1',
        scenario: 'Happy path - fetch paginated audit logs',
        given: 'governance_audit_log table contains 100+ entries',
        when: 'GET /api/governance/audit-logs?page=1&limit=20 is called',
        then: 'API returns first 20 logs ordered by created_at DESC with total_count and has_more metadata'
      },
      {
        id: 'AC-004-2',
        scenario: 'Filter by entity type',
        given: 'Audit logs exist for PRDs, SDs, and handoffs',
        when: 'GET /api/governance/audit-logs?entity_type=prd is called',
        then: 'API returns only PRD-related audit entries'
      },
      {
        id: 'AC-004-3',
        scenario: 'Filter by date range',
        given: 'Audit logs span multiple months',
        when: 'GET /api/governance/audit-logs?start_date=2025-01-01&end_date=2025-01-31 is called',
        then: 'API returns only logs within the specified date range'
      },
      {
        id: 'AC-004-4',
        scenario: 'Default pagination limits',
        given: 'No limit parameter provided',
        when: 'GET /api/governance/audit-logs is called',
        then: 'API defaults to limit=50 and page=1'
      },
      {
        id: 'AC-004-5',
        scenario: 'Max limit enforcement',
        given: 'Client requests limit=1000',
        when: 'GET /api/governance/audit-logs?limit=1000 is called',
        then: 'API caps limit at 100 to prevent excessive data transfer'
      }
    ],
    definition_of_done: [
      'API endpoint created at pages/api/governance/audit-logs.ts',
      'TypeScript types for AuditLogEntry and PaginatedResponse',
      'Pagination with page, limit, total_count, has_more',
      'Filtering by entity_type, start_date, end_date',
      'Default and max limit enforcement',
      'Unit tests with >80% coverage',
      'E2E test verifying pagination works'
    ],
    technical_notes: 'governance_audit_log table has RLS policies allowing anon INSERT for triggers. Queries should use service role for reads.',
    implementation_approach: 'Create paginated API with offset-based pagination. Apply filters via Supabase query builder. Include total_count for UI pagination controls.',
    implementation_context: JSON.stringify({
      files: ['pages/api/governance/audit-logs.ts'],
      dependencies: ['@supabase/supabase-js'],
      database_tables: ['governance_audit_log'],
      patterns: ['Offset pagination', 'Count query with filters', 'Date range filtering']
    }),
    architecture_references: JSON.stringify([
      'database/migrations/2025-11-07_add_anon_insert_governance_audit_log.sql - RLS context',
      'Supabase range() for pagination'
    ]),
    example_code_patterns: JSON.stringify([
      {
        pattern: 'Paginated query with count',
        code: `const { data, error, count } = await supabase
  .from('governance_audit_log')
  .select('*', { count: 'exact' })
  .order('created_at', { ascending: false })
  .range(offset, offset + limit - 1);`
      }
    ]),
    testing_scenarios: JSON.stringify([
      { id: 'TS-004-1', scenario: 'Page 1 of logs', expected: 'First 20 logs, has_more=true' },
      { id: 'TS-004-2', scenario: 'Filter entity_type', expected: 'Only matching entries' },
      { id: 'TS-004-3', scenario: 'Date range filter', expected: 'Only logs in range' },
      { id: 'TS-004-4', scenario: 'Excessive limit', expected: 'Capped at 100' }
    ]),
    maps_to_requirement: 'FR-004'
  },

  // ============================================================================
  // US-005: LEO Protocol Status API (FR-005)
  // ============================================================================
  {
    story_key: `${SD_KEY}:US-005`,
    title: 'LEO Protocol Status API Endpoint',
    user_role: 'governance administrator',
    user_want: 'fetch the current LEO Protocol version and phase status via API',
    user_benefit: 'see which protocol version is active and the current operational phase without checking configuration files',
    story_points: 3,
    priority: 'must_have',
    status: 'draft',
    acceptance_criteria: [
      {
        id: 'AC-005-1',
        scenario: 'Happy path - fetch active protocol',
        given: 'leo_protocols table has one active protocol version',
        when: 'GET /api/governance/protocol-status is called',
        then: 'API returns active protocol with id, version, status, title, description, and created_at'
      },
      {
        id: 'AC-005-2',
        scenario: 'Include section count',
        given: 'Active protocol has associated sections in leo_protocol_sections',
        when: 'GET /api/governance/protocol-status is called',
        then: 'Response includes section_count showing number of protocol sections'
      },
      {
        id: 'AC-005-3',
        scenario: 'Include phase counts',
        given: 'SDs exist in various phases',
        when: 'GET /api/governance/protocol-status is called',
        then: 'Response includes phase_status with counts for LEAD, PLAN, EXEC phases'
      },
      {
        id: 'AC-005-4',
        scenario: 'No active protocol',
        given: 'No protocol has status=active',
        when: 'GET /api/governance/protocol-status is called',
        then: 'API returns 404 with message indicating no active protocol found'
      }
    ],
    definition_of_done: [
      'API endpoint created at pages/api/governance/protocol-status.ts',
      'TypeScript types for ProtocolStatus interface',
      'Fetches active protocol from leo_protocols table',
      'Includes section count and phase distribution',
      'Unit tests with >80% coverage',
      'E2E test verifying protocol version display'
    ],
    technical_notes: 'Active protocol is determined by status=active in leo_protocols table. Only one protocol should be active at a time.',
    implementation_approach: 'Query leo_protocols for active status. Join with section count. Aggregate phase counts from story_drafts.',
    implementation_context: JSON.stringify({
      files: ['pages/api/governance/protocol-status.ts'],
      dependencies: ['@supabase/supabase-js'],
      database_tables: ['leo_protocols', 'leo_protocol_sections', 'story_drafts'],
      patterns: ['Single record fetch', 'Count aggregation']
    }),
    architecture_references: JSON.stringify([
      'database/migrations/20251128_leo_v433_ui_parity_governance.sql - protocol structure',
      'scripts/generate-claude-md-from-db.js - protocol version context'
    ]),
    testing_scenarios: JSON.stringify([
      { id: 'TS-005-1', scenario: 'Fetch active protocol', expected: 'v4.3.3 returned' },
      { id: 'TS-005-2', scenario: 'Section count', expected: 'Count matches leo_protocol_sections' },
      { id: 'TS-005-3', scenario: 'No active protocol', expected: '404 error' }
    ]),
    maps_to_requirement: 'FR-005'
  },

  // ============================================================================
  // US-006: React Hooks for Governance Data (UI-001 to UI-006)
  // ============================================================================
  {
    story_key: `${SD_KEY}:US-006`,
    title: 'React Hooks for Governance API Integration',
    user_role: 'frontend developer',
    user_want: 'use React Query hooks to fetch governance data with loading, error, and empty states',
    user_benefit: 'replace mock data in governance UI components with real database data using consistent patterns',
    story_points: 5,
    priority: 'must_have',
    status: 'draft',
    acceptance_criteria: [
      {
        id: 'AC-006-1',
        scenario: 'useStageContracts hook',
        given: 'Stage Contracts API is available',
        when: 'useStageContracts() hook is called in a component',
        then: 'Hook returns { data, isLoading, error } with typed StageContract[] data'
      },
      {
        id: 'AC-006-2',
        scenario: 'useSupervisionPolicies hook',
        given: 'Supervision Policies API is available',
        when: 'useSupervisionPolicies({ phase: "PLAN" }) hook is called',
        then: 'Hook returns filtered policies with loading and error states'
      },
      {
        id: 'AC-006-3',
        scenario: 'useGovernanceOverview hook',
        given: 'Compliance Overview API is available',
        when: 'useGovernanceOverview() hook is called',
        then: 'Hook returns overview metrics with automatic refetch on interval'
      },
      {
        id: 'AC-006-4',
        scenario: 'useAuditLogs hook with pagination',
        given: 'Audit Log API supports pagination',
        when: 'useAuditLogs({ page: 2, limit: 20 }) hook is called',
        then: 'Hook returns paginated logs with total_count and has_more for pagination UI'
      },
      {
        id: 'AC-006-5',
        scenario: 'useProtocolStatus hook',
        given: 'Protocol Status API is available',
        when: 'useProtocolStatus() hook is called',
        then: 'Hook returns current protocol version and phase status'
      }
    ],
    definition_of_done: [
      'Hooks created in src/hooks/governance/ directory',
      'All hooks use React Query (TanStack Query) pattern',
      'TypeScript types for all return values',
      'Stale time and cache time configured appropriately',
      'Loading, error, and empty state handling documented',
      'Unit tests for each hook with >80% coverage'
    ],
    technical_notes: 'Use React Query with fetch API for client-side data fetching. Configure staleTime based on data volatility (audit logs = shorter, contracts = longer).',
    implementation_approach: 'Create hooks using useQuery pattern. Export from index.ts barrel file. Configure query keys for cache invalidation.',
    implementation_context: JSON.stringify({
      files: [
        'src/hooks/governance/useStageContracts.ts',
        'src/hooks/governance/useSupervisionPolicies.ts',
        'src/hooks/governance/useGovernanceOverview.ts',
        'src/hooks/governance/useAuditLogs.ts',
        'src/hooks/governance/useProtocolStatus.ts',
        'src/hooks/governance/index.ts'
      ],
      dependencies: ['@tanstack/react-query'],
      patterns: ['React Query useQuery pattern', 'Query key factory pattern']
    }),
    architecture_references: JSON.stringify([
      '@tanstack/react-query documentation',
      'Existing hook patterns in codebase'
    ]),
    example_code_patterns: JSON.stringify([
      {
        pattern: 'React Query hook with types',
        code: `export function useStageContracts(stageNumber?: number) {
  return useQuery<StageContract[], Error>({
    queryKey: ['governance', 'stage-contracts', stageNumber],
    queryFn: () => fetch(\`/api/governance/stage-contracts\${stageNumber ? \`?stage_number=\${stageNumber}\` : ''}\`).then(r => r.json()),
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
}`
      }
    ]),
    testing_scenarios: JSON.stringify([
      { id: 'TS-006-1', scenario: 'Hook loading state', expected: 'isLoading=true initially' },
      { id: 'TS-006-2', scenario: 'Hook success state', expected: 'data populated, isLoading=false' },
      { id: 'TS-006-3', scenario: 'Hook error state', expected: 'error populated, data undefined' },
      { id: 'TS-006-4', scenario: 'Pagination hook', expected: 'Returns page metadata' }
    ]),
    maps_to_requirement: 'UI-001,UI-002,UI-003,UI-004,UI-005,UI-006'
  },

  // ============================================================================
  // US-007: E2E Tests for Governance API Integration
  // ============================================================================
  {
    story_key: `${SD_KEY}:US-007`,
    title: 'E2E Tests for Governance API and UI Integration',
    user_role: 'developer',
    user_want: 'automated E2E tests verifying governance mode displays real database data',
    user_benefit: 'catch regressions where UI reverts to mock data or API integration breaks',
    story_points: 5,
    priority: 'must_have',
    status: 'draft',
    acceptance_criteria: [
      {
        id: 'AC-007-1',
        scenario: 'Stage contracts display test',
        given: 'Stage contracts exist in database',
        when: 'E2E test navigates to governance contracts page',
        then: 'Test verifies contracts are displayed with correct stage numbers and names'
      },
      {
        id: 'AC-007-2',
        scenario: 'Supervision policies display test',
        given: 'Policies exist in database',
        when: 'E2E test navigates to governance policies page',
        then: 'Test verifies policies display with phase and rule type visible'
      },
      {
        id: 'AC-007-3',
        scenario: 'Audit log pagination test',
        given: 'More than 20 audit log entries exist',
        when: 'E2E test clicks pagination controls',
        then: 'Test verifies page changes and new entries are displayed'
      },
      {
        id: 'AC-007-4',
        scenario: 'Protocol status display test',
        given: 'Active protocol v4.3.3 exists',
        when: 'E2E test views protocol status section',
        then: 'Test verifies version 4.3.3 is displayed'
      },
      {
        id: 'AC-007-5',
        scenario: 'Loading state verification',
        given: 'API has artificial delay',
        when: 'E2E test loads governance page',
        then: 'Test verifies loading indicators appear before data'
      }
    ],
    definition_of_done: [
      'E2E tests created at tests/e2e/governance-api-integration.spec.ts',
      'Tests follow US-XXX naming convention for mapping',
      'Coverage for all 5 API endpoints',
      'Loading and error state tests included',
      'Tests pass in CI/CD pipeline'
    ],
    technical_notes: 'Use Playwright for E2E tests. Tests should verify actual data from database, not mocked responses.',
    implementation_approach: 'Create Playwright spec file with test.describe blocks for each API endpoint. Use page.waitForResponse to verify API calls.',
    implementation_context: JSON.stringify({
      files: ['tests/e2e/governance-api-integration.spec.ts'],
      dependencies: ['@playwright/test'],
      patterns: ['Playwright test patterns', 'API response verification']
    }),
    architecture_references: JSON.stringify([
      'tests/e2e/ - existing E2E test patterns',
      'Playwright test documentation'
    ]),
    example_code_patterns: JSON.stringify([
      {
        pattern: 'API response verification',
        code: `test('US-001: Stage contracts display', async ({ page }) => {
  const responsePromise = page.waitForResponse('/api/governance/stage-contracts');
  await page.goto('/governance/contracts');
  const response = await responsePromise;
  expect(response.status()).toBe(200);
  const data = await response.json();
  expect(data.length).toBeGreaterThan(0);
});`
      }
    ]),
    testing_scenarios: JSON.stringify([
      { id: 'TS-007-1', scenario: 'All endpoints return 200', expected: 'No API errors' },
      { id: 'TS-007-2', scenario: 'Data displays in UI', expected: 'Real data visible' },
      { id: 'TS-007-3', scenario: 'Pagination works', expected: 'Page changes correctly' }
    ]),
    maps_to_requirement: 'FR-001,FR-002,FR-003,FR-004,FR-005'
  }
];

// ============================================================================
// INSERT FUNCTION
// ============================================================================

async function insertUserStories() {
  console.log('='.repeat(70));
  console.log('STORIES Sub-Agent: User Story Generation for SD-ARCH-EHG-005');
  console.log('='.repeat(70));
  console.log('');
  console.log('SD: SD-ARCH-EHG-005 - Governance API Integration');
  console.log('PRD: PRD-ARCH-EHG-005');
  console.log('SD UUID: ' + SD_ID);
  console.log('Total Stories: ' + userStories.length);
  console.log('Total Story Points: ' + userStories.reduce((sum, s) => sum + s.story_points, 0));
  console.log('');

  // Verify SD exists
  const { data: sd, error: sdError } = await supabase
    .from('story_drafts')
    .select('id, sd_key, title, status')
    .eq('id', SD_ID)
    .single();

  if (sdError || !sd) {
    console.error('ERROR: SD not found with ID:', SD_ID);
    console.error('Error:', sdError?.message);
    process.exit(1);
  }

  console.log('Verified SD:', sd.sd_key, '-', sd.title);
  console.log('SD Status:', sd.status);
  console.log('');

  // Check if stories already exist
  const { data: existing, error: checkError } = await supabase
    .from('user_stories')
    .select('story_key')
    .eq('sd_id', SD_ID);

  if (checkError) {
    console.error('Error checking existing stories:', checkError.message);
    process.exit(1);
  }

  if (existing && existing.length > 0) {
    console.log(`WARNING: ${existing.length} stories already exist for ${SD_KEY}`);
    console.log('Existing stories:', existing.map(s => s.story_key).join(', '));
    console.log('');

    const readline = await import('readline');
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });

    const answer = await new Promise(resolve => {
      rl.question('Delete existing stories and insert new ones? (yes/no): ', resolve);
    });
    rl.close();

    if (answer.toLowerCase() === 'yes') {
      const { error: deleteError } = await supabase
        .from('user_stories')
        .delete()
        .eq('sd_id', SD_ID);

      if (deleteError) {
        console.error('Error deleting existing stories:', deleteError.message);
        process.exit(1);
      }
      console.log('Deleted existing stories.');
      console.log('');
    } else {
      console.log('Aborting. No changes made.');
      process.exit(0);
    }
  }

  // Insert stories
  console.log('Inserting user stories...');
  console.log('');

  let successCount = 0;
  let errorCount = 0;

  for (const story of userStories) {
    const insertData = {
      sd_id: SD_ID,
      prd_id: PRD_ID,
      story_key: story.story_key,
      title: story.title,
      user_role: story.user_role,
      user_want: story.user_want,
      user_benefit: story.user_benefit,
      story_points: story.story_points,
      priority: story.priority,
      status: story.status,
      acceptance_criteria: story.acceptance_criteria,
      definition_of_done: story.definition_of_done,
      technical_notes: story.technical_notes,
      implementation_approach: story.implementation_approach,
      implementation_context: story.implementation_context,
      architecture_references: story.architecture_references,
      example_code_patterns: story.example_code_patterns || null,
      testing_scenarios: story.testing_scenarios || null,
      created_by: 'STORIES',
      validation_status: 'pending',
      e2e_test_status: 'not_created'
    };

    const { error } = await supabase
      .from('user_stories')
      .insert(insertData);

    if (error) {
      console.error(`  ERROR: ${story.story_key} - ${error.message}`);
      errorCount++;
    } else {
      console.log(`  OK: ${story.story_key} - ${story.title}`);
      successCount++;
    }
  }

  console.log('');
  console.log('='.repeat(70));
  console.log('SUMMARY');
  console.log('='.repeat(70));
  console.log(`Inserted: ${successCount} stories`);
  console.log(`Errors: ${errorCount} stories`);
  console.log('');

  if (successCount > 0) {
    console.log('Story Breakdown:');
    console.log('');
    userStories.forEach((story, idx) => {
      console.log(`  ${story.story_key}`);
      console.log(`    Title: ${story.title}`);
      console.log(`    Priority: ${story.priority.toUpperCase()} | Points: ${story.story_points}`);
      console.log(`    Maps to: ${story.maps_to_requirement || 'N/A'}`);
      console.log(`    AC Count: ${story.acceptance_criteria.length}`);
      console.log('');
    });

    console.log('Priority Breakdown:');
    const mustHave = userStories.filter(s => s.priority === 'must_have').length;
    const shouldHave = userStories.filter(s => s.priority === 'should_have').length;
    const couldHave = userStories.filter(s => s.priority === 'could_have').length;
    console.log(`  Must Have: ${mustHave} stories`);
    console.log(`  Should Have: ${shouldHave} stories`);
    console.log(`  Could Have: ${couldHave} stories`);
    console.log('');

    console.log('Requirement Coverage:');
    console.log('  FR-001 (Stage Contracts API): US-001');
    console.log('  FR-002 (Supervision Policies API): US-002');
    console.log('  FR-003 (Compliance Overview API): US-003');
    console.log('  FR-004 (Audit Log API): US-004');
    console.log('  FR-005 (Protocol Status API): US-005');
    console.log('  UI-001 to UI-006 (React Hooks): US-006');
    console.log('  E2E Test Coverage: US-007');
    console.log('');

    console.log('Next Steps:');
    console.log('  1. Review and approve user stories');
    console.log('  2. Begin EXEC phase implementation');
    console.log('  3. Create E2E tests following US-XXX naming convention');
  }
}

// ============================================================================
// OUTPUT JSON FOR DATABASE (alternative to running script)
// ============================================================================

function outputJSON() {
  const jsonOutput = userStories.map(story => ({
    title: story.title,
    story: `As a ${story.user_role}, I want to ${story.user_want}, so that I can ${story.user_benefit}`,
    acceptance_criteria: story.acceptance_criteria.map(ac =>
      `Given ${ac.given}, When ${ac.when}, Then ${ac.then}`
    ),
    priority: story.priority,
    story_points: story.story_points
  }));

  console.log('\n=== JSON OUTPUT FOR DATABASE ===\n');
  console.log(JSON.stringify(jsonOutput, null, 2));
}

// ============================================================================
// RUN
// ============================================================================

const args = process.argv.slice(2);
if (args.includes('--json-only')) {
  outputJSON();
} else {
  insertUserStories().catch(err => {
    console.error('Fatal error:', err);
    process.exit(1);
  });
}
