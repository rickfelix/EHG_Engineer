# ============================================================================
# STAGE 0: Direct Commit to Main Protection (BLOCKING)
# ============================================================================
# LEO Protocol requires all work to be done on feature branches.
# Direct commits to main are blocked to enforce proper workflow.
# ============================================================================

BRANCH=$(git rev-parse --abbrev-ref HEAD)

if [ "$BRANCH" = "main" ]; then
  echo ""
  echo "âŒ BLOCKED: Direct commits to main are not allowed!"
  echo ""
  echo "   LEO Protocol requires all work on feature branches."
  echo ""
  echo "   To fix this:"
  echo "   1. Create a Strategic Directive: npm run sd:create"
  echo "   2. Run PLAN-TO-EXEC handoff: node scripts/handoff.js plan-to-exec"
  echo "      (This creates your feature branch automatically)"
  echo ""
  echo "   Or manually create a branch:"
  echo "   git checkout -b feat/SD-XXX-description"
  echo "   git checkout -b quick-fix/QF-YYYYMMDD-NNN"
  echo ""
  echo "   Emergency bypass (logged): git commit --no-verify"
  echo ""
  exit 1
fi

# ============================================================================
# STAGE 1: Secret Detection (BLOCKING)
# ============================================================================
# SD-SEC-CREDENTIAL-ROTATION-001: Prevent accidental commit of secrets
# Checks staged files for common API key and credential patterns
# ============================================================================
echo ""
echo "ğŸ” Running secret detection scan..."

# Get all staged file contents (excluding pre-commit hook itself to avoid false positives)
# The hook contains regex patterns that would otherwise trigger detection
STAGED_CONTENT=$(git diff --cached --diff-filter=ACM -U0 -- ':!.husky/pre-commit' ':!.githooks/*' 2>/dev/null || true)

# Define secret patterns (regex)
# These patterns match common API key and credential formats
SECRET_PATTERNS=(
  # Supabase/JWT tokens (eyJ prefix)
  'eyJ[A-Za-z0-9_-]{20,}\.[A-Za-z0-9_-]{20,}'
  # OpenAI API keys
  'sk-[A-Za-z0-9]{20,}'
  # Anthropic API keys
  'sk-ant-[A-Za-z0-9_-]{20,}'
  # Resend API keys
  're_[A-Za-z0-9_]{20,}'
  # Generic API key patterns
  'api[_-]?key["\s:=]+["\047][A-Za-z0-9_-]{20,}["\047]'
  # AWS Access Keys
  'AKIA[0-9A-Z]{16}'
  # AWS Secret Keys
  'aws[_-]?secret[_-]?access[_-]?key["\s:=]+["\047][A-Za-z0-9/+=]{40}["\047]'
  # Generic secret patterns
  'secret[_-]?key["\s:=]+["\047][A-Za-z0-9_-]{16,}["\047]'
  # Private keys
  '-----BEGIN (RSA |EC |DSA |OPENSSH )?PRIVATE KEY-----'
  # Database connection strings with passwords
  'postgresql://[^:]+:[^@]+@'
)

SECRETS_FOUND=0
SECRET_DETAILS=""

for pattern in "${SECRET_PATTERNS[@]}"; do
  MATCHES=$(echo "$STAGED_CONTENT" | grep -oiE "$pattern" 2>/dev/null | head -5 || true)
  if [ ! -z "$MATCHES" ]; then
    SECRETS_FOUND=1
    # Redact the actual secret for display
    REDACTED=$(echo "$MATCHES" | sed 's/\(.\{8\}\).*/\1...REDACTED/')
    SECRET_DETAILS="${SECRET_DETAILS}   Pattern: ${pattern:0:30}...\n   Found: ${REDACTED}\n\n"
  fi
done

if [ "$SECRETS_FOUND" -eq 1 ]; then
  echo ""
  echo "âŒ BLOCKED: Potential secrets detected in staged files!"
  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  echo ""
  echo "The following patterns were detected:"
  echo ""
  echo -e "$SECRET_DETAILS"
  echo "SECURITY: Committing secrets to git history is a critical security risk."
  echo "          Even if deleted later, secrets remain in git history forever."
  echo ""
  echo "ğŸ’¡ REMEDIATION:"
  echo "   1. Remove secrets from staged files"
  echo "   2. Store secrets in .env files (which are gitignored)"
  echo "   3. Use environment variables or secret managers"
  echo ""
  echo "   If this is a false positive (e.g., test/mock data):"
  echo "   - Use clearly fake values: 'sk-test-fake-key-12345'"
  echo "   - Or bypass with: git commit --no-verify (logged, use sparingly)"
  echo ""
  exit 1
fi

echo "âœ… No secrets detected in staged files"

# ============================================================================
# Auto-fix Linting Issues
# ============================================================================
echo "ğŸ” Running ESLint auto-fix on staged files..."

# Get staged JS/TS files
STAGED_JS_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(js|ts|jsx|tsx)$' || true)

if [ ! -z "$STAGED_JS_FILES" ]; then
  echo "$STAGED_JS_FILES" | xargs npx eslint --fix --quiet 2>/dev/null || true

  # Re-add fixed files to staging
  echo "$STAGED_JS_FILES" | xargs git add 2>/dev/null || true

  echo "âœ… Auto-fix complete (staged files updated)"
else
  echo "â„¹ï¸  No JS/TS files to lint"
fi

echo ""

# ============================================================================
# Smoke Tests
# ============================================================================
echo "Running smoke tests before commit..."
npm run test:smoke

# Check exit code
if [ $? -ne 0 ]; then
  echo "âŒ Smoke tests failed. Commit aborted."
  echo "Run 'npm run test:smoke' to see details."
  exit 1
fi

echo "âœ… Smoke tests passed."

# ============================================================================
# PRD Schema Validation
# ============================================================================

# Get list of staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

# Check if any PRD scripts are being committed
PRD_SCRIPTS=$(echo "$STAGED_FILES" | grep -E "scripts/(create-prd|add-prd|generate-prd|update-prd|insert-prd|populate-prd)" || true)

if [ ! -z "$PRD_SCRIPTS" ]; then
  echo ""
  echo "ğŸ” Detected PRD script changes. Running schema validation..."
  echo ""

  # Run validation on changed scripts
  for script in $PRD_SCRIPTS; do
    if [ -f "$script" ]; then
      echo "Validating: $script"

      # Check if script uses deprecated fields
      DEPRECATED_FIELDS=$(grep -E "strategic_directive_id:|prd_id:|user_stories:|ui_components:|success_metrics:|risks_and_mitigations:|technical_architecture:|problem_statement:" "$script" | grep -v "// FIX:" | grep -v "\/\/" || true)

      if [ ! -z "$DEPRECATED_FIELDS" ]; then
        echo ""
        echo "âŒ PRD Schema Validation Failed: $script"
        echo ""
        echo "Found deprecated/invalid fields:"
        echo "$DEPRECATED_FIELDS"
        echo ""
        echo "ğŸ’¡ Fix suggestions:"
        echo "   - strategic_directive_id â†’ sd_uuid"
        echo "   - prd_id â†’ id"
        echo "   - user_stories â†’ (use separate table)"
        echo "   - ui_components â†’ metadata.ui_components"
        echo "   - success_metrics â†’ metadata.success_metrics"
        echo "   - risks_and_mitigations â†’ risks"
        echo "   - technical_architecture â†’ system_architecture"
        echo "   - problem_statement â†’ business_context"
        echo ""
        echo "ğŸ“š See docs/PRD_SCRIPTS_AUDIT_SUMMARY.md for field mapping guide"
        echo "ğŸ”§ Run 'npm run prd:audit:fix $script' to auto-fix common issues"
        echo ""
        exit 1
      fi

      # Check if script fetches sd_uuid
      if grep -q "product_requirements_v2" "$script"; then
        if ! grep -q "sd_uuid" "$script" && ! grep -q "uuid_id" "$script"; then
          echo ""
          echo "âš ï¸  Warning: $script may be missing sd_uuid population"
          echo "   Make sure you fetch uuid_id from strategic_directives_v2"
          echo "   See templates/prd-script-template.js for correct pattern"
          echo ""
        fi
      fi

      echo "âœ… $script passed validation"
    fi
  done

  echo ""
  echo "âœ… All PRD scripts validated successfully!"
fi

# ============================================================================
# DOCMON Database-First Compliance Check
# ============================================================================
echo ""
echo "ğŸ” Running DOCMON database-first compliance check..."
echo ""

# Get list of staged markdown files
STAGED_MD_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.md$' || true)

if [ ! -z "$STAGED_MD_FILES" ]; then
  # Check for Strategic Directive markdown files
  SD_FILES=$(echo "$STAGED_MD_FILES" | grep -E '^(docs/)?SD-.*\.md$' || true)

  # Check for PRD markdown files
  PRD_FILES=$(echo "$STAGED_MD_FILES" | grep -E '^(docs/)?PRD-.*\.md$' || true)

  # Check for handoff markdown files (exclude design docs, retrospectives, and reference docs)
  # Excludes: retrospectives/, docs/vision/, docs/plans/, docs/specs/, docs/reference/
  # SD-LEO-STREAMS-001: Added docs/reference/ exclusion for schema documentation
  HANDOFF_FILES=$(echo "$STAGED_MD_FILES" | grep -i 'handoff' | grep -v 'retrospectives/' | grep -v 'docs/vision/' | grep -v 'docs/plans/' | grep -v 'docs/specs/' | grep -v 'docs/reference/' || true)

  VIOLATIONS=""

  if [ ! -z "$SD_FILES" ]; then
    VIOLATIONS="${VIOLATIONS}Strategic Directive markdown files:\n$(echo "$SD_FILES" | sed 's/^/  - /')\n\n"
  fi

  if [ ! -z "$PRD_FILES" ]; then
    VIOLATIONS="${VIOLATIONS}PRD markdown files:\n$(echo "$PRD_FILES" | sed 's/^/  - /')\n\n"
  fi

  if [ ! -z "$HANDOFF_FILES" ]; then
    VIOLATIONS="${VIOLATIONS}Handoff markdown files:\n$(echo "$HANDOFF_FILES" | sed 's/^/  - /')\n\n"
  fi

  if [ ! -z "$VIOLATIONS" ]; then
    echo "âŒ DOCMON: Database-First Violation Detected!"
    echo ""
    echo "The following files violate database-first architecture:"
    echo ""
    echo -e "$VIOLATIONS"
    echo "ğŸ’¡ Fix Instructions:"
    echo ""

    if [ ! -z "$SD_FILES" ]; then
      echo "   Strategic Directives â†’ Use database:"
      echo "   Run: npm run leo:new"
      echo "   Or:  node scripts/create-strategic-directive.js"
      echo ""
    fi

    if [ ! -z "$PRD_FILES" ]; then
      echo "   PRDs â†’ Use database:"
      echo "   Run: node scripts/add-prd-to-database.js"
      echo ""
    fi

    if [ ! -z "$HANDOFF_FILES" ]; then
      echo "   Handoffs â†’ Use database:"
      echo "   Run: node scripts/unified-handoff-system.js"
      echo ""
    fi

    echo "ğŸ“š Database-first architecture ensures single source of truth."
    echo "   Markdown files should be generated FROM database, not created manually."
    echo ""
    echo "To bypass this check (not recommended): git commit --no-verify"
    echo ""
    exit 1
  fi
fi

echo "âœ… DOCMON: No database-first violations detected"

# ============================================================================
# Work Accumulation Warning (prevents 250+ script accumulation)
# ============================================================================
echo ""
echo "ğŸ” Checking for work accumulation..."

# Count untracked files
UNTRACKED_COUNT=$(git status --porcelain | grep "^??" | wc -l)
if [ "$UNTRACKED_COUNT" -gt 20 ]; then
  echo ""
  echo "âš ï¸  WARNING: $UNTRACKED_COUNT untracked files detected!"
  echo "   Consider reviewing and cleaning up before continuing."
  echo "   Run: git status --porcelain | grep '^??' | head -20"
  echo ""
fi

# Check if branch is far behind main
BEHIND=$(git rev-list --count HEAD..origin/main 2>/dev/null || echo 0)
if [ "$BEHIND" -gt 50 ]; then
  echo ""
  echo "âš ï¸  WARNING: Branch is $BEHIND commits behind main."
  echo "   Consider rebasing: git fetch origin && git rebase origin/main"
  echo ""
fi

# ============================================================================
# Branch Naming Convention Check (Warning only - main already blocked above)
# ============================================================================
# Note: Direct commits to main are blocked in STAGE 0 above.
# This section validates branch naming conventions AND SD identifier presence.
# SD-LEARN-FIX-ADDRESS-IMPROVEMENT-LEARN-001: Added SD identifier validation

# Valid prefixes: feat/, fix/, docs/, test/, quick-fix/, reports/
if ! echo "$BRANCH" | grep -qE '^(feat|fix|docs|test|quick-fix|reports)/'; then
  echo ""
  echo "âš ï¸  WARNING: Branch name '$BRANCH' does not follow convention."
  echo "   Expected prefixes: feat/, fix/, docs/, test/, quick-fix/, or reports/"
  echo ""
fi

# SD Identifier Validation for feat/ and fix/ branches
# Ensures work is properly tracked against a Strategic Directive
if echo "$BRANCH" | grep -qE '^(feat|fix)/'; then
  # Check for SD identifier pattern: SD-XXX-NNN, SD-XXX-CATEGORY-NNN, or SD-XXX-MULTI-SEGMENT-NNN
  # Updated to support variable-length SD identifiers like SD-LEO-SELF-IMPROVE-AIJUDGE-001
  if ! echo "$BRANCH" | grep -qiE 'SD-[A-Z]+(-[A-Z0-9]+)*-[0-9]+'; then
    # Also accept quick-fix pattern for fix/ branches: QF-YYYYMMDD-NNN
    if echo "$BRANCH" | grep -qE '^fix/' && echo "$BRANCH" | grep -qE 'QF-[0-9]{8}-[0-9]+'; then
      echo "   â„¹ï¸  Quick-fix pattern detected (QF-YYYYMMDD-NNN)"
    else
      echo ""
      echo "âš ï¸  WARNING: Branch '$BRANCH' missing SD identifier!"
      echo ""
      echo "   LEO Protocol requires branches to reference a Strategic Directive:"
      echo "   - feat/SD-FEATURE-001-description"
      echo "   - fix/SD-BUGFIX-002-description"
      echo "   - fix/QF-20260120-001-quick-fix-description"
      echo ""
      echo "   Without SD tracking, work may not be:"
      echo "   - Properly validated through LEO handoffs"
      echo "   - Captured in retrospectives"
      echo "   - Linked to requirements/PRDs"
      echo ""
      echo "   Create an SD first: npm run sd:create"
      echo "   Or use quick-fix: /quick-fix [description]"
      echo ""
    fi
  fi
fi

echo "âœ… Work accumulation check complete"

# ============================================================================
# STAGE 7: SD Status Validation - Gate 0 (BLOCKING)
# ============================================================================
# SD-LEO-GATE0-PRECOMMIT-001: Prevents commits when referenced SD is in draft
# status or LEAD_APPROVAL phase. Ensures LEO Protocol workflow is followed.
# ============================================================================
echo ""
echo "ğŸ” Running Gate 0: SD Status Validation..."

# Get commit message (try reading from staged commit or file)
# During commit, the message is passed via stdin or COMMIT_EDITMSG
COMMIT_MSG=""
if [ -f ".git/COMMIT_EDITMSG" ]; then
  COMMIT_MSG=$(cat .git/COMMIT_EDITMSG 2>/dev/null || true)
fi

# Also check branch name for SD reference
if [ -z "$COMMIT_MSG" ]; then
  COMMIT_MSG="$BRANCH"
fi

# Extract SD identifier pattern from commit message or branch name
# Matches: SD-LEO-GATE0-001, SD-FEATURE-001, SD-LEO-REFACTOR-LARGE-FILES-002
# Also matches multi-segment: SD-LEO-SELF-IMPROVE-AIJUDGE-001
SD_ID=$(echo "$COMMIT_MSG $BRANCH" | grep -oE 'SD-[A-Z]+(-[A-Z0-9]+)*-[0-9]+' | head -1)

if [ ! -z "$SD_ID" ]; then
  echo "   Found SD reference: $SD_ID"

  # Run validation script
  node scripts/validate-sd-commit.js "$SD_ID"
  VALIDATION_EXIT=$?

  if [ $VALIDATION_EXIT -ne 0 ]; then
    exit 1
  fi
else
  echo "   No SD reference found in branch/commit - skipping validation"
  echo "   â„¹ï¸  Non-SD branches (reports/, docs/) are allowed"
fi

echo "âœ… Gate 0 validation complete"

# ============================================================================
# STAGE 7.5: LOC Threshold Trigger (BLOCKING for large changes)
# ============================================================================
# SD-LEO-GATE0-LOCTHRESHOLD-001: Large changes (>500 LOC) require SD in EXEC phase
# This prevents refactoring/infrastructure work from bypassing LEO Protocol
# ============================================================================
echo ""
echo "ğŸ” Running LOC Threshold Check..."

# Calculate lines of code being added/modified in this commit
# Uses git diff --cached to get staged changes
LOC_ADDED=$(git diff --cached --numstat 2>/dev/null | awk '{ added += $1 } END { print added+0 }')
LOC_DELETED=$(git diff --cached --numstat 2>/dev/null | awk '{ deleted += $2 } END { print deleted+0 }')
LOC_TOTAL=$((LOC_ADDED + LOC_DELETED))

LOC_THRESHOLD=500

echo "   Lines changed: +$LOC_ADDED -$LOC_DELETED (total: $LOC_TOTAL)"

if [ "$LOC_TOTAL" -gt "$LOC_THRESHOLD" ]; then
  echo ""
  echo "âš ï¸  LARGE CHANGE DETECTED: $LOC_TOTAL lines (threshold: $LOC_THRESHOLD)"
  echo ""

  # SD-LEO-INFRA-PRE-COMMIT-HOOK-001: Exempt docs/, reports/, test/ branches from LOC threshold
  # These branches typically contain documentation regeneration, reports, or test additions
  # that don't need SD tracking (database-generated CLAUDE.md files often exceed 500 LOC)
  if echo "$BRANCH" | grep -qE '^(docs|reports|test)/'; then
    echo "   âœ… Large change permitted - documentation/reports/test branch"
    echo "   â„¹ï¸  Branch type '$(echo "$BRANCH" | cut -d'/' -f1)/' exempt from SD requirement"
  # If we have an SD, verify it's in EXEC phase
  elif [ ! -z "$SD_ID" ]; then
    echo "   SD detected: $SD_ID"
    echo "   âœ… Large change permitted - SD reference found"
  else
    echo ""
    echo "âŒ BLOCKED: Large change without SD reference!"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "   Changes: $LOC_TOTAL lines ($LOC_ADDED added, $LOC_DELETED deleted)"
    echo "   Threshold: $LOC_THRESHOLD lines"
    echo ""
    echo "   REASON: Changes exceeding $LOC_THRESHOLD lines require tracking"
    echo "   via a Strategic Directive in EXEC phase."
    echo ""
    echo "   REMEDIATION:"
    echo "   1. Create an SD for this work: npm run sd:create"
    echo "   2. Run LEAD-TO-PLAN then PLAN-TO-EXEC handoffs"
    echo "   3. Retry commit with SD reference in branch name"
    echo ""
    echo "   Or split changes into smaller commits (<$LOC_THRESHOLD lines)"
    echo ""
    echo "   For documentation regeneration: Use docs/ branch prefix"
    echo "   Emergency bypass (logged): git commit --no-verify"
    echo ""
    exit 1
  fi
else
  echo "   âœ… Below threshold - no SD required for size"
fi

echo "âœ… LOC threshold check complete"

# ============================================================================
# STAGE 9: Root Temp File Warning (NON-BLOCKING)
# ============================================================================
# (Renumbered from Stage 6 after Gate 0 additions)
echo ""
echo "ğŸ§¹ Checking for root temp files..."

# Count root-level temp files (one-off scripts and reports)
ROOT_TEMPS=$(ls -1 *.mjs *.cjs 2>/dev/null | wc -l)
ROOT_JSONS=$(ls -1 *-report*.json handoff-*.json 2>/dev/null | wc -l)
ROOT_TOTAL=$((ROOT_TEMPS + ROOT_JSONS))

if [ "$ROOT_TOTAL" -gt 10 ]; then
  echo ""
  echo "âš ï¸  WARNING: $ROOT_TOTAL temp files detected at repository root"
  echo "   Consider running: npm run leo:cleanup:root"
  echo ""
else
  echo "âœ… Root temp file check passed ($ROOT_TOTAL files)"
fi

echo ""
echo "âœ… Pre-commit checks passed. Proceeding with commit."
