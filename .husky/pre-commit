# ============================================================================
# STAGE 0: Direct Commit to Main Protection (BLOCKING)
# ============================================================================
# LEO Protocol requires all work to be done on feature branches.
# Direct commits to main are blocked to enforce proper workflow.
# ============================================================================

BRANCH=$(git rev-parse --abbrev-ref HEAD)

if [ "$BRANCH" = "main" ]; then
  echo ""
  echo "‚ùå BLOCKED: Direct commits to main are not allowed!"
  echo ""
  echo "   LEO Protocol requires all work on feature branches."
  echo ""
  echo "   To fix this:"
  echo "   1. Create a Strategic Directive: npm run sd:create"
  echo "   2. Run PLAN-TO-EXEC handoff: node scripts/handoff.js plan-to-exec"
  echo "      (This creates your feature branch automatically)"
  echo ""
  echo "   Or manually create a branch:"
  echo "   git checkout -b feat/SD-XXX-description"
  echo "   git checkout -b quick-fix/QF-YYYYMMDD-NNN"
  echo ""
  echo "   Emergency bypass (logged): git commit --no-verify"
  echo ""
  exit 1
fi

# ============================================================================
# STAGE 0.1: Branch Guard for Worktree Sessions (BLOCKING)
# ============================================================================
# SD-LEO-INFRA-GIT-WORKTREE-AUTOMATION-001 (FR-3)
# When working in a .sessions/ worktree, ensures the current branch matches
# the expected branch configured at worktree creation (.session.json).
# This prevents cross-session contamination (e.g., committing SD-A work to SD-B branch).
# ============================================================================

SESSION_CONFIG=".session.json"
if [ -f "$SESSION_CONFIG" ]; then
  EXPECTED_BRANCH=$(node -e "try{console.log(JSON.parse(require('fs').readFileSync('$SESSION_CONFIG','utf8')).expectedBranch||'')}catch{console.log('')}" 2>/dev/null || true)

  if [ ! -z "$EXPECTED_BRANCH" ] && [ "$EXPECTED_BRANCH" != "$BRANCH" ]; then
    if [ "$SKIP_BRANCH_GUARD" = "1" ]; then
      echo ""
      echo "  WARNING: Branch guard bypassed (SKIP_BRANCH_GUARD=1)"
      echo "  Expected: $EXPECTED_BRANCH"
      echo "  Actual:   $BRANCH"
      echo ""
    else
      echo ""
      echo "  BLOCKED: Branch mismatch in worktree session!"
      echo ""
      echo "  Expected branch: $EXPECTED_BRANCH"
      echo "  Current branch:  $BRANCH"
      echo ""
      echo "  This worktree was created for branch '$EXPECTED_BRANCH'."
      echo "  Committing on '$BRANCH' would contaminate another session."
      echo ""
      echo "  REMEDIATION:"
      echo "  1. Checkout the expected branch: git checkout $EXPECTED_BRANCH"
      echo "  2. Or recreate the worktree: npm run session:worktree -- --session <name> --branch $BRANCH --force"
      echo "  3. Bypass (not recommended): SKIP_BRANCH_GUARD=1 git commit ..."
      echo ""
      exit 1
    fi
  else
    echo "  Branch guard: $BRANCH matches expected branch"
  fi
elif [ -z "$EXPECTED_BRANCH" ] && git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
  # Not in a session worktree ‚Äî check if .session.json is missing but we're in .sessions/
  CURRENT_DIR=$(pwd)
  case "$CURRENT_DIR" in
    */.sessions/*)
      if [ "$BRANCH_GUARD_ALLOW_UNKNOWN" = "1" ]; then
        echo ""
        echo "  WARNING: In .sessions/ directory but no .session.json found."
        echo "  Cannot determine expected branch. Allowing due to BRANCH_GUARD_ALLOW_UNKNOWN=1"
        echo ""
      else
        echo ""
        echo "  BLOCKED: In .sessions/ directory but no .session.json found."
        echo "  Cannot determine expected branch for this worktree."
        echo ""
        echo "  REMEDIATION:"
        echo "  1. Recreate worktree: npm run session:worktree -- --session <name> --branch <branch>"
        echo "  2. Bypass: BRANCH_GUARD_ALLOW_UNKNOWN=1 git commit ..."
        echo ""
        exit 1
      fi
      ;;
  esac
fi

echo "  Branch guard check passed"

# ============================================================================
# STAGE 0.5: CLAUDE*.md Protection (BLOCKING)
# ============================================================================
# SD-LEO-SELF-IMPROVE-001A: Prevent direct edits to CLAUDE*.md files
# These files are auto-generated from database and should never be edited directly.
# Use: node scripts/generate-claude-md-from-db.js to regenerate
# ============================================================================

# Get staged CLAUDE*.md files (excluding deletions)
STAGED_CLAUDE_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -E '^CLAUDE.*\.md$' || true)

if [ ! -z "$STAGED_CLAUDE_FILES" ]; then
  echo ""
  echo "‚ùå BLOCKED: Direct modification of CLAUDE*.md files detected!"
  echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
  echo ""
  echo "The following files are auto-generated and should not be edited directly:"
  echo ""
  echo "$STAGED_CLAUDE_FILES" | sed 's/^/   - /'
  echo ""
  echo "These files are generated from the database using:"
  echo "   node scripts/generate-claude-md-from-db.js"
  echo ""
  echo "üí° REMEDIATION:"
  echo "   1. Unstage the CLAUDE files: git reset HEAD $STAGED_CLAUDE_FILES"
  echo "   2. Update content in the database (leo_protocol_sections table)"
  echo "   3. Regenerate: node scripts/generate-claude-md-from-db.js"
  echo "   4. Stage the regenerated files: git add CLAUDE*.md"
  echo ""
  echo "   If you are regenerating (not editing manually):"
  echo "   - Check that the files match the generator output"
  echo "   - Emergency bypass (logged): git commit --no-verify"
  echo ""
  echo "üìö Reference: CONST-005 Database First Rule"
  echo "   'All protocol content lives in database tables.'"
  echo "   'CLAUDE.md is generated, never edited directly.'"
  echo ""

  # Allow if files contain generator markers (AUTO-GENERATED and Last Generated timestamp)
  # This allows committing regenerated files while blocking manual edits
  ALL_REGENERATED=1
  for file in $STAGED_CLAUDE_FILES; do
    # Check for both markers that the generator adds
    HAS_AUTO_GEN=$(grep -c "AUTO-GENERATED from the database" "$file" 2>/dev/null || echo 0)
    HAS_TIMESTAMP=$(grep -c "Last Generated.*:" "$file" 2>/dev/null || echo 0)

    if [ "$HAS_AUTO_GEN" -eq 0 ] || [ "$HAS_TIMESTAMP" -eq 0 ]; then
      echo "   ‚ùå $file missing generator markers"
      ALL_REGENERATED=0
    fi
  done

  if [ "$ALL_REGENERATED" -eq 1 ]; then
    echo ""
    echo "   ‚úÖ All CLAUDE files have valid generator markers"
    echo "   ‚ÑπÔ∏è  Allowing regenerated files (not manual edits)"
    echo ""
  else
    echo ""
    echo "   Some files appear to be manually edited (missing generator markers)"
    exit 1
  fi
fi

echo "‚úÖ CLAUDE*.md protection check passed"

# ============================================================================
# STAGE 1: Secret Detection (BLOCKING)
# ============================================================================
# SD-SEC-CREDENTIAL-ROTATION-001: Prevent accidental commit of secrets
# Checks staged files for common API key and credential patterns
# ============================================================================
echo ""
echo "üîê Running secret detection scan..."

# Get all staged file contents (excluding pre-commit hook itself to avoid false positives)
# The hook contains regex patterns that would otherwise trigger detection
STAGED_CONTENT=$(git diff --cached --diff-filter=ACM -U0 -- ':!.husky/pre-commit' ':!.githooks/*' 2>/dev/null || true)

# Define secret patterns (regex)
# These patterns match common API key and credential formats
SECRET_PATTERNS=(
  # Supabase/JWT tokens (eyJ prefix)
  'eyJ[A-Za-z0-9_-]{20,}\.[A-Za-z0-9_-]{20,}'
  # OpenAI API keys
  'sk-[A-Za-z0-9]{20,}'
  # Anthropic API keys
  'sk-ant-[A-Za-z0-9_-]{20,}'
  # Resend API keys (word boundary prevents false positives on filenames like VENTURE_STAGE...)
  '\bre_[A-Za-z0-9_]{20,}'
  # Generic API key patterns
  'api[_-]?key["\s:=]+["\047][A-Za-z0-9_-]{20,}["\047]'
  # AWS Access Keys
  'AKIA[0-9A-Z]{16}'
  # AWS Secret Keys
  'aws[_-]?secret[_-]?access[_-]?key["\s:=]+["\047][A-Za-z0-9/+=]{40}["\047]'
  # Generic secret patterns
  'secret[_-]?key["\s:=]+["\047][A-Za-z0-9_-]{16,}["\047]'
  # Private keys
  '-----BEGIN (RSA |EC |DSA |OPENSSH )?PRIVATE KEY-----'
  # Database connection strings with passwords
  'postgresql://[^:]+:[^@]+@'
)

SECRETS_FOUND=0
SECRET_DETAILS=""

for pattern in "${SECRET_PATTERNS[@]}"; do
  MATCHES=$(echo "$STAGED_CONTENT" | grep -oiE "$pattern" 2>/dev/null | head -5 || true)
  if [ ! -z "$MATCHES" ]; then
    SECRETS_FOUND=1
    # Redact the actual secret for display
    REDACTED=$(echo "$MATCHES" | sed 's/\(.\{8\}\).*/\1...REDACTED/')
    SECRET_DETAILS="${SECRET_DETAILS}   Pattern: ${pattern:0:30}...\n   Found: ${REDACTED}\n\n"
  fi
done

if [ "$SECRETS_FOUND" -eq 1 ]; then
  echo ""
  echo "‚ùå BLOCKED: Potential secrets detected in staged files!"
  echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
  echo ""
  echo "The following patterns were detected:"
  echo ""
  echo -e "$SECRET_DETAILS"
  echo "SECURITY: Committing secrets to git history is a critical security risk."
  echo "          Even if deleted later, secrets remain in git history forever."
  echo ""
  echo "üí° REMEDIATION:"
  echo "   1. Remove secrets from staged files"
  echo "   2. Store secrets in .env files (which are gitignored)"
  echo "   3. Use environment variables or secret managers"
  echo ""
  echo "   If this is a false positive (e.g., test/mock data):"
  echo "   - Use clearly fake values: 'sk-test-fake-key-12345'"
  echo "   - Or bypass with: git commit --no-verify (logged, use sparingly)"
  echo ""
  exit 1
fi

echo "‚úÖ No secrets detected in staged files"

# ============================================================================
# Auto-fix Linting Issues
# ============================================================================
echo "üîç Running ESLint auto-fix on staged files..."

# Get staged JS/TS files
STAGED_JS_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(js|ts|jsx|tsx)$' || true)

if [ ! -z "$STAGED_JS_FILES" ]; then
  echo "$STAGED_JS_FILES" | xargs npx eslint --fix --quiet 2>/dev/null || true

  # Re-add fixed files to staging
  echo "$STAGED_JS_FILES" | xargs git add 2>/dev/null || true

  echo "‚úÖ Auto-fix complete (staged files updated)"
else
  echo "‚ÑπÔ∏è  No JS/TS files to lint"
fi

echo ""

# ============================================================================
# Smoke Tests
# ============================================================================
echo "Running smoke tests before commit..."
npm run test:smoke

# Check exit code
if [ $? -ne 0 ]; then
  echo "‚ùå Smoke tests failed. Commit aborted."
  echo "Run 'npm run test:smoke' to see details."
  exit 1
fi

echo "‚úÖ Smoke tests passed."

# ============================================================================
# PRD Schema Validation
# ============================================================================

# Get list of staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

# Check if any PRD scripts are being committed
PRD_SCRIPTS=$(echo "$STAGED_FILES" | grep -E "scripts/(create-prd|add-prd|generate-prd|update-prd|insert-prd|populate-prd)" || true)

if [ ! -z "$PRD_SCRIPTS" ]; then
  echo ""
  echo "üîç Detected PRD script changes. Running schema validation..."
  echo ""

  # Run validation on changed scripts
  for script in $PRD_SCRIPTS; do
    if [ -f "$script" ]; then
      echo "Validating: $script"

      # Check if script uses deprecated fields
      DEPRECATED_FIELDS=$(grep -E "strategic_directive_id:|prd_id:|user_stories:|ui_components:|success_metrics:|risks_and_mitigations:|technical_architecture:|problem_statement:" "$script" | grep -v "// FIX:" | grep -v "\/\/" || true)

      if [ ! -z "$DEPRECATED_FIELDS" ]; then
        echo ""
        echo "‚ùå PRD Schema Validation Failed: $script"
        echo ""
        echo "Found deprecated/invalid fields:"
        echo "$DEPRECATED_FIELDS"
        echo ""
        echo "üí° Fix suggestions:"
        echo "   - strategic_directive_id ‚Üí sd_uuid"
        echo "   - prd_id ‚Üí id"
        echo "   - user_stories ‚Üí (use separate table)"
        echo "   - ui_components ‚Üí metadata.ui_components"
        echo "   - success_metrics ‚Üí metadata.success_metrics"
        echo "   - risks_and_mitigations ‚Üí risks"
        echo "   - technical_architecture ‚Üí system_architecture"
        echo "   - problem_statement ‚Üí business_context"
        echo ""
        echo "üìö See docs/PRD_SCRIPTS_AUDIT_SUMMARY.md for field mapping guide"
        echo "üîß Run 'npm run prd:audit:fix $script' to auto-fix common issues"
        echo ""
        exit 1
      fi

      # Check if script fetches sd_uuid
      if grep -q "product_requirements_v2" "$script"; then
        if ! grep -q "sd_uuid" "$script" && ! grep -q "uuid_id" "$script"; then
          echo ""
          echo "‚ö†Ô∏è  Warning: $script may be missing sd_uuid population"
          echo "   Make sure you fetch uuid_id from strategic_directives_v2"
          echo "   See templates/prd-script-template.js for correct pattern"
          echo ""
        fi
      fi

      echo "‚úÖ $script passed validation"
    fi
  done

  echo ""
  echo "‚úÖ All PRD scripts validated successfully!"
fi

# ============================================================================
# DOCMON Database-First Compliance Check
# ============================================================================
echo ""
echo "üîç Running DOCMON database-first compliance check..."
echo ""

# Get list of staged markdown files
STAGED_MD_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.md$' || true)

if [ ! -z "$STAGED_MD_FILES" ]; then
  # Check for Strategic Directive markdown files
  SD_FILES=$(echo "$STAGED_MD_FILES" | grep -E '^(docs/)?SD-.*\.md$' || true)

  # Check for PRD markdown files
  PRD_FILES=$(echo "$STAGED_MD_FILES" | grep -E '^(docs/)?PRD-.*\.md$' || true)

  # Check for handoff markdown files (exclude design docs, retrospectives, reference docs, and slash commands)
  # Excludes: retrospectives/, docs/vision/, docs/plans/, docs/specs/, docs/reference/, .claude/commands/
  # SD-LEO-STREAMS-001: Added docs/reference/ exclusion for schema documentation
  HANDOFF_FILES=$(echo "$STAGED_MD_FILES" | grep -i 'handoff' | grep -v 'retrospectives/' | grep -v 'docs/vision/' | grep -v 'docs/plans/' | grep -v 'docs/specs/' | grep -v 'docs/reference/' | grep -v '\.claude/commands/' || true)

  VIOLATIONS=""

  if [ ! -z "$SD_FILES" ]; then
    VIOLATIONS="${VIOLATIONS}Strategic Directive markdown files:\n$(echo "$SD_FILES" | sed 's/^/  - /')\n\n"
  fi

  if [ ! -z "$PRD_FILES" ]; then
    VIOLATIONS="${VIOLATIONS}PRD markdown files:\n$(echo "$PRD_FILES" | sed 's/^/  - /')\n\n"
  fi

  if [ ! -z "$HANDOFF_FILES" ]; then
    VIOLATIONS="${VIOLATIONS}Handoff markdown files:\n$(echo "$HANDOFF_FILES" | sed 's/^/  - /')\n\n"
  fi

  if [ ! -z "$VIOLATIONS" ]; then
    echo "‚ùå DOCMON: Database-First Violation Detected!"
    echo ""
    echo "The following files violate database-first architecture:"
    echo ""
    echo -e "$VIOLATIONS"
    echo "üí° Fix Instructions:"
    echo ""

    if [ ! -z "$SD_FILES" ]; then
      echo "   Strategic Directives ‚Üí Use database:"
      echo "   Run: npm run leo:new"
      echo "   Or:  node scripts/create-strategic-directive.js"
      echo ""
    fi

    if [ ! -z "$PRD_FILES" ]; then
      echo "   PRDs ‚Üí Use database:"
      echo "   Run: node scripts/add-prd-to-database.js"
      echo ""
    fi

    if [ ! -z "$HANDOFF_FILES" ]; then
      echo "   Handoffs ‚Üí Use database:"
      echo "   Run: node scripts/unified-handoff-system.js"
      echo ""
    fi

    echo "üìö Database-first architecture ensures single source of truth."
    echo "   Markdown files should be generated FROM database, not created manually."
    echo ""
    echo "To bypass this check (not recommended): git commit --no-verify"
    echo ""
    exit 1
  fi
fi

echo "‚úÖ DOCMON: No database-first violations detected"

# ============================================================================
# Work Accumulation Warning (prevents 250+ script accumulation)
# ============================================================================
echo ""
echo "üîç Checking for work accumulation..."

# Count untracked files
UNTRACKED_COUNT=$(git status --porcelain | grep "^??" | wc -l)
if [ "$UNTRACKED_COUNT" -gt 20 ]; then
  echo ""
  echo "‚ö†Ô∏è  WARNING: $UNTRACKED_COUNT untracked files detected!"
  echo "   Consider reviewing and cleaning up before continuing."
  echo "   Run: git status --porcelain | grep '^??' | head -20"
  echo ""
fi

# Check if branch is far behind main
BEHIND=$(git rev-list --count HEAD..origin/main 2>/dev/null || echo 0)
if [ "$BEHIND" -gt 50 ]; then
  echo ""
  echo "‚ö†Ô∏è  WARNING: Branch is $BEHIND commits behind main."
  echo "   Consider rebasing: git fetch origin && git rebase origin/main"
  echo ""
fi

# ============================================================================
# Branch Naming Convention Check (Warning only - main already blocked above)
# ============================================================================
# Note: Direct commits to main are blocked in STAGE 0 above.
# This section validates branch naming conventions AND SD identifier presence.
# SD-LEARN-FIX-ADDRESS-IMPROVEMENT-LEARN-001: Added SD identifier validation

# Valid prefixes: feat/, fix/, docs/, test/, quick-fix/, reports/
if ! echo "$BRANCH" | grep -qE '^(feat|fix|docs|test|quick-fix|reports)/'; then
  echo ""
  echo "‚ö†Ô∏è  WARNING: Branch name '$BRANCH' does not follow convention."
  echo "   Expected prefixes: feat/, fix/, docs/, test/, quick-fix/, or reports/"
  echo ""
fi

# SD Identifier Validation for feat/ and fix/ branches
# Ensures work is properly tracked against a Strategic Directive
if echo "$BRANCH" | grep -qE '^(feat|fix)/'; then
  # Check for SD identifier pattern: SD-XXX-NNN, SD-XXX-CATEGORY-NNN, or SD-XXX-MULTI-SEGMENT-NNN
  # Updated to support variable-length SD identifiers like SD-LEO-SELF-IMPROVE-AIJUDGE-001
  if ! echo "$BRANCH" | grep -qiE 'SD-[A-Z]+(-[A-Z0-9]+)*-[0-9]+'; then
    # Also accept quick-fix pattern for fix/ branches: QF-YYYYMMDD-NNN
    if echo "$BRANCH" | grep -qE '^fix/' && echo "$BRANCH" | grep -qE 'QF-[0-9]{8}-[0-9]+'; then
      echo "   ‚ÑπÔ∏è  Quick-fix pattern detected (QF-YYYYMMDD-NNN)"
    else
      echo ""
      echo "‚ö†Ô∏è  WARNING: Branch '$BRANCH' missing SD identifier!"
      echo ""
      echo "   LEO Protocol requires branches to reference a Strategic Directive:"
      echo "   - feat/SD-FEATURE-001-description"
      echo "   - fix/SD-BUGFIX-002-description"
      echo "   - fix/QF-20260120-001-quick-fix-description"
      echo ""
      echo "   Without SD tracking, work may not be:"
      echo "   - Properly validated through LEO handoffs"
      echo "   - Captured in retrospectives"
      echo "   - Linked to requirements/PRDs"
      echo ""
      echo "   Create an SD first: npm run sd:create"
      echo "   Or use quick-fix: /quick-fix [description]"
      echo ""
    fi
  fi
fi

echo "‚úÖ Work accumulation check complete"

# ============================================================================
# STAGE 7: SD Status Validation - Gate 0 (BLOCKING)
# ============================================================================
# SD-LEO-GATE0-PRECOMMIT-001: Prevents commits when referenced SD is in draft
# status or LEAD_APPROVAL phase. Ensures LEO Protocol workflow is followed.
# ============================================================================
echo ""
echo "üîç Running Gate 0: SD Status Validation..."

# Get commit message (try reading from staged commit or file)
# During commit, the message is passed via stdin or COMMIT_EDITMSG
COMMIT_MSG=""
if [ -f ".git/COMMIT_EDITMSG" ]; then
  COMMIT_MSG=$(cat .git/COMMIT_EDITMSG 2>/dev/null || true)
fi

# Also check branch name for SD reference
if [ -z "$COMMIT_MSG" ]; then
  COMMIT_MSG="$BRANCH"
fi

# Extract SD identifier pattern from commit message or branch name
# Matches: SD-LEO-GATE0-001, SD-FEATURE-001, SD-LEO-REFACTOR-LARGE-FILES-002
# Also matches multi-segment: SD-LEO-SELF-IMPROVE-AIJUDGE-001
SD_ID=$(echo "$COMMIT_MSG $BRANCH" | grep -oE 'SD-[A-Z]+(-[A-Z0-9]+)*-[0-9]+' | head -1)

if [ ! -z "$SD_ID" ]; then
  echo "   Found SD reference: $SD_ID"

  # Run validation script
  node scripts/validate-sd-commit.js "$SD_ID"
  VALIDATION_EXIT=$?

  if [ $VALIDATION_EXIT -ne 0 ]; then
    exit 1
  fi
else
  echo "   No SD reference found in branch/commit - skipping validation"
  echo "   ‚ÑπÔ∏è  Non-SD branches (reports/, docs/) are allowed"
fi

echo "‚úÖ Gate 0 validation complete"

# ============================================================================
# STAGE 7.5: LOC Threshold Trigger (BLOCKING for large changes)
# ============================================================================
# SD-LEO-GATE0-LOCTHRESHOLD-001: Large changes (>500 LOC) require SD in EXEC phase
# This prevents refactoring/infrastructure work from bypassing LEO Protocol
# ============================================================================
echo ""
echo "üîç Running LOC Threshold Check..."

# Calculate lines of code being added/modified in this commit
# Uses git diff --cached to get staged changes
LOC_ADDED=$(git diff --cached --numstat 2>/dev/null | awk '{ added += $1 } END { print added+0 }')
LOC_DELETED=$(git diff --cached --numstat 2>/dev/null | awk '{ deleted += $2 } END { print deleted+0 }')
LOC_TOTAL=$((LOC_ADDED + LOC_DELETED))

LOC_THRESHOLD=500

echo "   Lines changed: +$LOC_ADDED -$LOC_DELETED (total: $LOC_TOTAL)"

if [ "$LOC_TOTAL" -gt "$LOC_THRESHOLD" ]; then
  echo ""
  echo "‚ö†Ô∏è  LARGE CHANGE DETECTED: $LOC_TOTAL lines (threshold: $LOC_THRESHOLD)"
  echo ""

  # SD-LEO-INFRA-PRE-COMMIT-HOOK-001: Exempt docs/, reports/, test/ branches from LOC threshold
  # These branches typically contain documentation regeneration, reports, or test additions
  # that don't need SD tracking (database-generated CLAUDE.md files often exceed 500 LOC)
  if echo "$BRANCH" | grep -qE '^(docs|reports|test)/'; then
    echo "   ‚úÖ Large change permitted - documentation/reports/test branch"
    echo "   ‚ÑπÔ∏è  Branch type '$(echo "$BRANCH" | cut -d'/' -f1)/' exempt from SD requirement"
  # If we have an SD, verify it's in EXEC phase
  elif [ ! -z "$SD_ID" ]; then
    echo "   SD detected: $SD_ID"
    echo "   ‚úÖ Large change permitted - SD reference found"
  else
    echo ""
    echo "‚ùå BLOCKED: Large change without SD reference!"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo "   Changes: $LOC_TOTAL lines ($LOC_ADDED added, $LOC_DELETED deleted)"
    echo "   Threshold: $LOC_THRESHOLD lines"
    echo ""
    echo "   REASON: Changes exceeding $LOC_THRESHOLD lines require tracking"
    echo "   via a Strategic Directive in EXEC phase."
    echo ""
    echo "   REMEDIATION:"
    echo "   1. Create an SD for this work: npm run sd:create"
    echo "   2. Run LEAD-TO-PLAN then PLAN-TO-EXEC handoffs"
    echo "   3. Retry commit with SD reference in branch name"
    echo ""
    echo "   Or split changes into smaller commits (<$LOC_THRESHOLD lines)"
    echo ""
    echo "   For documentation regeneration: Use docs/ branch prefix"
    echo "   Emergency bypass (logged): git commit --no-verify"
    echo ""
    exit 1
  fi
else
  echo "   ‚úÖ Below threshold - no SD required for size"
fi

echo "‚úÖ LOC threshold check complete"

# ============================================================================
# STAGE 9: Root Temp File Warning (NON-BLOCKING)
# ============================================================================
# (Renumbered from Stage 6 after Gate 0 additions)
echo ""
echo "üßπ Checking for root temp files..."

# Count root-level temp files (one-off scripts and reports)
ROOT_TEMPS=$(ls -1 *.mjs *.cjs 2>/dev/null | wc -l)
ROOT_JSONS=$(ls -1 *-report*.json handoff-*.json 2>/dev/null | wc -l)
ROOT_TOTAL=$((ROOT_TEMPS + ROOT_JSONS))

if [ "$ROOT_TOTAL" -gt 10 ]; then
  echo ""
  echo "‚ö†Ô∏è  WARNING: $ROOT_TOTAL temp files detected at repository root"
  echo "   Consider running: npm run leo:cleanup:root"
  echo ""
else
  echo "‚úÖ Root temp file check passed ($ROOT_TOTAL files)"
fi

echo ""
echo "‚úÖ Pre-commit checks passed. Proceeding with commit."
