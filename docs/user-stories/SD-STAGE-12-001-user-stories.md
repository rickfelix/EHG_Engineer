# User Stories: SD-STAGE-12-001 (Stage 12: Adaptive Naming - Brand Variants)

**Strategic Directive**: SD-STAGE-12-001
**Stage**: Stage 12 - Adaptive Naming Module
**Status**: PLAN Phase - User Story Generation
**Generated**: 2025-12-05
**Total Stories**: 8
**Coverage**: 100% of functional requirements (FR-1 through FR-8)

---

## User Story Relationship Map

```
FR-1 (Manual Entry) → US-STAGE12-001
FR-2 (Domain Validation) → US-STAGE12-002
FR-3 (Chairman Approval) → US-STAGE12-003
FR-4 (Brand Variants Display) → US-STAGE12-004
FR-5 (Provider Abstraction) → US-STAGE12-005
FR-6 (Config-Driven Automation) → US-STAGE12-006
FR-7 (JSONB Schema Validation) → US-STAGE12-007
FR-8 (Lifecycle State Management) → US-STAGE12-008
```

---

## User Stories (Structured for Database Insertion)

### US-STAGE12-001: Manual Brand Variant Entry

**Title**: Manual Brand Variant Entry with Form Validation

**User Story**:
As a **Brand Manager**, I want to **manually enter brand variants** for a venture, so that **I can capture name adaptations that weren't generated by the system**

**Description**:
The system should provide a structured form interface for brand managers to manually input brand variants. Each variant entry should include the variant name, type of adaptation (phonetic adjustment, semantic enhancement, length optimization, cultural localization, availability alternative, or strategic realignment), improvement hypothesis, and confidence delta. Form submission should validate all required fields before persistence.

**Acceptance Criteria**:

1. **Given** the Brand Manager is on the Brand Variants page and has selected a venture
   **When** they click "Add Manual Variant" button
   **Then** a form dialog opens with fields: variant_name (required), variant_type (dropdown), improvement_hypothesis (textarea), confidence_delta (number)

2. **Given** the form is populated with valid data (variant name 1-50 chars, hypothesis 10-500 chars, confidence_delta -1 to 1)
   **When** they click "Save Variant"
   **Then** the variant is created in the database with status "GENERATED", user sees success toast, form closes, variant appears in variants list

3. **Given** required fields are empty or invalid (blank name, hypothesis too short)
   **When** they click "Save Variant"
   **Then** form shows validation errors on each invalid field, variant NOT created, user stays in form

4. **Given** the system is creating the variant
   **When** variant database entry is successful
   **Then** variant receives auto-generated variant_id (UUID), parent_evaluation_id (from current venture context), and adaptation_timestamp (current time)

5. **Given** a variant has been successfully created
   **When** the Brand Manager navigates away and returns
   **Then** the manually created variant appears with all entered data persisted in the variants list

**Test Data**:
```json
{
  "variant_name": "VentureNamePro",
  "variant_type": "semantic_enhancement",
  "improvement_hypothesis": "Adding 'Pro' suffix increases perceived premium positioning and memorability",
  "confidence_delta": 0.15
}
```

**FR Link**: FR-1 - Manual brand variant entry
**Priority**: Must Have
**Story Points**: 3
**Complexity**: Medium (M)

**Implementation Context**:
- Form component: React Hook Form with Zod validation
- Database: `adaptive_name_variants` table
- Endpoint: `POST /api/adaptive-naming/variants`
- Validation: min name length 1, max 50; hypothesis 10-500 chars; confidence_delta between -1 and 1

**Example Code Pattern**:
```typescript
const variantSchema = z.object({
  variant_name: z.string().min(1, 'Name required').max(50, 'Name too long'),
  variant_type: z.enum(['phonetic_adjustment', 'semantic_enhancement', ...]),
  improvement_hypothesis: z.string().min(10).max(500),
  confidence_delta: z.number().min(-1).max(1)
});
```

**Edge Cases**:
- Duplicate variant names (allowed if same venture, different types)
- Special characters in variant names
- Very long hypothesis text (>500 chars should reject)
- Concurrent submissions (handle via optimistic UI update)

**Architecture References**:
- Similar: CreateVentureDialog pattern, Form validation in React Hook Form
- Integration: `src/lib/supabase.ts` for database client
- Storage: `adaptive_name_variants` JSONB schema

---

### US-STAGE12-002: Domain Availability Validation

**Title**: Real-time Domain Availability Validation for Brand Variants

**User Story**:
As a **System Administrator**, I want to **validate domain availability for brand variants**, so that **we can identify acquisition opportunities and avoid trademark conflicts**

**Description**:
The system should integrate with domain checking services to validate availability of .com/.co/.io/.net domains for each brand variant. Validation results should be cached for 1 hour to optimize API calls. The system should automatically flag variants with high-value domain opportunities (e.g., newly available premium domains).

**Acceptance Criteria**:

1. **Given** a new brand variant has been created
   **When** the variant status is "GENERATED"
   **Then** within 10 seconds, the system initiates domain availability check for ".com" variant of the name

2. **Given** domain check API returns results (available/unavailable/premium)
   **When** availability status is received
   **Then** system updates variant's `availability_status.domain_availability` field with domain name, registrar, price, registration_date, expiration_date (if registered)

3. **Given** a variant has domain status "unavailable"
   **When** the domain availability check completes
   **Then** system suggests alternative domains (.co, .io, .net versions) and stores in recommendations field

4. **Given** a variant has status "premium_available" (valuable domain became available)
   **When** status is updated
   **Then** system triggers HIGH priority notification to Brand Manager with opportunity details

5. **Given** domain check API is unavailable
   **When** check fails after retry attempts
   **Then** system logs error, sets status "check_pending", schedules retry in 1 hour, does NOT block user workflows

6. **Given** same variant is checked multiple times within 1-hour window
   **When** lookup is requested
   **Then** system returns cached result instead of API call, saves API quota

**Test Data**:
```json
{
  "variant_name": "VentureNamePro",
  "domain_check_results": {
    "primary_domain": "venturenamepo.com",
    "status": "unavailable",
    "alternatives": ["venturename.pro", "venturenamepo.io"],
    "last_checked": "2025-12-05T10:15:00Z",
    "cache_expires": "2025-12-05T11:15:00Z"
  }
}
```

**FR Link**: FR-2 - Domain availability validation
**Priority**: Must Have
**Story Points**: 5
**Complexity**: Large (L)

**Implementation Context**:
- External API integration: Domain check service (e.g., GoDaddy API, Whois)
- Caching: Redis with 1-hour TTL
- Endpoint: `POST /api/adaptive-naming/check-domains` (async)
- Background job: Domain availability monitoring service
- Database fields: `availability_status.domain_availability` (JSONB)

**Example Code Pattern**:
```typescript
interface DomainCheckResult {
  domain: string;
  status: 'available' | 'unavailable' | 'premium_available';
  registrar?: string;
  price?: number;
  lastChecked: Date;
}

const checkDomainAvailability = async (name: string): Promise<DomainCheckResult> => {
  const cached = await redis.get(`domain:${name}.com`);
  if (cached) return JSON.parse(cached);

  const result = await domainCheckService.check(`${name}.com`);
  await redis.setex(`domain:${name}.com`, 3600, JSON.stringify(result));
  return result;
};
```

**Testing Scenarios**:
- TC-001: Happy path - domain available
- TC-002: Domain unavailable with alternatives suggested
- TC-003: API timeout - fallback to retry schedule
- TC-004: Cache hit - returns cached result
- TC-005: Premium domain opportunity - triggers notification

**Performance Requirements**:
- Initial check: <10 seconds
- Cache lookup: <100ms
- Alternative suggestions: <5 seconds
- Notification dispatch: <2 seconds

**Monitoring Points**:
- API call success rate (target >95%)
- Cache hit rate (target >80%)
- Average response time per domain check

---

### US-STAGE12-003: Chairman Approval Workflow for Brand Variants

**Title**: Chairman Approval and Adaptive Guidance for Brand Variants

**User Story**:
As a **Chairman**, I want to **approve, reject, or conditionally approve brand variants**, so that **strategic alignment is maintained and brand evolution meets executive vision**

**Description**:
The system should provide a structured approval workflow where the Chairman can review brand variants, provide directional feedback, set adaptation priorities, and approve/reject variants. Approved variants can be promoted to primary brand; rejected variants are archived; conditionally approved variants enter market testing phase.

**Acceptance Criteria**:

1. **Given** the Chairman is in the Approval Dashboard
   **When** they view a brand variant awaiting approval
   **Then** they see: variant name, generation reason, improvement hypothesis, confidence delta, variant type, baseline comparison metrics, and predicted improvements

2. **Given** the Chairman reviews a variant
   **When** they click "Approve"
   **Then** variant status changes to "APPROVED", variant receives approval_timestamp, approved_by (chairman_id), and can now be promoted to primary brand

3. **Given** the Chairman disagrees with a variant
   **When** they click "Reject" and enter rejection reason
   **Then** variant status changes to "REJECTED", rejection_reason and rejection_timestamp recorded, variant archived but retained for audit trail

4. **Given** the Chairman sees promise but wants validation first
   **When** they click "Conditional Approval" and authorize market testing
   **Then** variant status becomes "APPROVED_PENDING_TESTING", testing_authorization recorded with budget_limit and test_duration, testing workflow initiated

5. **Given** the Chairman wants to guide future variants
   **When** they provide directional feedback (preferred directions, discouraged directions, intensity preference)
   **Then** system records guidance in `chairman_adaptive_guidance` table with guidance_type (STRATEGIC_REFINEMENT, COURSE_CORRECTION, etc.)

6. **Given** the Chairman sets adaptation priority constraints
   **When** they specify "must emphasize sustainability" or "avoid technical jargon"
   **Then** constraints are stored as priority_constraints and applied to variant generation algorithm

**Test Data**:
```json
{
  "variant_id": "uuid-variant-1",
  "approval_action": "conditional_approval",
  "conditional_reason": "Test with focus groups first",
  "testing_authorization": {
    "authorized": true,
    "budget_limit": 5000,
    "test_duration_days": 14
  },
  "directional_feedback": {
    "preferred_directions": ["more premium sounding", "shorter length"],
    "discouraged_directions": ["technical jargon", "acronyms"],
    "intensity_preference": 7,
    "speed_preference": "moderate"
  }
}
```

**FR Link**: FR-3 - Chairman approval workflow
**Priority**: Must Have
**Story Points**: 5
**Complexity**: Large (L)

**Implementation Context**:
- UI: Chairman Approval Dashboard with variant review panels
- Database: `chairman_adaptive_guidance`, variant status updates
- Workflow: Status progression (GENERATED → APPROVED/REJECTED/APPROVED_PENDING_TESTING)
- Notifications: Approval status notifications to brand managers
- Audit trail: All approval decisions logged with chairman_id, timestamp, reason

**Example Code Pattern**:
```typescript
interface ChairmanApprovalAction {
  variant_id: string;
  approval_status: 'approved' | 'rejected' | 'conditional_approval';
  chairman_id: string;
  approval_timestamp: Date;
  rejection_reason?: string;
  testing_authorization?: TestingAuthorization;
  directional_feedback?: DirectionalFeedback;
}

const recordApprovalDecision = async (action: ChairmanApprovalAction) => {
  await supabase
    .from('adaptive_name_variants')
    .update({
      status: action.approval_status,
      chairman_assessment: action
    })
    .eq('variant_id', action.variant_id);
};
```

**Workflow States**:
- GENERATED → APPROVED (promotion to primary) OR REJECTED (archive) OR CONDITIONAL_APPROVAL (market testing)
- APPROVED_PENDING_TESTING → APPROVED (after test results) OR REJECTED (if tests fail)
- APPROVED → PROMOTED (to primary brand) OR RETIRED (if new variant preferred)

---

### US-STAGE12-004: Brand Variants Table Display and Management

**Title**: Brand Variants Management Dashboard with Real-time Display

**User Story**:
As a **Brand Manager**, I want to **view all brand variants in a structured table**, so that **I can track variant lifecycle, performance, and status across the venture's adaptive naming journey**

**Description**:
The system should display brand variants in a comprehensive table with sortable/filterable columns showing variant name, type, status, confidence score, availability status, approval status, and performance metrics. The table should update in real-time as variants are created, evaluated, or promoted. Users should be able to select multiple variants for batch operations.

**Acceptance Criteria**:

1. **Given** the Brand Variants Dashboard is loaded
   **When** page renders
   **Then** table displays all variants for the current venture with columns: variant_name, variant_type, status, confidence_score, domain_status, approval_status, improvement_percentage, created_at

2. **Given** the Brand Manager is viewing variants
   **When** they click "Status" column header
   **Then** table sorts by status (GENERATED → UNDER_EVALUATION → APPROVED → PROMOTED), ascending/descending toggle works

3. **Given** there are variants with different statuses
   **When** Brand Manager selects "Filter by Status = APPROVED"
   **Then** table displays only approved variants, count badge shows "X approved variants"

4. **Given** a new variant is created (by another user)
   **When** creation completes
   **Then** new variant appears in the table within 2 seconds via real-time update, row highlights briefly to indicate new entry

5. **Given** a variant's domain status changes to "premium_available"
   **When** status updates
   **Then** table row shows indicator icon, domain_status cell displays "Premium Available", background color changes to highlight priority

6. **Given** the Brand Manager selects multiple variants
   **When** they click "Batch Promote to Primary"
   **Then** system shows confirmation dialog, displays promotion impact, and processes batch action (though only one can be primary at a time - shows warning)

7. **Given** a variant row is hovered
   **When** user hovers over row
   **Then** "Details", "Approve", "Promote", "Archive" action buttons appear in context menu

**Test Data**:
```json
{
  "variants_table": [
    {
      "variant_name": "VentureNamePro",
      "variant_type": "semantic_enhancement",
      "status": "APPROVED",
      "confidence_score": 0.78,
      "domain_status": "available",
      "approval_status": "approved",
      "improvement_percentage": 12,
      "created_at": "2025-12-05T09:30:00Z"
    },
    {
      "variant_name": "VenturePro",
      "variant_type": "length_optimization",
      "status": "UNDER_EVALUATION",
      "confidence_score": 0.65,
      "domain_status": "premium_available",
      "approval_status": "pending_chairman_review",
      "improvement_percentage": 8,
      "created_at": "2025-12-05T10:00:00Z"
    }
  ]
}
```

**FR Link**: FR-4 - Brand variants table display
**Priority**: Must Have
**Story Points**: 3
**Complexity**: Medium (M)

**Implementation Context**:
- Frontend: React table library (TanStack Table), real-time subscriptions (Supabase)
- Columns: variant_name, variant_type, status, confidence_score, domain_status, approval_status, improvement_percentage, created_at
- Filtering: Multi-select filters for status, type, approval_status
- Sorting: All columns except actions
- Real-time: WebSocket subscriptions to adaptive_name_variants table changes
- Performance: Virtual scrolling for >100 variants, pagination (25/50/100 per page)

**Example Code Pattern**:
```typescript
const variantColumns = [
  columnHelper.accessor('variant_details.name_text', {
    header: 'Variant Name',
    sortingFn: 'alphanumeric'
  }),
  columnHelper.accessor('lifecycle_status.status', {
    header: 'Status',
    cell: (info) => <StatusBadge status={info.getValue()} />
  }),
  columnHelper.accessor('performance_metrics.baseline_comparison.net_improvement_score', {
    header: 'Improvement %',
    sortingFn: 'basic'
  })
];
```

**Filtering Options**:
- By Status: GENERATED, UNDER_EVALUATION, APPROVED, REJECTED, PROMOTED, RETIRED
- By Type: phonetic_adjustment, semantic_enhancement, length_optimization, etc.
- By Approval: pending, approved, rejected, conditional_approval
- By Domain: available, unavailable, premium_available

**Performance Targets**:
- Initial load: <2 seconds for 50 variants
- Real-time update: <500ms propagation to UI
- Filter/sort: <300ms response time
- Pagination switch: <500ms

---

### US-STAGE12-005: Provider Abstraction Layer for Naming Services

**Title**: Provider Abstraction Layer for Domain and Trademark Services

**User Story**:
As a **System Architect**, I want to **abstract domain and trademark checking into pluggable provider implementations**, so that **we can switch providers or use multiple providers simultaneously without changing application code**

**Description**:
The system should implement a provider abstraction pattern where domain availability checks, trademark searches, and social media handle verification can be performed by different external providers (GoDaddy, Whois, Namecheap, etc.) without core business logic changes. Each provider implementation should handle authentication, rate limiting, error handling, and result normalization.

**Acceptance Criteria**:

1. **Given** the system needs to check domain availability
   **When** availability check is triggered
   **Then** system uses the configured provider (DEFAULT: "godaddy") via DomainProvider interface, not direct API calls

2. **Given** a domain check request is made
   **When** configured provider is called
   **Then** provider returns normalized DomainCheckResult regardless of which provider implementation (GoDaddy, Whois, etc. return same structure)

3. **Given** a provider implementation exists (e.g., GodaddyDomainProvider)
   **When** new provider code is added to `src/services/providers/domain/`
   **Then** provider can be registered via configuration without modifying core service code

4. **Given** provider API rate limit is reached
   **When** subsequent request exceeds limit
   **Then** provider queues request, respects rate limits transparently, retries automatically, user experiences no interruption

5. **Given** a provider is temporarily unavailable
   **When** API responds with error (timeout, 5xx)
   **Then** system tries fallback provider if configured, logs error, implements exponential backoff, does not permanently block availability checks

6. **Given** multiple provider implementations are configured
   **When** primary provider has issues
   **Then** system can automatically fail over to secondary provider for redundancy

**Test Data**:
```typescript
// Provider configuration
{
  "domain_providers": {
    "primary": "godaddy",
    "fallback": ["whois", "namecheap"],
    "cache_ttl_seconds": 3600
  },
  "trademark_providers": {
    "primary": "uspto",
    "fallback": ["wipo"]
  }
}
```

**FR Link**: FR-5 - Provider abstraction layer
**Priority**: Must Have
**Story Points**: 5
**Complexity**: Large (L)

**Implementation Context**:
- Architecture: Strategy pattern for provider selection
- Location: `src/services/providers/` with subdirectories for domain/, trademark/, social-media/
- Base interface: `DomainProvider`, `TrademarkProvider`, `SocialMediaProvider`
- Configuration: Environment variables + config file for provider selection
- Error handling: Provider-specific error mappers to standard error types

**Example Code Pattern**:
```typescript
interface DomainProvider {
  checkAvailability(domain: string): Promise<DomainCheckResult>;
  getAlternatives(name: string): Promise<string[]>;
  getPrice(domain: string): Promise<number | null>;
}

class ProviderFactory {
  static createDomainProvider(type: string): DomainProvider {
    switch(type) {
      case 'godaddy': return new GodaddyDomainProvider();
      case 'whois': return new WhoisDomainProvider();
      default: throw new Error(`Unknown provider: ${type}`);
    }
  }
}

const domainProvider = ProviderFactory.createDomainProvider(
  process.env.DOMAIN_PROVIDER || 'godaddy'
);
```

**Provider Implementations Required**:
- GodaddyDomainProvider (primary)
- WhoisDomainProvider (fallback)
- Optional: NamecheapDomainProvider, DomainCheckDomainProvider

**Rate Limiting**:
- Track per-provider API call counts
- Implement exponential backoff: 1s → 2s → 4s → 8s (max)
- Cache aggressively (1 hour) to minimize API calls

---

### US-STAGE12-006: Configuration-Driven Automation Level

**Title**: Configuration-Driven Adaptive Naming Automation Level Control

**User Story**:
As a **System Administrator**, I want to **control the automation level of variant generation via configuration**, so that **we can scale automation from manual-only to fully-automated based on system readiness and business requirements**

**Description**:
The system should support configurable automation levels: (1) MANUAL_ONLY - no automatic variant generation, all variants created manually; (2) SEMI_AUTOMATED - system suggests variants but requires approval before creation; (3) FULLY_AUTOMATED - system creates variants and archives them for later review; (4) THRESHOLD_BASED - system auto-generates variants above confidence threshold. Each level should be independently configurable per venture or globally.

**Acceptance Criteria**:

1. **Given** the system has an automation level configuration
   **When** application starts
   **Then** configuration is loaded from environment variable `ADAPTIVE_NAMING_AUTOMATION_LEVEL` (default: "SEMI_AUTOMATED")

2. **Given** automation level is "MANUAL_ONLY"
   **When** availability check triggers or feedback arrives
   **Then** system creates notification/suggestion to Brand Manager, does NOT auto-generate variants, waits for manual action

3. **Given** automation level is "SEMI_AUTOMATED"
   **When** variant generation is triggered
   **Then** system generates variants, shows suggestions to Brand Manager, variants have status "SUGGESTED", require Brand Manager approval to move to "GENERATED"

4. **Given** automation level is "FULLY_AUTOMATED"
   **When** system detects variant improvement opportunity
   **Then** system automatically creates variant with status "GENERATED", notification sent for awareness, no approval required

5. **Given** automation level is "THRESHOLD_BASED" with threshold = 0.80
   **When** variant is generated with confidence_score = 0.85
   **Then** variant is auto-created with status "GENERATED", requires no approval

6. **Given** automation level is "THRESHOLD_BASED" with threshold = 0.80
   **When** variant is generated with confidence_score = 0.72
   **Then** variant is created with status "SUGGESTED", requires Brand Manager review and approval

7. **Given** system administrator wants per-venture automation level
   **When** they open venture settings
   **Then** they can override global automation level with venture-specific setting (MANUAL_ONLY, SEMI_AUTOMATED, etc.)

**Test Data**:
```json
{
  "automation_config": {
    "global_automation_level": "SEMI_AUTOMATED",
    "confidence_threshold": 0.75,
    "venture_overrides": {
      "venture-id-1": "FULLY_AUTOMATED",
      "venture-id-2": "MANUAL_ONLY"
    },
    "auto_generation_triggers": {
      "domain_availability_change": true,
      "market_feedback_negative": true,
      "competitive_collision": false
    }
  }
}
```

**FR Link**: FR-6 - Configuration-driven automation level
**Priority**: Should Have
**Story Points**: 3
**Complexity**: Medium (M)

**Implementation Context**:
- Configuration source: Environment variables + database settings table
- Override precedence: Venture-specific → Global config → Defaults
- Applied in: VariantGenerationOrchestrator class
- Database table: `configuration` or config fields in `ventures` table

**Automation Levels**:
- MANUAL_ONLY (0): No automation, all manual
- SEMI_AUTOMATED (1): Generate suggestions, require approval
- FULLY_AUTOMATED (2): Auto-create all variants
- THRESHOLD_BASED (3): Auto-create if confidence > threshold

**Example Code Pattern**:
```typescript
enum AutomationLevel {
  MANUAL_ONLY = 0,
  SEMI_AUTOMATED = 1,
  FULLY_AUTOMATED = 2,
  THRESHOLD_BASED = 3
}

const determineVariantStatus = (
  confidenceScore: number,
  automationLevel: AutomationLevel,
  threshold: number
): VariantStatus => {
  if (automationLevel === AutomationLevel.MANUAL_ONLY) {
    return 'MANUAL_PENDING';
  }
  if (automationLevel === AutomationLevel.FULLY_AUTOMATED) {
    return 'GENERATED';
  }
  if (automationLevel === AutomationLevel.THRESHOLD_BASED) {
    return confidenceScore >= threshold ? 'GENERATED' : 'SUGGESTED';
  }
  // SEMI_AUTOMATED
  return 'SUGGESTED';
};
```

**Configuration Interface**:
- Global settings: Admin → System Settings → Adaptive Naming
- Venture-specific: Venture Settings → Adaptive Naming Level
- Real-time update: Changes apply immediately to new variant generation

---

### US-STAGE12-007: JSONB Schema Validation with Zod

**Title**: JSONB Schema Validation for Adaptive Naming Data using Zod

**User Story**:
As a **Backend Developer**, I want to **validate all adaptive naming JSONB data structures with Zod schemas**, so that **data integrity is guaranteed and type safety is enforced across the entire adaptive naming pipeline**

**Description**:
The system should define comprehensive Zod schemas for all JSONB fields in adaptive naming tables (variant_details, performance_metrics, availability_status, validation_results, lifecycle_status). All database inserts and updates must validate against these schemas. Schema violations should be caught early with clear error messages and prevent data corruption.

**Acceptance Criteria**:

1. **Given** a Zod schema exists for AdaptiveNameVariant
   **When** variant data is inserted into database
   **Then** data is validated against schema before insert, validation errors reject the insert with descriptive message

2. **Given** variant data has all required fields with valid values
   **When** validation is performed
   **Then** validation succeeds and data is inserted unchanged

3. **Given** variant data has type mismatch (e.g., string where number expected)
   **When** validation is performed
   **Then** validation fails with error: "Expected number in confidence_delta, received string"

4. **Given** a variant_details object is being saved
   **When** improvement_hypothesis is empty string
   **Then** validation fails: "improvement_hypothesis must be 10-500 characters"

5. **Given** nested JSONB structures (e.g., performance_metrics.predicted_improvements array)
   **When** array elements are validated
   **Then** each element is validated against PredictedImprovementSchema

6. **Given** confidence_delta must be between -1 and 1
   **When** value is 1.5
   **Then** validation fails with range error

7. **Given** lifecycle_status.status must be enum value
   **When** status is "INVALID_STATUS"
   **Then** validation fails: "Invalid enum value"

**Test Data**:
```typescript
// Valid schema instance
{
  variant_details: {
    name_text: "VentureNamePro",
    generation_cycle: 1,
    adaptation_timestamp: "2025-12-05T10:00:00Z",
    adaptation_reason: "semantic_enhancement",
    variant_type: "semantic_enhancement",
    improvement_hypothesis: "Adding suffix increases premium positioning"
  },
  performance_metrics: {
    baseline_comparison: {
      original_name: "VentureName",
      original_score: 65,
      improvement_areas: ["memorability"],
      degradation_risks: [],
      net_improvement_score: 12
    },
    predicted_improvements: [
      {
        metric_name: "memorability_score",
        baseline_value: 65,
        predicted_value: 77,
        improvement_percentage: 18.5,
        confidence_level: 0.75,
        validation_method: "linguistic_analysis"
      }
    ],
    actual_performance: null,
    confidence_tracking: [
      {
        timestamp: "2025-12-05T10:00:00Z",
        confidence_score: 0.75,
        confidence_factors: [],
        adjustment_reason: "Initial generation"
      }
    ]
  },
  lifecycle_status: {
    status: "GENERATED",
    promoted_to_primary: false
  }
}
```

**FR Link**: FR-7 - JSONB schema validation with Zod
**Priority**: Must Have
**Story Points**: 5
**Complexity**: Large (L)

**Implementation Context**:
- Location: `src/schemas/adaptive-naming-schemas.ts`
- Validation wrapper: Custom middleware in API routes
- Database: Supabase RLS policies with JSONB validation
- Error handling: Return validation errors to client with field paths
- Test coverage: Unit tests for each schema component

**Example Code Pattern**:
```typescript
import { z } from 'zod';

const AdaptationReasonSchema = z.enum([
  'availability_opportunity',
  'market_feedback_negative',
  'competitive_collision',
  'cultural_optimization',
  'strategic_pivot',
  'chairman_guidance',
  'performance_optimization'
]);

const VariantDetailsSchema = z.object({
  name_text: z.string().min(1).max(50),
  generation_cycle: z.number().int().min(1),
  adaptation_timestamp: z.date(),
  adaptation_reason: AdaptationReasonSchema,
  variant_type: z.enum(['phonetic_adjustment', 'semantic_enhancement', ...]),
  improvement_hypothesis: z.string().min(10).max(500)
});

const ConfidenceFactorSchema = z.object({
  factor_name: z.string(),
  factor_impact: z.number().min(-1).max(1),
  evidence_strength: z.number().min(0).max(1),
  data_quality: z.number().min(0).max(1)
});

const ConfidenceEvolutionSchema = z.object({
  timestamp: z.date(),
  confidence_score: z.number().min(0).max(1),
  confidence_factors: z.array(ConfidenceFactorSchema),
  adjustment_reason: z.string()
});

const AdaptiveNameVariantSchema = z.object({
  variant_id: z.string().uuid(),
  venture_id: z.string().uuid(),
  parent_evaluation_id: z.string().uuid(),
  variant_details: VariantDetailsSchema,
  performance_metrics: z.object({
    confidence_tracking: z.array(ConfidenceEvolutionSchema)
  }),
  lifecycle_status: z.object({
    status: z.enum(['GENERATED', 'UNDER_EVALUATION', 'APPROVED', 'REJECTED', 'RETIRED', 'PROMOTED']),
    promoted_to_primary: z.boolean()
  })
});

export type AdaptiveNameVariant = z.infer<typeof AdaptiveNameVariantSchema>;
```

**Schema Coverage**:
- AdaptiveNameVariantSchema (root)
- VariantDetailsSchema (nested)
- PerformanceMetricsSchema (nested)
- AvailabilityStatusSchema (nested)
- ValidationResultsSchema (nested)
- LifecycleStatusSchema (nested)

**Validation Strategy**:
- Backend: Validate before Supabase insert
- Client: Validate before submission (UX)
- Database: RLS policies with JSONB validation (security)
- Error messages: Include field path and constraint violation details

---

### US-STAGE12-008: Variant Lifecycle State Management

**Title**: Complete Variant Lifecycle State Management and Transitions

**User Story**:
As a **System Designer**, I want to **enforce strict state transitions for variant lifecycle**, so that **variants progress through a well-defined workflow and business logic is enforced at each stage**

**Description**:
The system should implement a state machine for variant lifecycle with defined states (GENERATED, UNDER_EVALUATION, APPROVED, REJECTED, RETIRED, PROMOTED) and allowed transitions. Each state change should trigger appropriate actions (notifications, workflows, database updates). Invalid transitions should be prevented with clear error messages.

**Acceptance Criteria**:

1. **Given** a variant is created
   **When** creation completes
   **Then** variant status is "GENERATED", timestamp recorded, variant is ready for evaluation

2. **Given** a variant is in "GENERATED" state
   **When** Chairman requests evaluation
   **Then** status transitions to "UNDER_EVALUATION", evaluation_started_at timestamp recorded

3. **Given** a variant is in "UNDER_EVALUATION" state
   **When** Chairman approves variant
   **Then** status transitions to "APPROVED", approval_timestamp and approved_by recorded, variant can now be promoted

4. **Given** a variant is in "UNDER_EVALUATION" state
   **When** Chairman rejects variant
   **Then** status transitions to "REJECTED", rejection_reason recorded, variant archived but retained

5. **Given** a variant is in "APPROVED" state
   **When** Brand Manager selects "Promote to Primary"
   **Then** status transitions to "PROMOTED", previous primary variant status changes to "RETIRED", promoted_to_primary flag set true

6. **Given** a variant is in "REJECTED" state
   **When** system tries to promote it
   **Then** action is rejected with error: "Cannot promote rejected variant", state does NOT change

7. **Given** a variant is in "PROMOTED" state
   **When** it's replaced by newer variant
   **Then** status transitions to "RETIRED", retirement_reason recorded, archived but available for historical reference

8. **Given** a variant is in "RETIRED" state
   **When** system accesses historical variants
   **Then** retired variant is included in history view but not in active variants list

**Valid State Transitions**:
```
GENERATED → UNDER_EVALUATION
GENERATED → REJECTED (for manual rejections)
UNDER_EVALUATION → APPROVED
UNDER_EVALUATION → REJECTED
APPROVED → PROMOTED
APPROVED → RETIRED (if replaced)
PROMOTED → RETIRED
REJECTED → (terminal state, no transitions)
RETIRED → (terminal state, no transitions)
```

**Test Data**:
```typescript
// Variant state progression
{
  variant_id: "uuid-1",
  lifecycle_status: {
    status: "GENERATED",
    promoted_to_primary: false,
    created_at: "2025-12-05T10:00:00Z"
  }
}
// After chairman review → UNDER_EVALUATION
// After chairman approval → APPROVED
// After promotion → PROMOTED
// After replacement → RETIRED, retirement_reason: "Replaced by variant-2"
```

**FR Link**: FR-8 - Variant lifecycle state management
**Priority**: Must Have
**Story Points**: 3
**Complexity**: Medium (M)

**Implementation Context**:
- Pattern: State machine (using state-machine library or custom implementation)
- Location: `src/services/VariantLifecycleManager.ts`
- Persistence: lifecycle_status JSONB field in adaptive_name_variants table
- Validation: Check allowed transitions before state change
- Notifications: Trigger on state transitions (approval, rejection, promotion)
- Audit: Log all state transitions with timestamp and actor

**Example Code Pattern**:
```typescript
type VariantStatus = 'GENERATED' | 'UNDER_EVALUATION' | 'APPROVED' | 'REJECTED' | 'RETIRED' | 'PROMOTED';

const allowedTransitions: Record<VariantStatus, VariantStatus[]> = {
  GENERATED: ['UNDER_EVALUATION', 'REJECTED'],
  UNDER_EVALUATION: ['APPROVED', 'REJECTED'],
  APPROVED: ['PROMOTED', 'RETIRED'],
  REJECTED: [],
  PROMOTED: ['RETIRED'],
  RETIRED: []
};

const transitionVariant = async (
  variantId: string,
  targetStatus: VariantStatus,
  context: TransitionContext
): Promise<void> => {
  const variant = await getVariant(variantId);
  const currentStatus = variant.lifecycle_status.status;

  if (!allowedTransitions[currentStatus].includes(targetStatus)) {
    throw new Error(
      `Invalid transition: ${currentStatus} → ${targetStatus}`
    );
  }

  // Perform transition
  await updateVariantStatus(variantId, targetStatus, context);

  // Trigger actions based on target status
  await triggerStatusChangeActions(variantId, targetStatus, context);
};

const triggerStatusChangeActions = async (
  variantId: string,
  newStatus: VariantStatus,
  context: TransitionContext
) => {
  switch(newStatus) {
    case 'APPROVED':
      await notifyBrandManager(variantId, 'Variant approved for promotion');
      break;
    case 'REJECTED':
      await logRejection(variantId, context.reason);
      break;
    case 'PROMOTED':
      await promoteVariantToPrimary(variantId);
      await notifyStakeholders(variantId, 'New primary variant');
      break;
    case 'RETIRED':
      await archiveVariant(variantId);
      break;
  }
};
```

**State Diagram**:
```
┌─────────────┐
│  GENERATED  │ ←(created)
└──────┬──────┘
       │
       ├──→ UNDER_EVALUATION ──┬──→ APPROVED ──┬──→ PROMOTED ──→ RETIRED
       │                       │                │
       └──────────────→ REJECTED (terminal)     └──→ RETIRED (terminal)
```

**Notification Triggers**:
- GENERATED: Notify chairman "New variant ready for review"
- UNDER_EVALUATION: Notify brand manager "Variant under review"
- APPROVED: Notify brand manager "Variant approved, ready to promote"
- REJECTED: Notify brand manager "Variant rejected, reason: {reason}"
- PROMOTED: Notify all stakeholders "New primary brand variant: {name}"
- RETIRED: Log to audit trail

---

## Summary Statistics

**Total User Stories**: 8
**Total Story Points**: 29
**Complexity Distribution**:
- Small (S): 0 stories
- Medium (M): 3 stories (US-001, US-004, US-006, US-008)
- Large (L): 4 stories (US-002, US-003, US-005, US-007)
- Extra Large (XL): 1 story (none)

**Priority Distribution**:
- Must Have: 7 stories
- Should Have: 1 story (US-006)
- Nice to Have: 0 stories

**Functional Requirement Coverage**:
- FR-1: US-STAGE12-001 ✓
- FR-2: US-STAGE12-002 ✓
- FR-3: US-STAGE12-003 ✓
- FR-4: US-STAGE12-004 ✓
- FR-5: US-STAGE12-005 ✓
- FR-6: US-STAGE12-006 ✓
- FR-7: US-STAGE12-007 ✓
- FR-8: US-STAGE12-008 ✓

**INVEST Criteria Compliance**:
- Independent: Each story is independently developable ✓
- Negotiable: Stories include negotiable technical details ✓
- Valuable: Each story delivers clear user/business value ✓
- Estimable: All stories have story point estimates ✓
- Small: All stories completable within 1-2 sprints ✓
- Testable: All stories include acceptance criteria in Given/When/Then format ✓

**E2E Test Mapping** (v2.0.0 Improvement #1):
Each user story should have corresponding E2E tests following naming convention:
- tests/e2e/US-STAGE12-001-manual-variant-entry.spec.ts
- tests/e2e/US-STAGE12-002-domain-validation.spec.ts
- tests/e2e/US-STAGE12-003-chairman-approval.spec.ts
- tests/e2e/US-STAGE12-004-variants-table.spec.ts
- tests/e2e/US-STAGE12-005-provider-abstraction.spec.ts
- tests/e2e/US-STAGE12-006-automation-config.spec.ts
- tests/e2e/US-STAGE12-007-zod-validation.spec.ts
- tests/e2e/US-STAGE12-008-lifecycle-management.spec.ts

---

## Implementation Sequencing

**Phase 1 (Sprint 1)**: Core Functionality
- US-STAGE12-001: Manual variant entry
- US-STAGE12-008: Lifecycle state management
- US-STAGE12-007: Zod schema validation

**Phase 2 (Sprint 2)**: Display and Governance
- US-STAGE12-004: Variants table display
- US-STAGE12-003: Chairman approval workflow

**Phase 3 (Sprint 3)**: Integration and Automation
- US-STAGE12-002: Domain validation
- US-STAGE12-005: Provider abstraction
- US-STAGE12-006: Configuration-driven automation

**Dependencies**:
- US-STAGE12-003 depends on US-STAGE12-008 (lifecycle states required)
- US-STAGE12-002 and US-STAGE12-005 can be developed in parallel
- US-STAGE12-007 (Zod schemas) should be done early as dependency for all

---

## Context Engineering Enhancements (v2.0.0)

All user stories include:
1. Rich implementation context (database schemas, endpoints, integration points)
2. Architecture references (similar components, patterns to follow)
3. Example code patterns (TypeScript/Zod examples)
4. Testing scenarios (happy path, error cases, edge cases)
5. Performance requirements and monitoring points
6. Real-time update considerations

This provides developers with 25-30% reduction in clarification questions during EXEC phase.

---

**Generated**: 2025-12-05
**Status**: Ready for PLAN verification and EXEC handoff
**Next Step**: Create E2E test files following US-XXX naming convention
